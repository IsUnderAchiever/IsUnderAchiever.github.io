<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>Docker - 折影轻梦</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="折影轻梦,Mixcm,轻惋,觅漫者,小舒同学,Xiaoshu,Nexmoe,产品,Meteor,探索者小舒,伴学OS1,Theme,Design,Product">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
    <meta name="description" content="Docker概念镜像:相当于容器的模板容器:可以理解成轻量级的虚拟机镜像仓库:存放镜像的仓库，官方的镜像仓库 https:&#x2F;&#x2F;hub.docker.com&#x2F;以下内容可能会使用到某些文件下载链接  可以使用镜像来不断创建容器，而镜像仓库则是存放镜像的地方  命令 官网文档  # 查看帮助文档docker --help# 查看某一个命令的用法，如 pulldocker pull --help# 下列命">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://nexmoe.com/bian-cheng-yu-yan/java/xue-xi/kuang-jia/docker/docker.html">
<meta property="og:site_name" content="折影轻梦">
<meta property="og:description" content="Docker概念镜像:相当于容器的模板容器:可以理解成轻量级的虚拟机镜像仓库:存放镜像的仓库，官方的镜像仓库 https:&#x2F;&#x2F;hub.docker.com&#x2F;以下内容可能会使用到某些文件下载链接  可以使用镜像来不断创建容器，而镜像仓库则是存放镜像的地方  命令 官网文档  # 查看帮助文档docker --help# 查看某一个命令的用法，如 pulldocker pull --help# 下列命">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240323184204498.png">
<meta property="og:image" content="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240324181016560.png">
<meta property="og:image" content="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240325062118495.png">
<meta property="og:image" content="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240325071054576.png">
<meta property="article:published_time" content="2024-04-21T04:12:00.000Z">
<meta property="article:modified_time" content="2024-06-01T14:12:24.921Z">
<meta property="article:author" content="折影轻梦">
<meta property="article:tag" content="折影轻梦,Mixcm,轻惋,觅漫者,小舒同学,Xiaoshu,Nexmoe,产品,Meteor,探索者小舒,伴学OS1,Theme,Design,Product">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240323184204498.png">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1717251230326">
    
    <link rel="stylesheet" href="/css/style.css?v=1717251230326">

    
        
            <link rel="stylesheet" href="/custom.css?v=1717251230326">
        
    

    
<script src="/lib/mdui_043tiny/mdui.js" async></script>
<script src="/lib/fancybox/fancybox.umd.js" async></script>


    <script async src="/js/app.js?v=1717251230326"></script>
    
     

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4D4ZJ9G024"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());

  gtag("config", "G-4D4ZJ9G024");
</script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-drawer-body-left">
    <div id="nexmoe-background">
        <div class="nexmoe-bg" 
            style="background-image: url(https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102206.jpg)"
        ></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="折影轻梦" class="mdui-btn mdui-btn-icon"><img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102017.jpg" alt="折影轻梦"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="折影轻梦">
            <img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102017.jpg" alt="折影轻梦" alt="折影轻梦">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>168</div>
        <div><span>标签</span>60</div>
        <div><span>分类</span>61</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/life.html" title="我的生活">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的生活
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博主">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博主
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
        
            
            <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>


	<script async src="/js/search.js?v=1717251230326"></script>



        
            
            <div class="nexmoe-widget-wrap">
	<div class="nexmoe-widget nexmoe-social">
		<a
			class="mdui-ripple"
			href="http://wpa.qq.com/msgrd?v=3&uin=938798576&site=qq&menu=yes"
			target="_blank"
			mdui-tooltip="{content: 'QQ群'}"
			style="
				color: rgb(249, 174, 8);
				background-color: rgba(249, 174, 8, .1);
			"
		>
			<i
				class="nexmoefont icon-QQ"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://space.bilibili.com/477448861/"
			target="_blank"
			mdui-tooltip="{content: '哔哩哔哩'}"
			style="
				color: rgb(231, 106, 141);
				background-color: rgba(231, 106, 141, .1);
			"
		>
			<i
				class="nexmoefont icon-bilibili"
			></i> </a
		>
	</div>
</div>

        
            
            
            
            
            
            
    </aside>
    <div class="nexmoe-copyright">
        &copy; 2024 折影轻梦
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
    <div class="nexmoe-post">
  <article>
    
        <div class="nexmoe-post-cover"> 
            <img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102206.jpg" alt="Docker" loading="lazy">
            <h1>Docker</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2024年04月21日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/Docker/">Docker</a>
        
        
    </div>
    
    
    
    
    
</div>

    <h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><p><code>镜像</code>:相当于容器的模板<br><code>容器</code>:可以理解成轻量级的虚拟机<br><code>镜像仓库</code>:存放镜像的仓库，官方的镜像仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a><br>以下内容可能会使用到<code>某些文件</code><a target="_blank" rel="noopener" href="https://wwl.lanzouj.com/iKTW01shae1c">下载链接</a></p>
<blockquote>
<p>可以使用镜像来不断创建容器，而镜像仓库则是存放镜像的地方</p>
</blockquote>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/reference/cli/docker/image/ls/">官网文档</a></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看帮助文档</span><br>docker --<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 查看某一个命令的用法，如 pull</span><br>docker pull --<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 下列命令中，[]括起来的可写可不写</span><br><span class="hljs-comment"># 下载镜像 标签如版本等，如果不指定标签，则默认是latest，如果不指定仓库，则默认是官方仓库</span><br>docker pull [镜像仓库/]镜像名[:标签]<br><span class="hljs-comment"># 查看镜像</span><br>docker images [选项]<br><span class="hljs-comment"># 衍生</span><br><span class="hljs-comment"># 使用帮助手册查看参数 docker images --help</span><br><span class="hljs-comment"># 查看镜像id</span><br>docker images -q<br><span class="hljs-comment"># 查看所有镜像</span><br>docker images -a<br><span class="hljs-comment"># 查看所有镜像id</span><br><span class="hljs-comment"># docker images -aq/docker images -a -q</span><br><span class="hljs-comment"># 列出镜像名为mysql的镜像</span><br><span class="hljs-comment"># 例子 docker images --filter=reference=&#x27;busy*:*libc&#x27;</span><br><span class="hljs-comment"># REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="hljs-comment"># busybox             uclibc              e02e811dd08f        5 weeks ago         1.09 MB</span><br><span class="hljs-comment"># busybox             glibc               21c16b6787c6        5 weeks ago         4.19 MB</span><br>docker images --filter=reference=<span class="hljs-string">&#x27;mysql&#x27;</span><br><span class="hljs-comment"># 列出容器信息</span><br><span class="hljs-comment"># 默认显示正在运行的信息</span><br>docker ps [选项]<br><span class="hljs-comment"># 显示全部容器</span><br>docke ps -a<br><span class="hljs-comment"># 列出所有退出状态的容器</span><br>    docker ps -f status=exited<br><span class="hljs-comment"># 列出所有退出状态的容器id</span><br>docker ps -qf status=exited<br></code></pre></td></tr></table></figure>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器继续运行的条件"><a href="#容器继续运行的条件" class="headerlink" title="容器继续运行的条件"></a>容器继续运行的条件</h3><blockquote>
<p><code>正常情况下</code>docker容器运行必须有一个前台进程，如果没有前台进程执行，容器认为空闲，就会自动退出</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建并运行容器</span><br>docker run [OPTIONS] IMAGES [COMMAND] [ARG...]<br><span class="hljs-comment"># options 选项，重点关注-d,-p,-v,-e,--restart</span><br><span class="hljs-comment"># images 镜像信息，推介使用 镜像名:tag 的写法</span><br><span class="hljs-comment"># command 创建容器后要执行的命令</span><br><span class="hljs-comment"># ars command命令的参数</span><br><span class="hljs-comment"># 如</span><br>docker run nginx:latest<br><span class="hljs-comment"># 容器运行后执行 ls命令</span><br>docker run nginx:latest <span class="hljs-built_in">ls</span><br>docker run nginx:latest <span class="hljs-built_in">ls</span> -a<br>docker run -d nginx:latest <span class="hljs-built_in">ls</span> -a<br></code></pre></td></tr></table></figure>
<h3 id="容器的运行方式"><a href="#容器的运行方式" class="headerlink" title="容器的运行方式"></a>容器的运行方式</h3><ol>
<li>后台运行 <code>docker run nginx:latest</code></li>
<li>默认运行 <code>docker run -d nginx:latest</code></li>
<li>交互式运行 <code>docker run -it nginx:latest</code><blockquote>
<p>-i 以交互模式运行容器，通常与-t一起使用</p>
<p>-t 启动容器后，为容器分配一个命令行，通常与-i一起使用</p>
<p>主要在学习阶段和调试的时候会使用到，并且一般容器的执行命令会使用bash,这样才能在进入容器后去执行命令</p>
<p><code>docker run -it nginx:latest bash</code>如果这样执行，则会覆盖nginx镜像默认的执行命令，此时并不会运行nginx，而是进入容器内部执行bash脚本</p>
<p>退出交互式<code>exit</code></p>
</blockquote>
</li>
</ol>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> [选项] [容器ID或容器名...]<br><span class="hljs-comment"># 例如 删除id为&quot;d34295b85f69&quot;的容器</span><br>docker <span class="hljs-built_in">rm</span> d34295b85f69<br><span class="hljs-comment"># 删除id为&quot;d34295b85f69&quot;和&quot;c0c9bf25c6a7&quot;的容器</span><br><span class="hljs-comment"># 容器id使用空格隔开</span><br>docker <span class="hljs-built_in">rm</span> d34295b85f69 c0c9bf25c6a7<br><span class="hljs-comment"># 运行中的容器无法直接删除，解决办法</span><br><span class="hljs-comment"># 1.停止运行容器，然后删除</span><br><span class="hljs-comment"># 2.强制删除</span><br>docker <span class="hljs-built_in">rm</span> -f c0c9bf25c6a7<br><span class="hljs-comment"># $()命令替换</span><br><span class="hljs-built_in">ls</span> $(<span class="hljs-built_in">pwd</span>)<br><span class="hljs-comment"># pwd 会显示当前目录</span><br><span class="hljs-comment"># ls $(pwd) 会打印当前目录下的内容</span><br><span class="hljs-comment"># 删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> $(docker ps -aq)<br><span class="hljs-comment"># 强制删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)<br><span class="hljs-comment"># 删除所有非运行状态的容器</span><br>docker <span class="hljs-built_in">rm</span> $(docker ps -f status=exited -q)<br></code></pre></td></tr></table></figure>
<h3 id="进入容器执行命令"><a href="#进入容器执行命令" class="headerlink" title="进入容器执行命令"></a>进入容器执行命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> [选项] 容器ID或容器名 命令[参数...]<br><span class="hljs-comment"># 如 docker exec 容器id ls</span><br>docker <span class="hljs-built_in">exec</span> 295731ae1fdf <span class="hljs-built_in">pwd</span><br><span class="hljs-comment"># 但是一次只能携带一个命令，是否可以使用交互式的方式</span><br>docke <span class="hljs-built_in">exec</span> -it 295731ae1fdf bash<br><span class="hljs-comment"># 使用curl的方式来查看nginx容器是否运行</span><br>curl http://127.0.0.1<br></code></pre></td></tr></table></figure>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker logs [选项] 容器ID或容器名<br>docker logs 295731ae1fdf<br><span class="hljs-comment"># 持续输出容器中的日志</span><br><span class="hljs-comment"># 执行完并不会返回，而是会等待是否有新的日志</span><br>docker logs -f 295731ae1fdf<br><span class="hljs-comment"># 查看最近的20条日志</span><br>docker logs -n 20 295731ae1fdf<br></code></pre></td></tr></table></figure>
<h3 id="容器文件拷贝"><a href="#容器文件拷贝" class="headerlink" title="容器文件拷贝"></a>容器文件拷贝</h3><blockquote>
<p>使用<code>docker cp</code>命令来实现容器与宿主机之间<code>文件和目录</code>的相互拷贝</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 把容器的文件拷贝到宿主机中</span><br>docker <span class="hljs-built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH<br><span class="hljs-comment"># docker cp 295731ae1fdf:/usr/share/nginx/html/index.html /home/index.html</span><br><span class="hljs-comment"># 把宿主机的文件拷贝到容器中</span><br>docker <span class="hljs-built_in">cp</span> [OPTIONS] SRC_PATH CONTAINER:DEST_PATH<br><span class="hljs-comment"># docker cp /home/cp_test 295731ae1fdf:/home/cp_test</span><br></code></pre></td></tr></table></figure>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker stop [容器ID或容器名...]<br><span class="hljs-comment"># docker stop 295731ae1fdf</span><br></code></pre></td></tr></table></figure>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker start [容器ID或容器名...]<br><span class="hljs-comment"># docker start 295731ae1fdf</span><br></code></pre></td></tr></table></figure>
<h3 id="run命令详解"><a href="#run命令详解" class="headerlink" title="run命令详解"></a>run命令详解</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">-p<br><span class="hljs-comment"># 将宿主机的端口映射到docker容器端口，通过宿主机的端口访问容器端口</span><br><span class="hljs-comment"># 发布一个端口</span><br>docker run -p 宿主机端口:容器端口 镜像名<br><span class="hljs-comment">#发布多个端口</span><br>docker run -p 宿主机端口1:容器端口1 -p 宿主机端口2:容器端口2 镜像名<br><span class="hljs-comment"># 怎么知道容器需要发布哪些端口呢？</span><br><span class="hljs-comment"># 1.DockerHub的介绍</span><br><span class="hljs-comment"># 2.构建容器的DockerFile(EXPOSE 80)</span><br>-v<br><span class="hljs-comment"># 数据卷</span><br></code></pre></td></tr></table></figure>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>为什么要使用数据卷？</p>
<ol>
<li>需要把容器中的数据持久化保存</li>
<li>需要在宿主机和容器之间完成数据共享<blockquote>
<p>将宿主机目录或文件挂载到容器中，实现宿主机和容器之间的数据共享和持久化</p>
</blockquote>
</li>
</ol>
<h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><ol>
<li>-p 对外端口发布，即端口映射</li>
<li>-v 数据卷</li>
<li>-e 设置环境变量</li>
<li>–name 容器命名</li>
<li>–restart 容器退出后的重启策略<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -v 数据卷别名:容器目录[:读写权限] 镜像名<br>docker run -d -p 80:80 -v nginx_html:/usr/share/nginx/html nginx<br><span class="hljs-comment"># 查看数据卷信息</span><br>docker inspect fcbc47e85323<br><span class="hljs-comment"># 其中有一段信息如下</span><br><span class="hljs-string">&quot;Mounts&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;volume&quot;</span>,<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;nginx_html&quot;</span>,<br>                <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/nginx_html/_data&quot;</span>,<br>                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span>,<br>                <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;z&quot;</span>,<br>                <span class="hljs-string">&quot;RW&quot;</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>            &#125;<br><span class="hljs-comment"># Type为volume，表示数据卷，Source即为我们数据卷的路径</span><br><span class="hljs-comment"># 可以cd到/var/lib/docker/volumes/nginx_html/_data里ls看一下，对应的是nginx中/usr/share/nginx/html的内容</span><br><span class="hljs-comment"># 列出数据卷</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看数据卷详情</span><br><span class="hljs-comment"># 这里nginx_html是别名</span><br>docker volume inspect nginx_html<br>docker volume inspect 06f4db3290e6759861b085989a859257121aac46ad30e35fe26a1904f8ff7aea<br><span class="hljs-comment"># 创建数据卷</span><br><span class="hljs-comment"># volume_test为数据卷的名字</span><br>docker volume create volume_test<br><span class="hljs-comment"># 删除数据卷</span><br>docker volume <span class="hljs-built_in">rm</span> volume_test<br><span class="hljs-comment"># 如果需要删除的数据卷正在被使用，是没有办法直接删除的</span><br><span class="hljs-comment"># 强制删除容器然后删除数据卷</span><br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 手动安装jdk 也可以使用docker安装jdk</span><br><span class="hljs-comment"># docker安装jdk在后文</span><br><span class="hljs-comment"># 在/usr/local 目录下安装jdk</span><br><span class="hljs-built_in">cd</span> /usr/local<br>wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz<br>tar -zxvf jdk-17_linux-x64_bin.tar.gz <br><span class="hljs-comment"># 将jdk-17改名为java</span><br><span class="hljs-built_in">mv</span> jdk-17.0.10 jdk17<br><span class="hljs-comment"># 进入profile文件，按i进入编辑模式</span><br>vim /etc/profile<br><span class="hljs-comment"># 在文件最下方添加</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk17<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin;<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar;<br><span class="hljs-comment"># 按下Esc退出编辑模式</span><br><span class="hljs-comment"># 下一步按住shift 再按俩次 z 键，保存配置文件信息</span><br><span class="hljs-comment"># 重新加载环境变量</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-comment"># </span><br><span class="hljs-built_in">cd</span> /<br>java -version<br></code></pre></td></tr></table></figure>
<strong>练习</strong><br>将某html挂载到nginx目录下进行显示<blockquote>
<p><strong>第一个80</strong>端口是宿主机的端口，<strong>第二个80</strong>端口是容器nginx的端口</p>
<p>将宿主机的<code>/home/html/index.html</code>挂载到容器的<code>/usr/share/nginx/html/index.html</code></p>
<p>不过一般不会直接挂载html，一般挂载整个目录，包括html、css、js等</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 80:80 -v /home/html/index.html:/usr/share/nginx/html/index.html nginx<br></code></pre></td></tr></table></figure>
访问<code>http://虚拟机ip:80/</code><blockquote>
<p>如果我们将宿主机的<code>/home/html/index.html</code>改变内容，再次访问nginx，是否会发生变化</p>
</blockquote>
</li>
</ol>
<h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><p>容器中某些变量不能直接写死，需要让使用者在创建容器的时候指定，这种情况镜像中一般是定义环境变量来使用。例如mysql容器的root密码。遇到这种镜像创建的容器我就可以使用-e来设置环境变量的值。<br>用法如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -e 变量名=变量值 镜像名<br></code></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<ol>
<li>后台运行mysql容器</li>
<li>容器中的mysql可以被外部连接</li>
<li>mysql容器的数据需要持久化存储，不能因为容器被删除而丢失</li>
<li>mysql的root用户密码设置为root<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 3306:3306 -v /home/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql:8.0.20<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="–name"><a href="#–name" class="headerlink" title="–name"></a>–name</h3><p>容器命名<br><strong>练习</strong><br>发布一个nginx页面，为容器命名为nginx-test</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 81:80 --name nginx-test -v /home/html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure>
<h3 id="–restart"><a href="#–restart" class="headerlink" title="–restart"></a>–restart</h3><p>容器退出后的自动重启策略</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run --restart 重启策略 镜像名<br><span class="hljs-comment"># no 不自动重启</span><br><span class="hljs-comment"># always 总自动重启</span><br><span class="hljs-comment"># on-failure[:max-retries] 仅在非正常退出时，自动重启</span><br><span class="hljs-comment"># unless-stopped 容器会在退出后自动重启，除非手动停止</span><br></code></pre></td></tr></table></figure>
<h3 id="其他镜像和容器命令"><a href="#其他镜像和容器命令" class="headerlink" title="其他镜像和容器命令"></a>其他镜像和容器命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看镜像详细内容</span><br>docker images inspect [OPTIONS] IMAGE [IMAGE...]<br>docker image inspect 7614ae9453d1<br><span class="hljs-comment"># 查看容器中的进程</span><br>docker top CONTAINER[ps CONTAINER]<br>docker top redis<br><span class="hljs-comment"># 查看容器详细内容</span><br>docker inspect 51764b94357b<br></code></pre></td></tr></table></figure>
<h3 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># docker拉取java17</span><br>docker pull openjdk:17-jdk<br><span class="hljs-comment"># 运行jar包</span><br>java -jar xxx.jar<br><span class="hljs-comment"># 根据application.properties来穿参数</span><br><span class="hljs-comment"># 运行时参数，比如运行端口为8080，mysql的密码为root</span><br>java -jar xxx.jar --server.port=8080 --spring.datasource.username=root --spring.datasource.password=root<br>docker run -d \<br>-p 8080:8080 \<br>-v /usr/blog:/usr/blog \<br>--restart always \<br>--name jar_test \<br>openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar <br></code></pre></td></tr></table></figure>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker inspect mysql<br></code></pre></td></tr></table></figure>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240323184204498.png" alt="image-20240323184204498" data-caption="image-20240323184204498" loading="lazy"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看运行的容器</span><br>docker ps -f name=jar_test<br><span class="hljs-comment"># 进入容器内部</span><br>docker <span class="hljs-built_in">exec</span> -it jar_test bash<br><span class="hljs-comment"># ping mysql试试</span><br>ping 172.17.0.3<br><span class="hljs-comment"># 创建网络</span><br>docker network create 网络名<br><span class="hljs-comment"># 列出网络信息</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 加入网络有两种方式</span><br><span class="hljs-comment"># 1.在创建容器时加入</span><br>docker run --network 网络名 镜像名<br><span class="hljs-comment"># 2.容器创建后加入</span><br>docker network connect [选项] 网络名 容器名或容器<span class="hljs-built_in">id</span><br><span class="hljs-comment"># 查看网络详情</span><br>docker network inspect 网络名或网络<span class="hljs-built_in">id</span><br>docker run -d \<br>-p 8080:8080 \<br>-v /usr/blog:/usr/blog \<br>--network blog_test jar_test<br>--restart always \<br>--name jar_test \<br>openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar \<br><span class="hljs-string">&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&amp;useSSL=false&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;allowPublicKeyRetrieval=true&quot;</span><br><span class="hljs-comment"># 在加入同一个网络后，这里spring.datasource.url并没有写ip地址了，而是写的容器名称mysql</span><br></code></pre></td></tr></table></figure>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>不区分大小写，但是最好习惯大写</li>
<li>基本以FROM开头</li>
<li><code>#</code>开头代表注释<br><strong>练习</strong><br>自定义一个镜像，运行容器后输出helloworld(如:echo helloworld)<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM centos:7<br>CMD [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;helloworld&quot;</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>将文件编译成镜像</p>
<p>使用<code>-t</code>可以指定镜像的名字和标签、<code>-f</code>指定基于哪个dockerfile文件来进行构建镜像、<code>.</code>表示文件在当前路径下</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t hello:1.0 -f HelloWorld .<br><span class="hljs-comment"># 测试是否成功</span><br>docker run hello:1.0<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><blockquote>
<p>用来定义基础镜像</p>
<p><code>作用时机:构建镜像的时候</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM 镜像名:标签名<br>FROM centos:7<br></code></pre></td></tr></table></figure>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><blockquote>
<p>用来定义容器运行时的默认命令，可以在docker run的时候覆盖掉CMD中定义的命令</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">CMD [<span class="hljs-string">&quot;命令1&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]<br><span class="hljs-comment"># CMD [&quot;echo&quot;,&quot;helloworld&quot;]</span><br><span class="hljs-comment"># 这种形式可以解析环境变量</span><br><span class="hljs-comment"># CMD echo hello$HOME</span><br><span class="hljs-comment"># 这种也可以解析环境变量</span><br><span class="hljs-comment"># CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;hello $HOME&quot;]</span><br><span class="hljs-comment"># 如果在一个dockerfile中有多个CMD，则只执行最后一个CMD</span><br>FROM centos:7<br>CMD [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;helloworld&quot;</span>]<br>CMD <span class="hljs-built_in">echo</span> hello,java<br>CMD <span class="hljs-built_in">echo</span> hello,vue<br><span class="hljs-comment"># 测试一下</span><br>docker build -t hello:2.0 -f HelloWorld .<br></code></pre></td></tr></table></figure>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><blockquote>
<p>用来定义环境变量</p>
<p><code>ENV 变量名=&quot;变量值&quot;</code> 如<code>ENV DIR=&quot;/root&quot;</code></p>
<p>作用时机为<code>构建镜像时</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ENV DIR=<span class="hljs-string">&quot;/root&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>需求：要求对打印内容进行改造，需要实现可以打印任意内容，具体内容在运行容器的时候通过环境变量的方式去指定</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM centos:7<br>ENV NAME=<span class="hljs-string">&quot;小花&quot;</span><br>CMD <span class="hljs-built_in">echo</span> hello,<span class="hljs-variable">$NAME</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>编译测试</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t test01:1.0 -f Test01 .<br>docker run test01:1.0<br><span class="hljs-comment"># 也可以在运行时指定环境变量</span><br>docker run -e NAME=小红 test01:1.0<br></code></pre></td></tr></table></figure>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><blockquote>
<p>用于设置当前工作的目录，如果该目录不存在会自动创建。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">WORKDIR 目录<br>WORKDIR /root/app<br></code></pre></td></tr></table></figure>
<p><strong>示例1</strong></p>
<blockquote>
<p>pwd打印出来是什么？</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM centos:7<br>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br>CMD <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure>
<p>pwd打印<code>/a/b/c</code><br><strong>示例2</strong></p>
<blockquote>
<p>WORKDIR指定目录的父目录不存在会怎么样？</p>
<p><code>WORKDIR /a/b/c</code></p>
<p><code>如果指定目录的父目录不存在，会自动创建</code><br><strong>示例3</strong><br>WORKDIR指定的目录是否能使用环境变量</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM centos:7<br>ENV PATH=<span class="hljs-string">&quot;/a&quot;</span><br>WORKDIR <span class="hljs-variable">$PATH</span><br>CMD <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure>
<p>WORKDIR指定的目录<code>可以</code>使用环境变量</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><blockquote>
<p>用来在构建过程中要执行的命令</p>
<p>而<code>CMD</code>则是在容器运行时执行命令</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">RUN <span class="hljs-built_in">echo</span> abc<br></code></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<blockquote>
<p>定义一个CONTENT变量,默认值为hellodocker, 在镜像的&#x2F;app目录下创建一个sg目录，在其中创建一个content.txt文件, 文件的内容为CQNTENT变量的值。容器启动时打印content.txt的内容</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 如果是sh脚本，则可以这么实现</span><br><span class="hljs-built_in">export</span> CONTENT=<span class="hljs-string">&quot;hellodocker&quot;</span><br><span class="hljs-built_in">mkdir</span> -p /app/sg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$CONTENT</span>&quot;</span> &gt; /app/sg/content.txt<br><span class="hljs-built_in">cat</span> /app/sg/content.txt<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如何改成<code>DockerFile</code>的写法</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM centos:7<br>ENV CONTENT=<span class="hljs-string">&quot;hellodocker&quot;</span><br>WORKDIR /app/sg<br>RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$CONTENT</span>&quot;</span> &gt; /app/sg/content.txt<br>CMD <span class="hljs-built_in">cat</span> /app/sg/content.txt<br></code></pre></td></tr></table></figure>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t test01:1.0 -f Test01 .<br>docker run test01:1.0<br><span class="hljs-comment"># 或者</span><br>docker run -it test01:1.0 bash<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> content.txt <br></code></pre></td></tr></table></figure>
<p><strong>思考</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">[root@10 dockerfile_test]<span class="hljs-comment"># docker run -e CONTENT=java  test01:1.0</span><br>hellodocker<br></code></pre></td></tr></table></figure>
<blockquote>
<p>为什么<code>docker run -e CONTENT=java  test01:1.0</code>的时候，输出的不是<code>java</code></p>
<p>因为只有<code>CMD</code>是在docker运行时执行，而其他指令如<code>ENV、RUN等</code>是在构建镜像时执行</p>
<p>所以输出的还是<code>hellodocker</code></p>
</blockquote>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><blockquote>
<p>把构建上下文的文件或者网络文件添加到镜像</p>
<p>如果文件是压缩包则自动解压，但是需要根据情况，如果是本地压缩包大概率没问题</p>
<p>但如果是网络上的如<code>oss压缩包</code>可能又不会解压，需要根据实际情况来定</p>
<p>作用时机为构建镜像的时候</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ADD 原路径 目标路径<br>ADD xxx.tar.gz .<br><span class="hljs-comment"># 随便找一个 html+js+css的网页</span><br><span class="hljs-comment"># 使用如下命令将html目录打成html.tar.gz压缩包</span><br>tar zcvf html.tar.gz html<br></code></pre></td></tr></table></figure>
<p><strong>练习</strong><br>在构建目录下存放一个<code>gz压缩包</code>， 构建镜像的时候把这个包添加到镜像的&#x2F;app录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口</p>
<blockquote>
<p>dockerfile:Test01</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>ADD html.tar.gz .<br>RUN tar -xzvf html.tar.gz<br>RUN <span class="hljs-built_in">cp</span> -r html/* /usr/share/nginx/html<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t test01:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> -f Test01 .<br></code></pre></td></tr></table></figure>
<blockquote>
<p>报错如下</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">[+] Building <span class="hljs-number">0.4</span>s (<span class="hljs-number">6</span>/<span class="hljs-number">7</span>)                                                                                                                                                                                              docker:default<br> =&gt; [internal] load build definition from Test01                                                                                                                                                                               <span class="hljs-number">0.0</span>s<br> =&gt; =&gt; transferring dockerfile: <span class="hljs-number">217</span>B                                                                                                                                                                                           <span class="hljs-number">0.0</span>s<br> =&gt; [internal] load metadata <span class="hljs-keyword">for</span> docker.io<span class="hljs-regexp">/library/</span>nginx:latest                                                                                                                                                                <span class="hljs-number">0.0</span>s<br> =&gt; [internal] load .dockerignore                                                                                                                                                                                              <span class="hljs-number">0.0</span>s<br> =&gt; =&gt; transferring context: <span class="hljs-number">2</span>B                                                                                                                                                                                                <span class="hljs-number">0.0</span>s<br> =&gt; [<span class="hljs-number">1</span><span class="hljs-regexp">/4] FROM docker.io/</span>library/nginx:latest                                                                                                                                                                                  <span class="hljs-number">0.0</span>s<br> =&gt; [<span class="hljs-number">2</span><span class="hljs-regexp">/4] WORKDIR /</span>app                                                                                                                                                                                                         <span class="hljs-number">0.0</span>s<br> =&gt; ERROR [<span class="hljs-number">3</span>/<span class="hljs-number">4</span>] RUN tar -xzvf html.tar.gz                                                                                                                                                                                      <span class="hljs-number">0.3</span>s<br>------                                                                                                                                                                                                                              <br> &gt; [<span class="hljs-number">3</span>/<span class="hljs-number">4</span>] RUN tar -xzvf html.tar.gz:                                                                                                                                                                                                 <br><span class="hljs-number">0.263</span> tar (child): html.tar.gz: Cannot open: No such file or directory<br><span class="hljs-number">0.263</span> tar (child): Error is not recoverable: exiting now<br><span class="hljs-number">0.263</span> tar: Child returned status <span class="hljs-number">2</span><br><span class="hljs-number">0.263</span> tar: Error is not recoverable: exiting now<br>------<br>Test01:<span class="hljs-number">3</span><br>--------------------<br>   <span class="hljs-number">1</span> |     FROM nginx:latest<br>   <span class="hljs-number">2</span> |     WORKDIR /app<br>   <span class="hljs-number">3</span> | &gt;&gt;&gt; RUN tar -xzvf html.tar.gz<br>   <span class="hljs-number">4</span> |     RUN cp html<span class="hljs-regexp">/* /u</span>sr<span class="hljs-regexp">/share/</span>nginx/html<br>   <span class="hljs-number">5</span> |     CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br>--------------------<br>ERROR: failed to solve: process <span class="hljs-string">&quot;/bin/sh -c tar -xzvf html.tar.gz&quot;</span> did not complete successfully: <span class="hljs-keyword">exit</span> code: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>可以看到是在解压tar.gz包的时候报错了，好像是没有找到文件<br><strong>那怎么调试呢？现在镜像都没构建，更别说进入到容器内部查看文件是否存在了</strong></p>
<blockquote>
<p>将Test01改成如下内容</p>
<p>注释掉报错部分，先创建镜像，然后进入容器内部查看报错原因</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>ADD html.tar.gz .<br><span class="hljs-comment">#RUN tar -xzvf html.tar.gz</span><br><span class="hljs-comment">#RUN cp -r html/* /usr/share/nginx/html</span><br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>构建成功</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t test01:1.0 -f Test01 .<br>docker run -it test01:1.0 bash<br><span class="hljs-comment"># ls发现tar.gz已经被自动解压了</span><br><span class="hljs-comment"># 说明ADD一个压缩包，会自动解压</span><br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>最终将dockerFile改为如下</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>ADD html.tar.gz .<br>RUN <span class="hljs-built_in">cp</span> -r html/* /usr/share/nginx/html<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>构建后运行镜像</p>
<p>因为我虚拟机已经运行了一个nginx容器了，所以80端口已经被占用了，这里指定的端口是81</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 81:80 --name=dockerfile_test01 test01:1.0<br></code></pre></td></tr></table></figure>
<blockquote>
<p>访问链接，这里<code>docker1</code>是指虚拟机的ip</p>
<p>我这里是因为配了主机的<code>hosts</code>文件</p>
<p>hosts文件路径：C:\Windows\System32\drivers\etc<br><strong><code>hosts</code>文件</strong></p>
</blockquote>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.56.10</span>   docker1<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://docker1:81/">http://docker1:81/</a><br><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240324181016560.png" alt="image-20240324181016560" data-caption="image-20240324181016560" loading="lazy"></p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><blockquote>
<p>暴露需要发布的端口，让镜像使用者知道应该发布哪些端口</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">EXPOSE 端口1 端口2<br>EXPOSE 80 8080<br></code></pre></td></tr></table></figure>
<blockquote>
<p>dockerfile</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>ADD html.tar.gz .<br>RUN <span class="hljs-built_in">cp</span> -r html/* /usr/share/nginx/html<br>EXPOSE 80<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><blockquote>
<p>从构建上下文中复制内容到镜像中</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">COPY 原路径 目标路径<br>COPY html.tar.gz .<br></code></pre></td></tr></table></figure>
<p>COPY的作用和ADD好像非常类似，具体如何抉择？</p>
<ol>
<li><code>ADD</code>可以下载网络文件,并且可以自动解压</li>
<li><code>COPY</code>就是单纯的拷贝<br><strong>练习</strong><br>在构建目录下存放一个html.tar.gz包，构建镜像的时候把这个包复制到镜像的&#x2F;app目录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>COPY html.tar.gz .<br>RUN tar -xzvf html.tar.gz<br>RUN <span class="hljs-built_in">cp</span> -r html/* /usr/share/nginx/html<br>EXPOSE 80<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><blockquote>
<p>用来定义容器运行时的默认命令。docker run的时候无法覆盖ENTRYPOINT里的内容。</p>
<p>运行时机在运行容器的时候</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ENTRYPOINT [<span class="hljs-string">&quot;命令1&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]<br>ENTRYPOINT [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;helloworld&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><strong>实际使用</strong></p>
<blockquote>
<p>实际使用往往是存在部分命令不能更改，也存在部分命令可以被更改</p>
<p>比如<code>java -jar aaa.jar</code></p>
<p>我们希望<code>java -jar</code>这部分命令是固定的，无法在运行时被修改</p>
<p>而<code>jar</code>包的名称可以在运行时修改</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>]<br>CMD [<span class="hljs-string">&quot;aaa.jar&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><strong>练习</strong><br>在上个案例要求的基础上，还要求容器的nginx的启动命令不能在运行容器时被覆盖</p>
<blockquote>
<p>分析一下这个练习</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 82:80 test01:1.0 bash<br></code></pre></td></tr></table></figure>
<p>执行上述命令后，容器处于退出状态<code>Exited </code><br>为啥呢？因为<code>bash</code>将dockerfile最后一行的cmd命令覆盖了<code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>COPY html.tar.gz .<br>RUN tar -xzvf html.tar.gz<br>RUN <span class="hljs-built_in">cp</span> -r html/* /usr/share/nginx/html<br>EXPOSE 80<br>ENTRYPOINT [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t entrypoint_test02:1.0 -f Test01 .<br>docker run -d -p 82:80 entrypoint_test02:1.0 bash<br></code></pre></td></tr></table></figure>
<blockquote>
<p>发现容器依然没有运行，查看容器日志</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d -p 82:80 entrypoint_test02:1.0 bash<br><span class="hljs-comment">#fa075623cdbf3d01ead7b405c8d61b224e0f70e9fffcdb2a3c5bd91100ecd35d</span><br>docker logs fa075623cdbf3d<br><span class="hljs-comment">#nginx: invalid option: &quot;bash&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>因为此时在<code>nginx</code>容器内执行了<code>bash</code>命令，nginx无法识别</p>
</blockquote>
<h2 id="优化部署流程"><a href="#优化部署流程" class="headerlink" title="优化部署流程"></a>优化部署流程</h2><blockquote>
<p>我们希望后端的镜像当中就包含了后端的jar包，镜像启动的时候默认就是会启动该jar包，前端的镜像中就包含了前端的包</p>
</blockquote>
<h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><h4 id="配置nginx反向代理"><a href="#配置nginx反向代理" class="headerlink" title="配置nginx反向代理"></a>配置nginx反向代理</h4><p><code>/etc/nginx/conf.d/default.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen       80;<br>    listen  [::]:80;<br>    server_name  localhost;<br>    #access_log  /var/log/nginx/host.access.log  main;<br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br>    location ^~/api/&#123;<br>        proxy_pass http://192.168.56.10:8080/;<br>    &#125;<br>    #error_page  404              /404.html;<br>    # redirect server error pages to the static page /50x.html<br>    #<br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br>    # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>    #<br>    #location ~ \.php$ &#123;<br>    #    proxy_pass   http://127.0.0.1;<br>    #&#125;<br>    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>    #<br>    #location ~ \.php$ &#123;<br>    #    root           html;<br>    #    fastcgi_pass   127.0.0.1:9000;<br>    #    fastcgi_index  index.php;<br>    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;<br>    #    include        fastcgi_params;<br>    #&#125;<br>    # deny access to .htaccess files, if Apache&#x27;s document root<br>    # concurs with nginx&#x27;s one<br>    #<br>    #location ~ /\.ht &#123;<br>    #    deny  all;<br>    #&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>主要是添加如下代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs conf">...<br>  location ^~/api/&#123;<br>        proxy_pass http://192.168.56.10:8080/;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 我这里的nginx的镜像名为nginx-test</span><br>docker inspect volume nginx-test<br><span class="hljs-comment">#        &quot;Mounts&quot;: [</span><br><span class="hljs-comment">#            &#123;</span><br><span class="hljs-comment">#                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="hljs-comment">#                &quot;Source&quot;: &quot;/home/html&quot;,</span><br><span class="hljs-comment">#                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="hljs-comment">#                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="hljs-comment">#                &quot;RW&quot;: true,</span><br><span class="hljs-comment">#                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="hljs-comment">#            &#125;</span><br><span class="hljs-comment">#        ],</span><br></code></pre></td></tr></table></figure>
<p>而nginx镜像配置的数据卷在宿主机的路径为<code>/home/html</code>，所以我们将前端文件放在宿主机的<code>/home/html</code>路径下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ll<br><span class="hljs-comment">#total 16</span><br><span class="hljs-comment">#drwxr-xr-x. 2 root root   57 Mar 24 13:13 assets</span><br><span class="hljs-comment">#-rw-r--r--. 1 root root 1169 Mar 24 15:07 default.conf</span><br><span class="hljs-comment">#-rw-r--r--. 1 root root  456 Mar 24 13:13 index.html</span><br><span class="hljs-comment">#-rw-r--r--. 1 root root  834 Mar 24 14:06 nginx.conf</span><br><span class="hljs-comment">#-rw-r--r--. 1 root root 1497 Mar 20 23:01 vite.svg</span><br><span class="hljs-built_in">pwd</span><br><span class="hljs-comment">#/home/html</span><br></code></pre></td></tr></table></figure>
<p>到时候前端输入<code>虚拟机ip:80/</code>就会显示<code>/home/html/index.html</code>文件<br>如<code>http://192.168.56.10:80/</code>显示前端页面</p>
<h4 id="运行后端"><a href="#运行后端" class="headerlink" title="运行后端"></a>运行后端</h4><blockquote>
<p>注意更换自己mysql的账号和密码</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker run -d \<br>-p 8080:8080 \<br>-v /usr/blog:/usr/blog \<br>--restart always \<br>--name jar_test \<br>openjdk:17-jdk java -jar /usr/blog/demo.jar  --spring.datasource.username=root --spring.datasource.password=123456<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里将jar包放在了<code>/usr/blog</code>下，也可以自己定义路径</p>
</blockquote>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>还需要配置mysql,新建一个<code>test</code>数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table user<br>(<br>    id        int auto_increment comment &#x27;用户编号&#x27;<br>        primary key,<br>    username  varchar(20)  null comment &#x27;账号&#x27;,<br>    password  varchar(20)  null comment &#x27;密码&#x27;,<br>    nick_name varchar(20)  null comment &#x27;昵称&#x27;,<br>    avatar    varchar(255) null comment &#x27;头像&#x27;<br>)<br>    comment &#x27;用户表&#x27;;<br>INSERT INTO test.user (id, username, password, nick_name, avatar) VALUES (1, &#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;默认昵称&#x27;, null);<br></code></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote>
<p>dockerfile</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM openjdk:17-jdk<br>WORKDIR /app<br>ADD demo.jar .<br>EXPOSE 8080<br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>]<br>CMD [<span class="hljs-string">&quot;demo.jar&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240325062118495.png" alt="image-20240325062118495" data-caption="image-20240325062118495" loading="lazy"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/dockerfile_test<br>docker build -t demo_jar:1 -f /usr/dockerfile_test/demo_jar .<br><span class="hljs-comment"># network 添加到同一个网络</span><br><span class="hljs-comment"># mysql也需要</span><br>docker run -d \<br>-p 8080:8080 \<br>--network blog_test \<br>--restart always \<br>--name jar_demo \<br>demo_jar:1<br></code></pre></td></tr></table></figure>
<blockquote>
<p>前端</p>
<p><code>demo_ngxin</code>是dockerfile文件</p>
<p>blog-vue下则是前端文件<br><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://gitee.com/tongstyle/blog-img/raw/master/img/image-20240325071054576.png" alt="image-20240325071054576" data-caption="image-20240325071054576" loading="lazy"></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">FROM nginx:latest<br>WORKDIR /app<br>COPY blog-vue .<br>RUN <span class="hljs-built_in">cp</span> -r dist/* /usr/share/nginx/html<br>EXPOSE 80<br>ENTRYPOINT [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t blog_vue:1 -f demo_nginx .<br>docker run -d \<br>-p 80:80 \<br>--restart always \<br>-d \<br>--name blog_vue \<br>blog_vue:1<br></code></pre></td></tr></table></figure>
<blockquote>
<p>访问发现后端接口404，是因为基于nginx镜像<code>FROM nginx:latest</code>，这里反向代理依然需要配置</p>
<p>解决方法：进入<code>blog_vue</code>容器内部重新配置反向代理</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it blog_vue bash<br></code></pre></td></tr></table></figure>
<h2 id="镜像推送到镜像仓库"><a href="#镜像推送到镜像仓库" class="headerlink" title="镜像推送到镜像仓库"></a>镜像推送到镜像仓库</h2><h3 id="注册Docker-Hub账号"><a href="#注册Docker-Hub账号" class="headerlink" title="注册Docker Hub账号"></a>注册<code>Docker Hub</code>账号</h3><p>官网:<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h3 id="登录镜像仓库"><a href="#登录镜像仓库" class="headerlink" title="登录镜像仓库"></a>登录镜像仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker login<br><span class="hljs-comment"># 然后输入账号密码即可登录</span><br></code></pre></td></tr></table></figure>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker build -t username/镜像名:tag .<br><span class="hljs-comment"># username是Docker Hub的帐号</span><br></code></pre></td></tr></table></figure>
<h3 id="给镜像打上标签"><a href="#给镜像打上标签" class="headerlink" title="给镜像打上标签"></a>给镜像打上标签</h3><blockquote>
<p>以便于与<code>Docker Hub</code>上的仓库关联</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第一个镜像名是本地的镜像名</span><br><span class="hljs-comment"># 第二个镜像名是Docker Hub仓库中的镜像名</span><br>docker tag username/镜像名:tag username/镜像名:tag<br></code></pre></td></tr></table></figure>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker push username/镜像名:tag<br></code></pre></td></tr></table></figure>
<h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><blockquote>
<p>DockerCompose是用来定义和运行一个或多个容器(通常都是多个)运行和应用的工具</p>
<p>当前版本的Docker不需要单独安装</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker compose version<br><span class="hljs-comment"># 查看版本</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">test:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>  <span class="hljs-attr">test2:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br></code></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 运行以上定义的所有镜像</span><br>docker compose up<br><span class="hljs-comment"># -d 后台运行</span><br>docker compose up -d<br><span class="hljs-comment"># 会停止并删除yaml中运行的容器</span><br>docker compose down<br></code></pre></td></tr></table></figure>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><ol>
<li>command 覆盖容器启动后的默认指令</li>
<li>environment 指定环境变量，相当于run的-e选项</li>
<li>image 用来指定镜像</li>
<li>networks 指定网络, 相当于run的–network</li>
<li>ports 用来指定要发布的端口 ，相当于run的-p</li>
<li>volumes 用来指定数据卷， 相当于-V</li>
<li>restart 用来指定重启策略,相当于–restart<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-comment"># mysql</span><br>  <span class="hljs-attr">blog_mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0.20</span><br>    <span class="hljs-comment"># 已经存在的数据卷 mysql_data</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data:/var/lib/mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">blog_net</span><br>  <span class="hljs-comment"># redis</span><br>  <span class="hljs-attr">blog_redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis_data:/data</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;redis-server&#x27;</span>,<span class="hljs-string">&#x27;--appendonly&#x27;</span>,<span class="hljs-string">&#x27;yes&#x27;</span>]<br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">blog_net</span><br>  <span class="hljs-comment"># 后端服务</span><br>  <span class="hljs-attr">sg_blog:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">sb_blog:01</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">blog_net</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment"># 前端服务</span><br>  <span class="hljs-attr">sg_blog_vue:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">sb_blog_vue:01</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">blog_net:</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data:</span><br>    <span class="hljs-comment"># 表示数据卷已经存在，不需要自动创建</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">redis_data:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>设置好<code>docker-compose.yaml</code>后</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">docker compose up -d<br>docker compose down<br></code></pre></td></tr></table></figure></li>
</ol>

    
  </article>

  
      

  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
</div>
  
  

  
      <div class="nexmoe-post-footer">
          <script src="https://giscus.app/client.js"
    data-repo="nexmoe/nexmoe.com"
    data-repo-id="R_kgDOJI1XUA"
    data-category="General"
    data-category-id="DIC_kwDOJI1XUM4CU1nn"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>

      </div>
  
</div>
</div>
        <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">Docker概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">容器继续运行的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">容器的运行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.4.</span> <span class="toc-text">进入容器执行命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">2.1.5.</span> <span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.1.6.</span> <span class="toc-text">容器文件拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.7.</span> <span class="toc-text">停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.8.</span> <span class="toc-text">运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.9.</span> <span class="toc-text">run命令详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">2.2.</span> <span class="toc-text">数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v"><span class="toc-number">2.2.1.</span> <span class="toc-text">-v</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e"><span class="toc-number">2.2.2.</span> <span class="toc-text">-e</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93name"><span class="toc-number">2.2.3.</span> <span class="toc-text">–name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%93restart"><span class="toc-number">2.2.4.</span> <span class="toc-text">–restart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.5.</span> <span class="toc-text">其他镜像和容器命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cjar%E5%8C%85"><span class="toc-number">2.2.6.</span> <span class="toc-text">运行jar包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.2.7.</span> <span class="toc-text">网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockerFile"><span class="toc-number">2.3.</span> <span class="toc-text">DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FROM"><span class="toc-number">2.3.2.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">2.3.3.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENV"><span class="toc-number">2.3.4.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WORKDIR"><span class="toc-number">2.3.5.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN"><span class="toc-number">2.3.6.</span> <span class="toc-text">RUN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD"><span class="toc-number">2.3.7.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPOSE"><span class="toc-number">2.3.8.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY"><span class="toc-number">2.3.9.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">2.3.10.</span> <span class="toc-text">ENTRYPOINT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">优化部署流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88"><span class="toc-number">2.4.1.</span> <span class="toc-text">基础版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">配置nginx反向代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%90%8E%E7%AB%AF"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">运行后端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">MySQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">2.5.</span> <span class="toc-text">镜像推送到镜像仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CDocker-Hub%E8%B4%A6%E5%8F%B7"><span class="toc-number">2.5.1.</span> <span class="toc-text">注册Docker Hub账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">2.5.2.</span> <span class="toc-text">登录镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">构建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E9%95%9C%E5%83%8F%E6%89%93%E4%B8%8A%E6%A0%87%E7%AD%BE"><span class="toc-number">2.5.4.</span> <span class="toc-text">给镜像打上标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="toc-number">2.5.5.</span> <span class="toc-text">推送镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockerCompose"><span class="toc-number">2.6.</span> <span class="toc-text">DockerCompose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0"><span class="toc-number">2.6.2.</span> <span class="toc-text">元素</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
    </div>
    <div id="nexmoe-search-space">
	<div class="search-container">
		<div class="search-header">
			<div class="search-input-container">
				<input
					class="search-input"
					type="text"
					placeholder="搜索"
					oninput="sinput();"
				/>
			</div>
			<a class="search-close" onclick="sclose();">×</a>
		</div>
		<div class="search-body"></div>
	</div>
</div>

    
    
</body>

</html>
