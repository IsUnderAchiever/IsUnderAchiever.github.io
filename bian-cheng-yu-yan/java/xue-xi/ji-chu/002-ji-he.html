<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>java集合 - 折影轻梦</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="折影轻梦,Mixcm,轻惋,觅漫者,小舒同学,Xiaoshu,Nexmoe,产品,Meteor,探索者小舒,伴学OS1,Theme,Design,Product">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
    <meta name="description" content="Java集合接口继承关系和实现 集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。   Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据。 Map：是映射表的基础接口。 集合框架：   Collection List A">
<meta property="og:type" content="article">
<meta property="og:title" content="java集合">
<meta property="og:url" content="https://nexmoe.com/bian-cheng-yu-yan/java/xue-xi/ji-chu/002-ji-he.html">
<meta property="og:site_name" content="折影轻梦">
<meta property="og:description" content="Java集合接口继承关系和实现 集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。   Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据。 Map：是映射表的基础接口。 集合框架：   Collection List A">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-16T16:00:00.000Z">
<meta property="article:modified_time" content="2024-06-01T14:12:24.909Z">
<meta property="article:author" content="折影轻梦">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1717303056860">
    
    <link rel="stylesheet" href="/css/style.css?v=1717303056860">

    
        
            <link rel="stylesheet" href="/custom.css?v=1717303056860">
        
    

    
<script src="/lib/mdui_043tiny/mdui.js" async></script>
<script src="/lib/fancybox/fancybox.umd.js" async></script>


    <script async src="/js/app.js?v=1717303056860"></script>
    
     

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4D4ZJ9G024"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());

  gtag("config", "G-4D4ZJ9G024");
</script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="mdui-drawer-body-left">
    <div id="nexmoe-background">
        <div class="nexmoe-bg" 
            style="background-image: url(https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102206.jpg)"
        ></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="折影轻梦" class="mdui-btn mdui-btn-icon"><img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102017.jpg" alt="折影轻梦"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="折影轻梦">
            <img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102017.jpg" alt="折影轻梦" alt="折影轻梦">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>168</div>
        <div><span>标签</span>61</div>
        <div><span>分类</span>62</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/life.html" title="我的生活">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的生活
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博主">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博主
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
        
            
            <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>


	<script async src="/js/search.js?v=1717303056860"></script>



        
            
            <div class="nexmoe-widget-wrap">
	<div class="nexmoe-widget nexmoe-social">
		<a
			class="mdui-ripple"
			href="https://github.com/IsUnderAchiever/"
			target="_blank"
			mdui-tooltip="{content: 'QQ群'}"
			style="
				color: rgb(249, 174, 8);
				background-color: rgba(249, 174, 8, .1);
			"
		>
			<i
				class="nexmoefont icon-QQ"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://space.bilibili.com/477448861/"
			target="_blank"
			mdui-tooltip="{content: '哔哩哔哩'}"
			style="
				color: rgb(231, 106, 141);
				background-color: rgba(231, 106, 141, .1);
			"
		>
			<i
				class="nexmoefont icon-bilibili"
			></i> </a
		>
	</div>
</div>

        
            
            
            
            
            
            
    </aside>
    <div class="nexmoe-copyright">
        &copy; 2024 折影轻梦
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
    <div class="nexmoe-post">
  <article>
    
        <div class="nexmoe-post-cover"> 
            <img src="https://raw.githubusercontent.com/IsUnderAchiever/blog-img/master/about/202309161102206.jpg" alt="java集合" loading="lazy">
            <h1>java集合</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2022年12月17日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a>
        
        
    </div>
    
    
    
    
    
</div>

    <h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h3><blockquote>
<p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p>
</blockquote>
<ol>
<li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li>
<li>Iterator：迭代器，可以通过迭代器遍历集合中的数据。</li>
<li>Map：是映射表的基础接口。<blockquote>
<p>集合框架：</p>
</blockquote>
</li>
<li>Collection<ol>
<li>List<ul>
<li>ArrayList:排列有序，可重复、底层使用数组、查询快增删慢、线程不安全、当容量不够时-ArrayList是当前容量*1.5+1</li>
<li>Vector:排列有序，可重复、底层使用数组、查询快增删慢、线程安全但效率低、当容量不够时-Vector默认扩展一倍容量</li>
<li>LinkedList:排列有序，可重复、底层使用双向循环链表数据结构、查询慢增删快、线程不安全</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet:排列无序，不可重复、底层使用Hash实现、存取速度快、内部是HashMap</li>
<li>TreeSet:排列无序，不可重复、底层使用二叉树实现、排列存储、内部是TreeMap的SortedSet</li>
<li>LinkedHashSet:采用Hash表存储，并用双向链表记录插入顺序、内部是LinkedHashMap</li>
</ul>
</li>
<li>Queue:在两端出入的List，所以也可以用数组和链表来实现</li>
</ol>
</li>
<li>Map<ul>
<li>HashMap:键不可重复，值可重复、底层哈希表、线程不安全、允许键null值也可以为null</li>
<li>HashTable:键不可重复，值可重复、底层哈希表、线程安全、键值都不允许为null</li>
<li>TreeMap:键不可重复，值可重复、底层二叉树</li>
</ul>
</li>
</ol>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote>
<p>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类分别是 ArrayList、Vector 和 LinkedList</p>
</blockquote>
<h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><blockquote>
<p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p>
</blockquote>
<h3 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h3><blockquote>
<p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p>
</blockquote>
<h3 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h3><blockquote>
<p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p>
</blockquote>
<h3 id="HashSet（Hash表）"><a href="#HashSet（Hash表）" class="headerlink" title="HashSet（Hash表）"></a>HashSet（Hash表）</h3><blockquote>
<p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equals 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p>
</blockquote>
<h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li>
</ol>
<h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><blockquote>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="HashMap（数组-链表-红黑树）"><a href="#HashMap（数组-链表-红黑树）" class="headerlink" title="HashMap（数组+链表+红黑树）"></a>HashMap（数组+链表+红黑树）</h3><blockquote>
<p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol>
<li>Java7实现：13&#x2F;04&#x2F;2018 Page 50 of 283大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。<ol>
<li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，等于 capacity * loadFact</li>
</ol>
</li>
<li>Java8实现：Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</li>
</ol>
<h4 id="Segment段"><a href="#Segment段" class="headerlink" title="Segment段"></a>Segment段</h4><blockquote>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表部分或一段的意思，所以很多地方都会将其描述为分段锁。注意，行文中，槽来代表一个segment。</p>
</blockquote>
<h4 id="线程安全（Segment继承ReentrantLock加锁）"><a href="#线程安全（Segment继承ReentrantLock加锁）" class="headerlink" title="线程安全（Segment继承ReentrantLock加锁）"></a>线程安全（Segment继承ReentrantLock加锁）</h4><blockquote>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
</blockquote>
<h4 id="并行度（默认16）"><a href="#并行度（默认16）" class="headerlink" title="并行度（默认16）"></a>并行度（默认16）</h4><blockquote>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
</blockquote>
<h4 id="Java8实现（引入了红黑树）"><a href="#Java8实现（引入了红黑树）" class="headerlink" title="Java8实现（引入了红黑树）"></a>Java8实现（引入了红黑树）</h4><blockquote>
<p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</p>
</blockquote>
<h3 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h3><blockquote>
<p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
</blockquote>
<h3 id="TreeMap（可排序）"><a href="#TreeMap（可排序）" class="headerlink" title="TreeMap（可排序）"></a>TreeMap（可排序）</h3><blockquote>
<p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p>
</blockquote>
<h3 id="LinkHashMap（记录插入的顺序）"><a href="#LinkHashMap（记录插入的顺序）" class="headerlink" title="LinkHashMap（记录插入的顺序）"></a>LinkHashMap（记录插入的顺序）</h3><blockquote>
<p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
</blockquote>

    
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>折影轻梦<br>
        <strong>本文链接：</strong><a href="https://nexmoe.com/bian-cheng-yu-yan/java/xue-xi/ji-chu/002-ji-he.html" title="https:&#x2F;&#x2F;nexmoe.com&#x2F;bian-cheng-yu-yan&#x2F;java&#x2F;xue-xi&#x2F;ji-chu&#x2F;002-ji-he.html" target="_blank" rel="noopener">https:&#x2F;&#x2F;nexmoe.com&#x2F;bian-cheng-yu-yan&#x2F;java&#x2F;xue-xi&#x2F;ji-chu&#x2F;002-ji-he.html</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a>
    
</div>
  
  

  
      <div class="nexmoe-post-footer">
          <script src="https://giscus.app/client.js"
    data-repo="nexmoe/nexmoe.com"
    data-repo-id="R_kgDOJI1XUA"
    data-category="General"
    data-category-id="DIC_kwDOJI1XUM4CU1nn"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>

      </div>
  
</div>
</div>
        <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">接口继承关系和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">1.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">ArrayList（数组）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">Vector（数组实现、线程同步）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">LinkedList（链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">1.6.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%EF%BC%88Hash%E8%A1%A8%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">HashSet（Hash表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">TreeSet（二叉树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkHashSet%EF%BC%88HashSet-LinkedHashMap%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">LinkHashSet（HashSet+LinkedHashMap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">1.10.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%EF%BC%88%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">HashMap（数组+链表+红黑树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">1.12.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment%E6%AE%B5"><span class="toc-number">1.12.1.</span> <span class="toc-text">Segment段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88Segment%E7%BB%A7%E6%89%BFReentrantLock%E5%8A%A0%E9%94%81%EF%BC%89"><span class="toc-number">1.12.2.</span> <span class="toc-text">线程安全（Segment继承ReentrantLock加锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%88%E9%BB%98%E8%AE%A416%EF%BC%89"><span class="toc-number">1.12.3.</span> <span class="toc-text">并行度（默认16）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java8%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BC%95%E5%85%A5%E4%BA%86%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">1.12.4.</span> <span class="toc-text">Java8实现（引入了红黑树）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashTable%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">HashTable（线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap%EF%BC%88%E5%8F%AF%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">TreeMap（可排序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkHashMap%EF%BC%88%E8%AE%B0%E5%BD%95%E6%8F%92%E5%85%A5%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">LinkHashMap（记录插入的顺序）</span></a></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
    </div>
    <div id="nexmoe-search-space">
	<div class="search-container">
		<div class="search-header">
			<div class="search-input-container">
				<input
					class="search-input"
					type="text"
					placeholder="搜索"
					oninput="sinput();"
				/>
			</div>
			<a class="search-close" onclick="sclose();">×</a>
		</div>
		<div class="search-body"></div>
	</div>
</div>

    
    
</body>

</html>
