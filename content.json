{"meta":{"title":"折影轻梦","subtitle":"小雏菊","description":"纯粹、热爱、勇敢","author":"折影轻梦","url":"https://isunderachiever.github.io","root":"/"},"pages":[{"title":"关于","date":"2016-08-19T16:00:00.000Z","updated":"2023-09-13T22:33:48.000Z","comments":true,"path":"about.html","permalink":"https://isunderachiever.github.io/about.html","excerpt":"","text":"02 年出生，为热爱战斗着，努力学着变得勇敢 我是谁我是折影轻梦（Nexmoe） 作品 其他 听音乐 - 网易云音乐 看书、电影 - 豆瓣"},{"title":"文章归档","date":"2024-06-01T13:13:43.235Z","updated":"2023-09-13T22:33:48.000Z","comments":true,"path":"archive.html","permalink":"https://isunderachiever.github.io/archive.html","excerpt":"","text":""},{"title":"赞助我","date":"2019-11-30T15:00:09.000Z","updated":"2023-09-16T04:48:09.896Z","comments":true,"path":"donate.html","permalink":"https://isunderachiever.github.io/donate.html","excerpt":"","text":"赞助单"},{"title":"生活","date":"2019-02-01T12:03:41.000Z","updated":"2023-09-16T04:43:50.698Z","comments":true,"path":"life.html","permalink":"https://isunderachiever.github.io/life.html","excerpt":"","text":""},{"title":"","date":"2024-06-01T13:13:43.235Z","updated":"2023-09-13T22:33:48.000Z","comments":true,"path":"custom.css","permalink":"https://isunderachiever.github.io/custom.css","excerpt":"","text":":root { --color-shadow: rgb(204 177 161 / 60%); } body { overflow-x: hidden; } #nexmoe-content .nexmoe-post-footer { background-color: transparent; }"}],"posts":[{"title":"动态规划","slug":"算法/动态规划","date":"2024-06-02T14:00:00.000Z","updated":"2024-06-02T15:00:47.062Z","comments":true,"path":"/suan-fa/dong-tai-gui-hua.html","link":"","permalink":"https://isunderachiever.github.io/suan-fa/dong-tai-gui-hua.html","excerpt":"","text":"动态规划01动态规划解不同的子序列 LeetCode第115题 困难 给定一个字符串s和一个字符串t，计算在s的子序列中t出现的个数。 字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE”是”ABCDE”的一个子序列，而”AEC”不是） 题目数据保证答案符合32位带符号整数范围。 示例 1： 输入：s &#x3D; “rabbbit”, t &#x3D; “rabbit” 输出：3 解释： 如下图所示, 有3种可以从s中得到”rabbit”的方案。 rabbbitrabbbitrabbbit 示例 2： 输入：s &#x3D; “ babgbag”, t &#x3D; “ bag” 输出：5 解释： 如下图所示, 有5种可以从s中得到”bag”的方案。 babgbagbabgbagbabgbagbabgbagbabgbag 提示： 0&lt;&#x3D;s.length , t.length&lt;&#x3D;1000 s和t由英文字母组成 思路如下 我们需要知道字符串s的所有子序列中，和字符串t相同的有多少个 我们定义dp[i][j]表示字符串t的前i个字符可以由字符串s的前j个字符组成的个数 也就是字符串s的前j个字符组成的子序列中，有dp[i][j]个子序列与t的前i个字符相同 那么我们需要求的是**dp[t.length()][s.length()]** 如果字符串t的第i个字符和字符串s的第j个字符一样 此时我们有两种选择 使用字符串s的第j个字符与字符串t的第i个字符匹配 那么此时我们可以将dp[i][j]转化成dp[i-1][j-1] 不使用字符串s的第j个字符与字符串t的第i个字符匹配 那么此时我们可以将dp[i][j]转化成dp[i][j-1] 上述是字符串t的第i个字符和字符串s的第j个字符一样的情况 如果字符串t的第i个字符和字符串s的第j个字符不一样 就是说字符串s的第j个字符不能匹配字符串t的第i个字符。 那么我们只能计算字符串s的前j -1个字符构成的子序列中包含字符串t的前i个字符组成的字符串的个数。 即dp[i][j-1] 所以递推公式如下 for (int j = 1; j &lt;= sLength; j++) &#123; if (t.charAt(i - 1) == s.charAt(j - 1)) &#123; //如果字符串t的第i个字符和s的第j个字符一样， //那么有两种选择 dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]; &#125; else &#123; //如果字符串t的第i个字符和s的第j个字符不一样， //我们只能用字符串s的前j-1个字符来计算他包含的数量 dp[i][j] = dp[i][j - 1]; &#125;&#125; 动态规划的三个步骤就是定义状态，列出递推公式，找出边界条件。前面两步我们都完成了，我们来看最后一个。 因为空字符串&quot;&quot;是所有字符串的子集，所以当字符串t为空的时候，dp[0][j]&#x3D;1; 最终代码如下 public class _01_Subsequence &#123; public int answer(String str, String targetStr) &#123; // sLength和tLength分别是两个字符串的长度 int sLength = str.length(); int tLength = targetStr.length(); // 定义dp int[][] dp = new int[tLength + 1][sLength + 1]; // 边界条件 // 初始化dp for (int j = 0; j &lt;= sLength; j++) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt;= tLength; i++) &#123; for (int j = 1; j &lt;= sLength; j++) &#123; //下面是递推公式 if (targetStr.charAt(i - 1) == str.charAt(j - 1)) &#123; //如果字符串t的第i个字符和s的第j个字符一样， //那么有两种选择 dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]; &#125; else &#123; //如果字符串t的第i个字符和s的第j个字符不一样， //我们只能用字符串s的前j-1个字符来计算他包含的数量 dp[i][j] = dp[i][j - 1]; &#125; &#125; &#125; return dp[tLength][sLength]; &#125;&#125; 思考以下几个问题 为什么dp定义是new int[tLength + 1][sLength + 1]而不是new int[tLength][sLength]？ 递推公式先遍历tLength，后遍历sLength，反过来可不可以？ 解答上述问题 假如传入的s、t分别为rabbbit和rabbit，那么sLength为7，tLength 为6，我们定义的dp为dp[7][8] 需要求解的dp是dp[6][7]为什么会出现这种情况呢？ 在后文的dp初始化代码中会初始化dp for (int j = 0; j &lt;= sLength; j++) &#123; dp[0][j] = 1;&#125; 如果dp声明为int[][] dp = new int[tLength][sLength];那么后文初始化则会数组越界 声明int[][] dp = new int[7][8];，那么可以从dp[0][0]取到dp[6][7]，取dp[7][8]则会越界 先遍历sLength，后遍历tLength也可以","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://isunderachiever.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://isunderachiever.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"开启WSL","slug":"系统配置/编程配置/开启WSL/开启WSL","date":"2024-06-01T16:00:00.000Z","updated":"2024-06-02T13:26:12.986Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/kai-qi-wsl/kai-qi-wsl.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/kai-qi-wsl/kai-qi-wsl.html","excerpt":"","text":"开启WSL 参考文章 基本配置 打开设置，选中应用 选择程序和功能 选择启用或关闭Windows功能 勾选Hyper-v和适用于Linux的Windows子系统，然后重启电脑 安装Linux子系统 注意使用管理员权限运行cmd或者powershell # 下载或者更新wsl --update# 重新启动wsl --shutdown 前往微软商店下载Linux子系统 搜索Linux，安装心仪的系统，这里以ubuntu为例 启动系统后，会需要新建用户 输入自定义用户名以及密码，即可新建用户 配置docker配置docker过程查看博客 以下是配置后的结果 启动了两个容器，一个nginx，一个redis 输入http://localhost:80/访问nginx界面 客户端连接Redis成功 配置ssh 输入密码后切换为root用户 sudo su 执行以下命令 卸载WSL上自带的openssh并重装 apt-get updateapt-get remove openssh-server apt-get install openssh-server 修改ssh的配置 vim /etc/ssh/sshd_config 先按住shift : 输入set nu，回车即可显示行数 找到PermitRootLogin，改为yes 将如下位置的注释取消掉 然后保存并退出 service ssh statusservice ssh start ip直接写127.0.0.1即可 配置用户名、密码","categories":[{"name":"开启WSL","slug":"开启WSL","permalink":"https://isunderachiever.github.io/categories/%E5%BC%80%E5%90%AFWSL/"}],"tags":[{"name":"开启WSL","slug":"开启WSL","permalink":"https://isunderachiever.github.io/tags/%E5%BC%80%E5%90%AFWSL/"}]},{"title":"谷粒商城.html","slug":"编程语言/Java/项目/谷粒商城/谷粒商城","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/gu-li-shang-cheng/gu-li-shang-cheng.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/gu-li-shang-cheng/gu-li-shang-cheng.html","excerpt":"","text":"谷粒商城创建模块 gulimall-product gulimall-order gulimall-ware gulimall-coupon gulimall-member 创建数据库 gulimall_pms(商品) gulimall_oms(订单) gulimall_sms(营销) gulimall_ums(用户) gulimall_wms(库存) 人人开源npm使用10.16.3版本代码生成器链接后端链接前端链接","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"12.html","slug":"编程语言/Vue/Vue3/Vue3学习/12.插槽slot","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:12:25.045Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/12.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/12.html","excerpt":"","text":"插槽就是子组件中的提供给父组件使用的一个占位符，用 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的标签。 匿名插槽1.在子组件放置一个插槽 &lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2.父组件使用插槽在父组件给这个插槽填充内容 &lt;template&gt; &lt;Children&gt; &lt;template v-slot&gt; &lt;div&gt;123&lt;/div&gt; &lt;/template&gt; &lt;/Children&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;markRaw, reactive, ref, shallowRef&#125; from &quot;vue&quot;;import Children from &quot;@/view/Children.vue&quot;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 具名插槽具名插槽其实就是给插槽取个名字。一个子组件可以放多个插槽，而且可以放在不同的地方，而父组件填充内容时，可以根据这个名字把内容填充到对应插槽中 &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name=&quot;foot&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; &lt;template&gt; &lt;Children&gt; &lt;template v-slot:header&gt; &lt;div&gt;this is header&lt;/div&gt; &lt;/template&gt; &lt;template v-slot&gt; &lt;div&gt;this is slot&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:foot&gt; &lt;div&gt;this is foot&lt;/div&gt; &lt;/template&gt; &lt;/Children&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;markRaw, reactive, ref, shallowRef&#125; from &quot;vue&quot;;import Children from &quot;@/view/Children.vue&quot;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 插槽简写 &lt;template&gt; &lt;Children&gt; &lt;template #header&gt; &lt;div&gt;this is header&lt;/div&gt; &lt;/template&gt; &lt;template #default&gt; &lt;div&gt;this is slot&lt;/div&gt; &lt;/template&gt; &lt;template #foot&gt; &lt;div&gt;this is foot&lt;/div&gt; &lt;/template&gt; &lt;/Children&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;markRaw, reactive, ref, shallowRef&#125; from &quot;vue&quot;;import Children from &quot;@/view/Children.vue&quot;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 作用域插槽 在子组件动态绑定参数 派发给父组件的slot去使用 &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;div&gt; &lt;div v-for=&quot;item in 100&quot;&gt; &lt;slot :data=&quot;item&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 通过结构方式取值 &lt;template&gt; &lt;Children&gt; &lt;template #header&gt; &lt;div&gt;1&lt;/div&gt; &lt;/template&gt; &lt;template #default=&quot;&#123; data &#125;&quot;&gt; &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;div&gt;3&lt;/div&gt; &lt;/template&gt; &lt;/Children&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;markRaw, reactive, ref, shallowRef&#125; from &quot;vue&quot;;import Children from &quot;@/view/Children.vue&quot;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 动态插槽插槽可以是一个变量名 &lt;Dialog&gt; &lt;template #[name]&gt; &lt;div&gt; 23 &lt;/div&gt; &lt;/template&gt; &lt;/Dialog&gt;const name = ref(&#x27;header&#x27;)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"13.html","slug":"编程语言/Vue/Vue3/Vue3学习/13.异步组件代码分包suspense","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:12:25.047Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/13.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/13.html","excerpt":"","text":"异步组件 在大型应用中，我们可能需要将应用分割成小一些的代码块 并且减少主包的体积，这时候就可以使用异步组件 顶层await 在setup语法糖里面 使用方法 &lt;script setup&gt; 中可以使用顶层 await。结果代码会被编译成 async setup() &lt;script setup&gt; const post = await fetch(`/api/post/1`).then(r =&gt; r.json())&lt;/script&gt; 父组件引用子组件 通过defineAsyncComponent加载异步配合import 函数模式便可以分包 &lt;script setup lang=&quot;ts&quot;&gt;import &#123; reactive, ref, markRaw, toRaw, defineAsyncComponent &#125; from &#x27;vue&#x27;const Dialog = defineAsyncComponent(() =&gt; import(&#x27;../../components/Dialog/index.vue&#x27;))//完整写法const AsyncComp = defineAsyncComponent(&#123; // 加载函数 loader: () =&gt; import(&#x27;./Foo.vue&#x27;), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000&#125;) suspense&lt;suspense&gt; 组件有两个插槽。它们都只接收一个直接子节点。default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点。 &lt;Suspense&gt; &lt;template #default&gt; &lt;Dialog&gt; &lt;template #default&gt; &lt;div&gt;我在哪儿&lt;/div&gt; &lt;/template&gt; &lt;/Dialog&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt;loading...&lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt; 案例 在数据请求到达之前，显示骨架，在获取到数据后，替换骨架public&#x2F;data.json &#123; &quot;user&quot;: &#123; &quot;name&quot;: &quot;哆啦A梦&quot;, &quot;age&quot;: 15, &quot;url&quot;: &quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp7.itc.cn%2Fq_70%2Fimages03%2F20200924%2F6a36f60e6c034d78b93901b57afca05d.jpeg&amp;refer=http%3A%2F%2Fp7.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1656899135&amp;t=c53658ab441623ce626434ff0b974318&quot;, &quot;desc&quot;: &quot;大雄的好朋友&quot; &#125;&#125; SkeletonVue.vue &lt;template&gt; &lt;div id=&quot;att&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;姓名:正在请求中...&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;年龄:正在请求中...&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;header&quot;&gt; 头像:&lt;img alt=&quot;正在请求中...&quot; src=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 简介:&lt;span&gt;正在请求中...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Sync.vue &lt;template&gt; &lt;div id=&quot;att&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;姓名:&#123;&#123; user.name &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;年龄:&#123;&#123; user.age &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;header&quot;&gt; 头像:&lt;img :src=&quot;user.url&quot;&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 简介:&lt;span&gt;&#123;&#123; user.desc &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &quot;vue&quot;;import axios from &quot;axios&quot;;interface UserProps &#123; user: &#123; name: string, age: number, url: string; desc: string &#125;&#125;const &#123;data&#125; = await axios.get&lt;UserProps&gt;(&#x27;./data.json&#x27;)const user = ref&lt;&#123; name: string, age: number, url: string; desc: string&#125;&gt;();user.value = data.userconsole.log(&#x27;data:&#x27;, data);&lt;/script&gt;&lt;style scoped&gt;.header &gt; img &#123; width: 50px; height: 50px;&#125;&lt;/style&gt; APP.vue &lt;template&gt; &lt;div&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;Sync&gt; &lt;/Sync&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;SkeletonVue&gt; &lt;/SkeletonVue&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineAsyncComponent, reactive, ref&#125; from &quot;vue&quot;;import SkeletonVue from &quot;@/view/SkeletonVue.vue&quot;;const Sync = defineAsyncComponent(() =&gt; import(&#x27;@/view/Sync.vue&#x27;))&lt;/script&gt;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"11.html","slug":"编程语言/Vue/Vue3/Vue3学习/11.动态组件","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:12:25.044Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/11.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/11.html","excerpt":"","text":"&lt;template&gt; &lt;div style=&quot;display: flex;&quot;&gt; &lt;div id=&quot;att&quot; v-for=&quot;(item,index) in com&quot;&gt; &lt;div @click=&quot;changeIndex(index)&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;component :is=&quot;isCom&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &quot;vue&quot;;import ACom from &quot;@/view/ACom.vue&quot;;import BCom from &quot;@/view/BCom.vue&quot;;import CCom from &quot;@/view/CCom.vue&quot;;let isCom=ref(ACom);let com = reactive([ &#123; name: &#x27;A组件&#x27;, comName: ACom &#125;, &#123; name: &#x27;B组件&#x27;, comName: BCom &#125;, &#123; name: &#x27;C组件&#x27;, comName: CCom &#125;]);let changeIndex=(index:number)=&gt;&#123; isCom.value=com[index].comName&#125;&lt;/script&gt;&lt;style scoped&gt;#att div &#123; width: 50px; height: 30px; border: 1px solid black; text-align: center; line-height: 30px; margin: 10px 10px; cursor: pointer;&#125;&lt;/style&gt; 控制台警告如下 HomeView.vue?t=1689771528237:70 [Vue warn]: Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`. Component that was made reactive: &#123;__name: &#x27;ACom&#x27;, __hmrId: &#x27;2b2bca80&#x27;, __file: &#x27;D:/project/jetBrains/idea/antd-demo/src/view/ACom.vue&#x27;, setup: ƒ, render: ƒ&#125; at &lt;HomeView onVnodeUnmounted=fn&lt;onVnodeUnmounted&gt; ref=Ref&lt; null &gt; &gt; at &lt;RouterView&gt; at &lt;App&gt; 这是因为reactive 会进行proxy 代理 而我们组件代理之后毫无用处 节省性能开销 推荐我们使用shallowRef 或者 markRaw 跳过proxy 代理 修改如下 &lt;template&gt; &lt;div style=&quot;display: flex;&quot;&gt; &lt;div id=&quot;att&quot; v-for=&quot;(item,index) in com&quot;&gt; &lt;div @click=&quot;changeIndex(item,index)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;component :is=&quot;isCom&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;markRaw, reactive, ref, shallowRef&#125; from &quot;vue&quot;;import ACom from &quot;@/view/ACom.vue&quot;;import BCom from &quot;@/view/BCom.vue&quot;;import CCom from &quot;@/view/CCom.vue&quot;;let isCom = shallowRef(ACom);let active=ref(0);let com = reactive([ &#123; name: &#x27;A组件&#x27;, comName: markRaw(ACom) &#125;, &#123; name: &#x27;B组件&#x27;, comName: markRaw(BCom) &#125;, &#123; name: &#x27;C组件&#x27;, comName: markRaw(CCom) &#125;]);let changeIndex = (item,index) =&gt; &#123; isCom.value=item.comName active.value=index;&#125;&lt;/script&gt;&lt;style scoped&gt;#att div &#123; width: 50px; height: 30px; border: 1px solid black; text-align: center; line-height: 30px; margin: 10px 10px; cursor: pointer;&#125;&lt;/style&gt;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"14.html","slug":"编程语言/Vue/Vue3/Vue3学习/14.Teleport传送组件","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/14.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/14.html","excerpt":"","text":"Teleport Vue 3.0新特性之一。Teleport 是一种能够将我们的模板渲染至指定DOM节点，不受父级style、v-show等属性影响，但data、prop数据依旧能够共用的技术；类似于 React 的 Portal。主要解决的问题 因为Teleport节点挂载在其他指定的DOM节点下，完全不受父级style样式影响 使用方法通过to 属性 插入指定元素位置 to&#x3D;”body” 便可以将Teleport 内容传送到指定位置 &lt;Teleport to=&quot;body&quot;&gt; &lt;Loading&gt;&lt;/Loading&gt;&lt;/Teleport&gt; 也可以自定义传送位置 支持 class id等 选择器 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;div class=&quot;modal&quot;&gt;&lt;/div&gt;&lt;template&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;div&gt;我是弹框&lt;/div&gt; &lt;el-icon&gt; &lt;CloseBold /&gt; &lt;/el-icon&gt; &lt;/header&gt; &lt;main class=&quot;main&quot;&gt; 我是内容12321321321 &lt;/main&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;el-button size=&quot;small&quot;&gt;取消&lt;/el-button&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;确定&lt;/el-button&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.dialog &#123; width: 400px; height: 400px; background: #141414; display: flex; flex-direction: column; position: absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -200px; .header &#123; display: flex; color: #CFD3DC; border-bottom: 1px solid #636466; padding: 10px; justify-content: space-between; &#125; .main &#123; flex: 1; color: #CFD3DC; padding: 10px; &#125; .footer &#123; border-top: 1px solid #636466; padding: 10px; display: flex; justify-content: flex-end; &#125;&#125;&lt;/style&gt; 多个使用场景&lt;Teleport to=&quot;.modal1&quot;&gt; &lt;Loading&gt;&lt;/Loading&gt;&lt;/Teleport&gt;&lt;Teleport to=&quot;.modal2&quot;&gt; &lt;Loading&gt;&lt;/Loading&gt;&lt;/Teleport&gt; 动态控制teleport使用disabled 设置为 true则 to属性不生效 false 则生效 &lt;teleport :disabled=&quot;true&quot; to=&#x27;body&#x27;&gt; &lt;A&gt;&lt;/A&gt;&lt;/teleport&gt; 源码解析在创建teleport 组件的时候会经过patch 方法 然后调用teleport 的process 方法 主要是创建 更新 和删除的逻辑 他通过 resolveTarget 函数 获取了props.to 和 querySelect 获取 了目标元素然后判断是否有disabled 如果有则 to 属性不生效 否则 挂载新的位置 新节点disabled 为 true 旧节点disabled false 就把子节点移动回容器如果新节点disabled 为 false 旧节点为true 就把子节点移动到目标元素 遍历teleport 子节点进行unmount方法去移除","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"15.html","slug":"编程语言/Vue/Vue3/Vue3学习/15.keepalive缓存组件","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:12:25.049Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/15.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/15.html","excerpt":"","text":"内置组件keep-alive有时候我们不希望组件被重新渲染影响使用体验；或者处于性能考虑，避免多次重复渲染降低性能。而是希望组件可以缓存下来,维持当前的状态。这时候就需要用到keep-alive组件。开启keep-alive 生命周期的变化 初次进入时： onMounted&gt; onActivated 退出后触发 deactivated 再次进入只会触发 onActivated 事件挂载的方法等，只执行一次的放在 onMounted中；组件每次进去执行的方法放在 onActivated中&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; include 和 exclude&lt;keep-alive :include=&quot;&quot; :exclude=&quot;&quot; :max=&quot;&quot;&gt;&lt;/keep-alive&gt; include 和 exclude 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：max&lt;keep-alive :max=&quot;10&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; keep-alive 源码讲解源码目录runtime-core&#x2F;src&#x2F;components&#x2F;KeepAlive.ts propsprops: &#123; include: [String, RegExp, Array], // 配置了该属性，那么只有名称匹配的组件会被缓存 exclude: [String, RegExp, Array], // 配置了该属性，那么任何名称匹配的组件都不会被缓存 max: [String, Number]// 最多可以缓存多少组件实例 &#125;, setup(props: KeepAliveProps, &#123; slots &#125;: SetupContext) &#123; const instance = getCurrentInstance()! const sharedContext = instance.ctx as KeepAliveContext &#125;) const &#123; include, exclude, max &#125; = props //如果include 子组件名称 不包含， 和 exclude包含的名字 就不该缓存 直接返回 if ( (include &amp;&amp; (!name || !matches(include, name))) || (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; current = vnode return rawVNode &#125; watch( () =&gt; [props.include, props.exclude], ([include, exclude]) =&gt; &#123; //props 是响应式的 所以这个操作需要在做一遍 include &amp;&amp; pruneCache(name =&gt; matches(include, name)) exclude &amp;&amp; pruneCache(name =&gt; !matches(exclude, name)) &#125;, // prune post-render after `current` has been updated &#123; flush: &#x27;post&#x27;, deep: true &#125;) 缓存设计 //KeepAlive 组件的缓存管理 const cache: Cache = new Map() const keys: Keys = new Set() let pendingCacheKey: CacheKey | null = null //缓存函数 const cacheSubtree = () =&gt; &#123; // fix #1621, the pendingCacheKey could be 0 if (pendingCacheKey != null) &#123; cache.set(pendingCacheKey, getInnerChild(instance.subTree)) &#125; &#125; //KeepLive 组件中对缓存的管理时，首先会在组件的 onMounted 或 onUpdated 生命周期钩子函数中设置缓存，如下代码所示： onMounted(cacheSubtree) onUpdated(cacheSubtree)//Vnode 的key 作为缓存的key pendingCacheKey = key //KeepLive组件返回的函数中根据 vnode 对象的 key 去缓存中查找是否有缓存的组件， //如果缓存存在，则继承组件实例，并将用于描述组件的 vnode 对象标记为 COMPONENT_KEPT_ALIVE， //这样渲染器就不会重新创建新的组件实例；如果缓存不存在，则将 vnode 对象的key 添加到 keys 集合中 if (cachedVNode) &#123; // 如果缓存中存在缓存的组件 vnode.el = cachedVNode.el vnode.component = cachedVNode.component //无须创建组件实例，继承缓存的组件即可 if (vnode.transition) &#123; // 如果组件上有动画，处理动画 setTransitionHooks(vnode, vnode.transition!) &#125; // 标记Vnode 不会重新渲染 vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE // make this key the freshest keys.delete(key) keys.add(key) &#125; else &#123; //将 vnode 的key 添加到 keys 集合中，keys 集合用户维护缓存组件的 key keys.add(key) // prune oldest entry if (max &amp;&amp; keys.size &gt; parseInt(max as string, 10)) &#123; pruneCacheEntry(keys.values().next().value) &#125; &#125; 生命周期//隐藏容器 const storageContainer = createElement(&#x27;div&#x27;) //在实例上注册两个钩子函数 activate， deactivate sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =&gt; &#123; const instance = vnode.component! move(vnode, container, anchor, MoveType.ENTER, parentSuspense) // props 可能会发生变化，因此需要执行 patch 过程 patch( instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized ) queuePostRenderEffect(() =&gt; &#123; instance.isDeactivated = false if (instance.a) &#123; invokeArrayFns(instance.a) &#125; const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted if (vnodeHook) &#123; invokeVNodeHook(vnodeHook, instance.parent, vnode) &#125; &#125;, parentSuspense) if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123; // Update components tree devtoolsComponentAdded(instance) &#125; &#125; sharedContext.deactivate = (vnode: VNode) =&gt; &#123; const instance = vnode.component! //将组件移动到隐藏容器中 //在 “卸载” 组件时，并不是真正的卸载，而是调用 move 方法，将组件搬运到一个隐藏的容器中 move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense) queuePostRenderEffect(() =&gt; &#123; if (instance.da) &#123; invokeArrayFns(instance.da) &#125; const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted if (vnodeHook) &#123; invokeVNodeHook(vnodeHook, instance.parent, vnode) &#125; instance.isDeactivated = true &#125;, parentSuspense) if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123; // Update components tree devtoolsComponentAdded(instance) &#125; &#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"多级缓存.html","slug":"编程语言/Java/学习/框架/多级缓存/多级缓存","date":"2024-06-01T14:12:25.000Z","updated":"2024-06-01T14:32:53.437Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/duo-ji-huan-cun/duo-ji-huan-cun.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/duo-ji-huan-cun/duo-ji-huan-cun.html","excerpt":"","text":"多级缓存传统缓存的问题 传统的缓存策略一般是请求到达Tomcat后，先查询Redis,如果未命中则查询数据库，存在下面的问题:请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈Redis缓存失效时，会对数据库产生冲击 多级缓存方案多级缓存就是充分利用请求处理的每个环节,分别添加缓存，减轻Tomcat压力，提升服务性能: 减轻了tomcat的压力，避免了对数据库的压力，需要在nginx内部实现对于redis、tomcat访问的业务代码 将来会将nginx部署为集群 JVM进程缓存(Tomcat缓存) Lua语法入门 实现多级缓存 缓存同步策略 环境配置MySQL 后期做数据同步需要用到MySQL的主从功能，所以需要大家在虚拟机中，利用Docker来运行一个MySQL容器。 为了方便后期配置MySQL，我们先准备两个目录，用于挂载容器的数据和配置文件目录： # 进入/tmp目录cd /tmp# 创建文件夹mkdir mysql# 进入mysql目录cd mysql 运行命令 在&#x2F;tmp&#x2F;mysql&#x2F;conf目录添加一个my.cnf文件，作为mysql的配置文件： # 创建文件touch /tmp/mysql/conf/my.cnf 文件内容如下 [mysqld]skip-name-resolvecharacter_set_server=utf8datadir=/var/lib/mysqlserver-id=1000 docker run \\ -p 3307:3306 \\ --name mysql-demo \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --privileged \\ -d \\ mysql:5.7.25 重启容器 docker restart mysql-demo navicat新建连接新建数据库执行sql SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;DROP TABLE IF EXISTS `tb_item`;CREATE TABLE `tb_item` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;商品id&#x27;, `title` varchar(264) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#x27;商品标题&#x27;, `name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;商品名称&#x27;, `price` bigint(20) NOT NULL COMMENT &#x27;价格（分）&#x27;, `image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;商品图片&#x27;, `category` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;类目名称&#x27;, `brand` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;品牌名称&#x27;, `spec` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#x27;规格&#x27;, `status` int(1) NULL DEFAULT 1 COMMENT &#x27;商品状态 1-正常，2-下架，3-删除&#x27;, `create_time` datetime NULL DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_time` datetime NULL DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`) USING BTREE, INDEX `status`(`status`) USING BTREE, INDEX `updated`(`update_time`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 50002 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;商品表&#x27; ROW_FORMAT = COMPACT;INSERT INTO `tb_item` VALUES (10001, &#x27;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&#x27;, &#x27;SALSA AIR&#x27;, 16900, &#x27;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&#x27;, &#x27;拉杆箱&#x27;, &#x27;RIMOWA&#x27;, &#x27;&#123;\\&quot;颜色\\&quot;: \\&quot;红色\\&quot;, \\&quot;尺码\\&quot;: \\&quot;26寸\\&quot;&#125;&#x27;, 1, &#x27;2019-05-01 00:00:00&#x27;, &#x27;2019-05-01 00:00:00&#x27;);INSERT INTO `tb_item` VALUES (10002, &#x27;安佳脱脂牛奶 新西兰进口轻欣脱脂250ml*24整箱装*2&#x27;, &#x27;脱脂牛奶&#x27;, 68600, &#x27;https://m.360buyimg.com/mobilecms/s720x720_jfs/t25552/261/1180671662/383855/33da8faa/5b8cf792Neda8550c.jpg!q70.jpg.webp&#x27;, &#x27;牛奶&#x27;, &#x27;安佳&#x27;, &#x27;&#123;\\&quot;数量\\&quot;: 24&#125;&#x27;, 1, &#x27;2019-05-01 00:00:00&#x27;, &#x27;2019-05-01 00:00:00&#x27;);INSERT INTO `tb_item` VALUES (10003, &#x27;唐狮新品牛仔裤女学生韩版宽松裤子 A款/中牛仔蓝（无绒款） 26&#x27;, &#x27;韩版牛仔裤&#x27;, 84600, &#x27;https://m.360buyimg.com/mobilecms/s720x720_jfs/t26989/116/124520860/644643/173643ea/5b860864N6bfd95db.jpg!q70.jpg.webp&#x27;, &#x27;牛仔裤&#x27;, &#x27;唐狮&#x27;, &#x27;&#123;\\&quot;颜色\\&quot;: \\&quot;蓝色\\&quot;, \\&quot;尺码\\&quot;: \\&quot;26\\&quot;&#125;&#x27;, 1, &#x27;2019-05-01 00:00:00&#x27;, &#x27;2019-05-01 00:00:00&#x27;);INSERT INTO `tb_item` VALUES (10004, &#x27;森马(senma)休闲鞋女2019春季新款韩版系带板鞋学生百搭平底女鞋 黄色 36&#x27;, &#x27;休闲板鞋&#x27;, 10400, &#x27;https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/29976/8/2947/65074/5c22dad6Ef54f0505/0b5fe8c5d9bf6c47.jpg!q70.jpg.webp&#x27;, &#x27;休闲鞋&#x27;, &#x27;森马&#x27;, &#x27;&#123;\\&quot;颜色\\&quot;: \\&quot;白色\\&quot;, \\&quot;尺码\\&quot;: \\&quot;36\\&quot;&#125;&#x27;, 1, &#x27;2019-05-01 00:00:00&#x27;, &#x27;2019-05-01 00:00:00&#x27;);INSERT INTO `tb_item` VALUES (10005, &#x27;花王（Merries）拉拉裤 M58片 中号尿不湿（6-11kg）（日本原装进口）&#x27;, &#x27;拉拉裤&#x27;, 38900, &#x27;https://m.360buyimg.com/mobilecms/s720x720_jfs/t24370/119/1282321183/267273/b4be9a80/5b595759N7d92f931.jpg!q70.jpg.webp&#x27;, &#x27;拉拉裤&#x27;, &#x27;花王&#x27;, &#x27;&#123;\\&quot;型号\\&quot;: \\&quot;XL\\&quot;&#125;&#x27;, 1, &#x27;2019-05-01 00:00:00&#x27;, &#x27;2019-05-01 00:00:00&#x27;);DROP TABLE IF EXISTS `tb_item_stock`;CREATE TABLE `tb_item_stock` ( `item_id` bigint(20) NOT NULL COMMENT &#x27;商品id，关联tb_item表&#x27;, `stock` int(10) NOT NULL DEFAULT 9999 COMMENT &#x27;商品库存&#x27;, `sold` int(10) NOT NULL DEFAULT 0 COMMENT &#x27;商品销量&#x27;, PRIMARY KEY (`item_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;INSERT INTO `tb_item_stock` VALUES (10001, 99996, 3219);INSERT INTO `tb_item_stock` VALUES (10002, 99999, 54981);INSERT INTO `tb_item_stock` VALUES (10003, 99999, 189);INSERT INTO `tb_item_stock` VALUES (10004, 99999, 974);INSERT INTO `tb_item_stock` VALUES (10005, 99999, 18649);SET FOREIGN_KEY_CHECKS = 1; 基本工程下载nginx配置在nginx目录下，运行命令启动nginx start nginx.exe 访问页面http://localhost/item.html?id=10001现在，页面是假数据展示的。我们需要向服务器发送ajax请求，查询商品数据。打开控制台，可以看到页面有发起ajax查询数据而这个请求地址同样是80端口，所以被当前的nginx反向代理了。查看nginx的conf目录下的nginx.conf文件其中的关键配置如下：其中的192.168.150.101是我的虚拟机IP，也就是我的Nginx业务集群要部署的地方：完整内容如下： #user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; keepalive_timeout 65; upstream nginx-cluster&#123; server 192.168.150.101:8081; &#125; server &#123; listen 80; server_name localhost; location /api &#123; proxy_pass http://nginx-cluster; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 本地进程缓存缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类:分布式缓存，例如Redis: 优点:存储容量更大、可靠性更好、可以在集群间共享 缺点:访问缓存有网络开销 场景:缓存数据量较大、可靠性要求较高、需要在集群间共享进程本地缓存，例如HashMap、GuavaCache: 优点:读取本地内存,没有网络开销，速度更快 缺点:存储容量有限、可靠性较低、无法共享 场景:性能要求较高，缓存数据量较小 @Testvoid testBasicOps() &#123; // 创建缓存对象 Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build(); // 存数据 cache.put(&quot;gf&quot;, &quot;迪丽热巴&quot;); // 取数据，不存在则返回null String gf = cache.getIfPresent(&quot;gf&quot;); System.out.println(&quot;gf = &quot; + gf); // 取数据，不存在则去数据库查询 String defaultGF = cache.get(&quot;defaultGF&quot;, key -&gt; &#123; // 这里可以去数据库根据 key查询value return &quot;柳岩&quot;; &#125;); System.out.println(&quot;defaultGF = &quot; + defaultGF);&#125; Caffeine提供了三种缓存驱逐策略: 基于容量:设置缓存的数量上限 // 创建缓存对象Cache&lt;String, String&gt; cache = Caffeine.newBuilder() // 设置缓存大小上限为 1 .maximumSize(1) .build(); 基于时间:设置缓存的有效时间 // 创建缓存对象Cache&lt;String, String&gt; cache = Caffeine.newBuilder() // 设置缓存有效期为 10 秒 .expireAfterWrite(Duration.ofSeconds(1)) .build(); 基于引用:设置缓存为软引用或弱引用,利用GC来回收缓存数据。性能较差,不建议使用。在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后， 或者在空闲时间完成对失效数据的驱逐。 实现商品的查询的本地进程缓存 利用Caffeine实现下列需求: 给根据id查询商品的业务添加缓存，缓存未命中时查询数据库 给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库 缓存初始大小为100 缓存上限为10000新建配置类这里10_000其实是指10000，下划线的作用是分隔数字，方便阅读，不加也行 @Configurationpublic class CaffeineConfig &#123; @Bean public Cache&lt;Long, Item&gt; itemCache()&#123; return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); &#125; @Bean public Cache&lt;Long, ItemStock&gt; stockCache()&#123; return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); &#125;&#125; 查询api添加缓存 它首先检查给定 id 对应的缓存项是否存在（即 ItemStock 是否在缓存中）。 如果缓存中存在该 id 对应的 ItemStock，则直接从缓存中获取并返回结果。 如果缓存中不存在该 id 对应的 ItemStock，则执行传递给 get 方法的第二个参数——一个函数式接口（key -&gt; stockService.getById(key)）。这个函数会被用来计算并返回需要缓存的值，即通过调用 stockService.getById(key) 查询数据库以获取 ItemStock 对象。 在从数据库获取到 ItemStock 后，Caffeine 会将其放入缓存，并将该对象作为结果返回。 虽然代码片段中没有显式地进行“存入缓存”的操作，但在首次查询不存在于缓存中的 id 时，Caffeine 自动完成了从数据库加载数据并缓存这一过程。后续对该 id 的查询将会命中缓存，从而避免了对数据库的重复访问。 @RestController@RequestMapping(&quot;item&quot;)public class ItemController &#123; @Autowired private Cache&lt;Long, Item&gt; itemCache; @Autowired private Cache&lt;Long, ItemStock&gt; stockCache; // 注入Bean @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; @GetMapping(&quot;list&quot;) public PageDTO queryItemPage( @RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer page, @RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;) Integer size) &#123; // 分页查询商品 Page&lt;Item&gt; result = itemService.query() .ne(&quot;status&quot;, 3) .page(new Page&lt;&gt;(page, size)); // 查询库存 List&lt;Item&gt; list = result.getRecords().stream().peek(item -&gt; &#123; ItemStock stock = stockService.getById(item.getId()); item.setStock(stock.getStock()); item.setSold(stock.getSold()); &#125;).collect(Collectors.toList()); // 封装返回 return new PageDTO(result.getTotal(), list); &#125; @PostMapping public void saveItem(@RequestBody Item item) &#123; itemService.saveItem(item); &#125; @PutMapping public void updateItem(@RequestBody Item item) &#123; itemService.updateById(item); &#125; @PutMapping(&quot;stock&quot;) public void updateStock(@RequestBody ItemStock itemStock) &#123; stockService.updateById(itemStock); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public void deleteById(@PathVariable(&quot;id&quot;) Long id) &#123; itemService.update().set(&quot;status&quot;, 3).eq(&quot;id&quot;, id).update(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Item findById(@PathVariable(&quot;id&quot;) Long id) &#123; // 如果缓存存在，则直接返回，不存在则查数据库 return itemCache.get(id, key -&gt; itemService.query() .ne(&quot;status&quot;, 3).eq(&quot;id&quot;, key) .one() ); &#125; @GetMapping(&quot;/stock/&#123;id&#125;&quot;) public ItemStock findStockById(@PathVariable(&quot;id&quot;) Long id) &#123; // 如果缓存存在，则直接返回，不存在则查数据库 return stockCache.get(id, key -&gt; stockService.getById(key)); &#125;&#125; 访问http://localhost:8081/item/10001，多次刷新，但日志只打印了一次sql，说明查的是缓存 同理访问http://localhost:8081/item/stock/10001 Lua语法入门基础1.在Linux虚拟机的任意目录下，新建一-个hello.lua文件 touch hello.lua 2.添加下面的内容 print(&quot;Hello World!&quot;) 3.运行 lua hello.lua 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值(在条件表达式中相当于false)。 boolean 包含两个值: false和true number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由C或Lua编写的函数 table Lua中的表(table) 其实是一个”关联数组” (associative arrays)，数组的索引可以是数字、字符串或表类型。在Lua里，table的创建是通过”构造表达式”来完成，最简单构造表达式是{},用来创建一 个空表。 可以使用type关键字来判断变量的类型 print(type(&quot;hello&quot;)) 声明变量 local代表局部变量 -- 声明字符串local str = &#x27;hello&#x27;-- 声明数字local num = 21-- 声明布尔类型local flag = true-- 声明数组 key为索引的tablelocal arr = &#123;&#x27;java&#x27;,&#x27;python&#x27;,&#x27;go&#x27;&#125;-- 声明table，类似于java中的maplocal map=&#123; name = &#x27;jack&#x27; , gender = &#x27;男&#x27;&#125;-- 访问数组，lua数组的角标从1开始print(arr[1])-- 访问tableprint(map[&#x27;name&#x27;])print(map.name)-- 字符串拼接local helloworld=&#x27;Hello &#x27; .. &#x27;World!&#x27; 遍历 -- 遍历数组local arr = &#123;&#x27;java&#x27;,&#x27;python&#x27;,&#x27;go&#x27;&#125;-- ipairs代表解析数组for key,value in ipairs(arr) do print(key,value)end-- 遍历maplocal map=&#123; name = &#x27;jack&#x27; , gender = &#x27;男&#x27;&#125;-- 遍历tablefor key,value in pairs(map) do print(key,value)end 执行结果如下 函数 定义函数的语法 function 函数名(arg1,arg2...,arg3) -- 函数体 return 返回值end-- 例如，定义一个函数function printArr(arr) for key,value in ipairs(arr) do print(key,value) endendprintArr(&#123;&#x27;java&#x27;,&#x27;python&#x27;,&#x27;go&#x27;&#125;) 条件控制if(布尔表达式)then -- [为true时，执行的语句]else -- [为false时，执行的语句]end 逻辑操作符，and,or,not如、A and B、A orB、not B function printArr(arr) if(not arr) then print(&#x27;参数不能为nil&#x27;) return nil end for key,value in ipairs(arr) do print(key,value) endendlocal lang=&#123;&#x27;java&#x27;,&#x27;python&#x27;,&#x27;go&#x27;&#125;printArr(lang)printArr(nil) 多级缓存OpenRestry安装 官网OpenResty是-个基于Nginx的高性能Web平台，用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。具备下列特点: 具备Nginx的完整功能 基于Lua语言进行扩展，集成了大量精良的Lua库、第三方模块 允许使用Lua自定义业务逻辑、自定义库首先要安装OpenResty的依赖开发库，执行命令：yum install -y pcre-devel openssl-devel gcc --skip-broken 安装OpenResty仓库yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo 如果提示说命令不存在，则运行：yum install -y yum-utils 然后再重复上面的命令安装OpenResty然后就可以像下面这样安装软件包，比如 openresty：yum install -y openresty 安装opm工具opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。如果你想安装命令行工具 opm，那么可以像下面这样安装 openresty-opm 包：yum install -y openresty-opm 配置nginxvi /etc/profile 在最下面加入两行：export NGINX_HOME=/usr/local/openresty/nginxexport PATH=$&#123;NGINX_HOME&#125;/sbin:$PATH NGINX_HOME：后面是OpenResty安装目录下的nginx的目录然后让配置生效：source /etc/profile 所以运行方式与nginx基本一致：# 启动nginxnginx# 重新加载配置nginx -s reload# 停止nginx -s stop nginx的默认配置文件注释太多，影响后续我们的编辑，这里将nginx.conf中的注释部分删除，保留有效部分。修改/usr/local/openresty/nginx/conf/nginx.conf文件，内容如下：#user nobody;worker_processes 1;error_log logs/error.log;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 8081; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 在Linux的控制台输入命令以启动nginx：nginx 然后访问页面：http://192.168.56.10:8081，注意ip地址替换为你自己的虚拟机IP： 入门 访问http://localhost/item.html?id=10001商品详情页，发送的请求是http://localhost/api/item/10001nginx在捕获到/api请求后，转给了虚拟机8081，而刚刚部署的OpenRestry在8081，这里OpenRestry需要做一些业务处理步骤一:修改nginx.conf文件1.在nginx.conf的http 下面，添加对OpenResty的Lua模块的加载: #加载lua模块lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;;#加载c模块lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;; 2.在nginx.conf的server 下面，添加对/api/item这个路径的监听: location /api/item &#123; #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua;&#125; 在nginx目录下新建文件夹lua lua目录下新建文件item.lua 编写如下内容 -- 返回一条假数据，这里的ngx.say()函数就是把数据写入Response中ngx.say(&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;普通行李箱&quot;&#125;&#x27;) 重新加载配置 nginx -s reload 可以看到lua脚本已经生效了 请求参数OpenResty提供了各种API用来获取不同类型的请求参数:案例获取请求路径中的商品id信息，拼接到json结果中返回 location ~ /api/item/(\\d+) &#123; #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua;&#125; 封装http请求工具案例这里要修改item.lua,满足下面的需求: 获取请求参数中的id 根据id向Tomcat服务发送请求，查询商品信息 根据id向Tomcat服务发送请求，查询库存信息 组装商品信息、库存信息，序列化为JSON格式并返回 nginx发送http请求 /path是指具体的请求路径，如/item/10001 返回响应的内容包括 resp.status 响应状态码 resp.header 响应头，是一个table resp.body 响应体，就是响应数据 local resp=ngx.location.capture(&#x27;/path&#x27;,&#123; -- 请求方式 method=ngx.HTTP_GET, -- get方式传参 args=&#123;a=1,b=2&#125;, -- post方式传参 body=&quot;c=3&amp;d=4&quot;&#125;) 注意:这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理:location /item &#123; proxy_pass http://192.168.56.1:8081;&#125; 封装通用http请求 -- 封装函数，发送http请求local function read_http(path,params) local resp=ngx.location.capture(path,&#123; method=ngx.HTTP_GET, args=params, &#125;) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR,&quot;http not found,path: &quot;,path,&quot;, args: &quot;,args) ngx.exit(404) end return resp.bodyend-- 导出方法local _M=&#123; read_http=read_http&#125;return _M 再次请求即可 咱先理一下请求的过程 首先nginx里的html发送ajax请求http://localhost/api/item/10001 nginx反向代理给192.168.56.10:8081 而虚拟机的openresty由item.lua来处理这个请求 item.lua通过封装好的请求工具发送请求 而openresty本身也具有nginx的功能，将请求反向代理到windows主机上 后端接收到请求，响应数据 现在数据还不完整，还需要查询库存信息返回，此时只有商品信息 需要将json数据转换成lua中的table(也就是DTO) OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。 -- 导入cjson库local cjson=require(&quot;cjson&quot;)-- 序列化local obj=&#123; name=&quot;jack&quot;, age=21&#125;local json=cjson.encode(obj)-- 反序列化local json=&#x27;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:21&#125;&#x27;local obj=cjson.decode(json)print(obj.name) 编写item.lua -- 导入cjson库local cjson=require(&quot;cjson&quot;)-- 导入请求工具common-- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径local common=require(&quot;common&quot;)local read_http=common.read_http-- 获取路径参数local id=ngx.var[1]-- 查询商品信息local itemJson=read_http(&quot;/item/&quot;..id,nil)-- 查询库存信息local stockJson=read_http(&quot;/item/stock/&quot;..id,nil)-- dto转换-- json数据转换成lua中的tablelocal item=cjson.decode(itemJson)local stock=cjson.decode(stockJson)-- 组合数据item.stock=stock.stockitem.sold=stock.sold-- 返回结果ngx.say(cjson.encode(item)) 重启OpenResty，再次查看请求，库存信息已经出现 nginx -s reload Tomcat集群的负载均衡 既然要配置负载均衡，那请求就不能只指向一个ip了，需要配置集群查询缓存过程:查询8081，如果缓存存在则直接返回，如果不存在，在查询数据库之后，存入进程缓存中，下次即可从进程缓存获取数据但是，进程缓存无法共享，就是8081的进程缓存无法与8082共享我们希望查询商品id为10001在第一次查询之后永远都有缓存，该如何做？我们必须要让10001的请求每次都查询同一台服务器，这样就可以让缓存一直生效修改nginx负载均衡算法 对请求uri采用hash算法，使在请求相同的商品时能走到同一台服务器配置集群 #user nobody;worker_processes 1;error_log logs/error.log;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 加载lua模块 lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;; # 加载c模块 lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;; upstream tomcat-cluster&#123; hash $request-uri; server 192.168.56.1:8081; server 192.168.56.1:8082; &#125; server &#123; listen 8081; server_name localhost; location /item &#123; proxy_pass http://tomcat-cluster; &#125; location ~ /api/item/(\\d+) &#123; #响应类型，这里返回json default_type application/json; #响应数据由lua/item.lua这个文件来决定 content_by_lua_file lua/item.lua; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 继续复制一台Springboot实例，并启动访问http://localhost/item.html?id=10002和http://localhost/item.html?id=10001 负载均衡已实现，而在多次访问时，并没有mysql日志打印，说明是查询缓存得到的数据 添加Redis需求 但是按照多级缓存的设想，并不是优先查询Tomcat，而是优先查询Redis，在Redis缓存未命中时，再去查询Tomcat 冷启动与缓存预热冷启动:服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询 时添加缓存，可能会给数据库带来较大压力。缓存预热:在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。我们数据量较少，可以在启动时将所有数据都放入缓存中。 使用Docker安装Redis docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 添加Redis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置Redis地址 spring: redis: host: 192.168.56.10 编写Redis初始化类 @Componentpublic class RedisHandler implements InitializingBean &#123; @Autowired private StringRedisTemplate template; @Override public void afterPropertiesSet() throws Exception &#123; // 初始化缓存 &#125;&#125; 我的配置 server: port: 8081spring: application: name: itemservice datasource: url: jdbc:mysql://192.168.56.10:3307/heima?useSSL=false username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver redis: host: 192.168.56.10 port: 6379mybatis-plus: type-aliases-package: com.heima.item.pojo configuration: map-underscore-to-camel-case: true global-config: db-config: update-strategy: not_null id-type: autologging: level: com.heima: debug pattern: dateformat: HH:mm:ss:SSS import com.fasterxml.jackson.databind.ObjectMapper;import com.heima.item.pojo.Item;import com.heima.item.pojo.ItemStock;import com.heima.item.service.IItemService;import com.heima.item.service.IItemStockService;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.util.List;@Componentpublic class RedisHandler implements InitializingBean &#123; @Autowired private StringRedisTemplate template; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; // Spring自带的序列化工具 private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception &#123; // 初始化缓存 // 1.查询商品信息 List&lt;Item&gt; itemList = itemService.list(); // 2.存入缓存 for (Item item : itemList) &#123; // 将item序列化成json String json = MAPPER.writeValueAsString(item); // 存入缓存 template.opsForValue().set(&quot;item:id:&quot;+item.getId(),json); &#125; // 3.查询库存信息 List&lt;ItemStock&gt; stockList = stockService.list(); // 2.存入缓存 for (ItemStock stock : stockList) &#123; // 将item序列化成json String json = MAPPER.writeValueAsString(stock); // 存入缓存 template.opsForValue().set(&quot;item:stock:id:&quot;+stock.getId(),json); &#125; &#125;&#125; 访问http://localhost/item.html?id=10004界面，实现了缓存预热的功能 查询Redis缓存 OpenResty优先查询Redis，Redis缓存未命中，再查询TomcatOpenResty的Redis模块OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用:引入Redis模块，并初始化Redis对象 -- 引入redis模块local redis = requirl(&quot;resty.redis&quot;)-- 初始化Redis对象local red = redis:new( )-- 设置Redis超时时间red:set_timeouts(1000, 1000, 1000) 封装函数，用来释放Redis连接，其实是放入连接池 -- 关闭redi s连接的工具方法，其实是放入连接池local function close_redis(red) -- 连接的空闲时间，单位是毫秒 local pool_max_idle_time = 10000 -- 连接池大小 local pool_size = 100 local ok,err = red:set_keepalive(pool_max_idle_time,pool_size) if not ok then ngx.log(ngx.ERR，&quot;放入Redis连接池失败: &quot;,err) endend 封装函数，从Redis读数据并返回 -- 查询redis的方法ip和port是redi s地址，key是查询的keylocal function read_redis(ip, port, key) -- 获取一个连接 local ok，err = red:connect(ip,port) if not ok then ngx.log(ngx.ERR，&quot;连接redis失败: &quot;,err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR，&quot;查询Redis失败: &quot; ,err,&quot;, key = &quot;，key) end -- 查询成功，但是得到的数据为空 if resp == ngx.null then resp = nil ngx.log(ngx.ERR，&quot;查询Redis数据为空， key = &quot;,key) end close_redis(red) return respend 在common.lua下处理如下 -- 导入redislocal redis=require(&quot;resty.redis&quot;)-- 初始化redislocal red=redis:new()red:set_timeouts(1000,1000,1000)-- 关闭redis连接的工具方法，其实是放入连接池local function close_redis(red) local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒 local pool_size = 100 --连接池大小 local ok, err = red:set_keepalive(pool_max_idle_time, pool_size) if not ok then ngx.log(ngx.ERR, &quot;放入redis连接池失败: &quot;, err) endend-- 查询redis的方法 ip和port是redis地址，key是查询的keylocal function read_redis(ip, port, key) -- 获取一个连接 local ok, err = red:connect(ip, port) if not ok then ngx.log(ngx.ERR, &quot;连接redis失败 : &quot;, err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR, &quot;查询Redis失败: &quot;, err, &quot;, key = &quot; , key) end --得到的数据为空处理 if resp == ngx.null then resp = nil ngx.log(ngx.ERR, &quot;查询Redis数据为空, key = &quot;, key) end close_redis(red) return respend-- 封装函数，发送http请求local function read_http(path,params) local resp=ngx.location.capture(path,&#123; method=ngx.HTTP_GET, args=params, &#125;) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR,&quot;http not found,path: &quot;,path,&quot;, args: &quot;,args) ngx.exit(404) end return resp.bodyend-- 导出方法local _M=&#123; read_http=read_http, read_redis=read_redis&#125;return _M 在item.lua下封装一个read_data函数，优先查询redis，redis未命中再查询tomcat 查询商品和库存，都调用read_data函数 -- 封装函数，先查询redis，再查询httplocal function read_data(key, path, par ams) -- 查询redis local resp = read_redis(&quot;127.0.0.1&quot;,6379,key) -- 判断redis是否命中 if not resp then -- Redis查询失败，查询http resp = read_http(path, par ams) end return respend item.lua -- 导入cjson库local cjson=require(&quot;cjson&quot;)-- 导入请求工具common-- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径local common=require(&quot;common&quot;)local read_http=common.read_httplocal read_redis=common.read_redis-- 封装查询函数function read_data(key,path,params) -- 查询redis local resp=read_redis(&quot;127.0.0.1&quot;,6379,key) -- 判断查询结果 if not resp then -- redis查询失败，尝试查询tomcat ngx.log(&quot;redis查询失败，尝试查询tomcat：&quot;,key) resp=read_http(path,params) end return respend-- 获取路径参数local id=ngx.var[1]-- 查询商品信息local itemJson=read_data(&quot;item:id:&quot;..id , &quot;/item/&quot;..id , nil)-- 查询库存信息local stockJson=read_data(&quot;item:stock:id:&quot;..id , &quot;/item/stock/&quot;..id , nil)-- dto转换-- json数据转换成lua中的tablelocal item=cjson.decode(itemJson)local stock=cjson.decode(stockJson)-- 组合数据item.stock=stock.stockitem.sold=stock.sold-- 返回结果ngx.say(cjson.encode(item)) 更新Redis数据，重新查看网页，发现已经变成22寸了 Nginx本地缓存 优先查询OpenResty本地缓存，其次是Redis，最后是Tomcat OpenResty为Nginx提供了shard dict的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。 开启共享字典，在nginx.conf的http下添加配置# 共享字典，也就是本地缓存，名称叫做：item_cache，大小150mlua_shared_dict item_cache 150m; 操作共享字典-- 获取本地缓存对象local item_cache=ngx.shared.item_cache-- 存储，指定key、value、过期时间，单位s，默认为0代表永不过期item_cache:set(&#x27;key&#x27;,&#x27;value&#x27;,1000)-- 读取local val=item_cache:get(&#x27;key&#x27;) 修改item.lua，优先查询nginx本地缓存，其次是redis、tomcat、mysql 查询Redis、Tomcat成功后，将缓存信息写入本地缓存，并设置有效期 商品基本信息设置为有效期30min 库存信息设置为有效期1min -- 导入cjson库local cjson=require(&quot;cjson&quot;)-- 导入请求工具common-- 这里common.lua正好在lualib目录下，所以可以直接导入;如果不是，则需要写上路径local common=require(&quot;common&quot;)local read_http=common.read_httplocal read_redis=common.read_redislocal item_cache=ngx.shared.item_cache-- 封装查询函数function read_data(key,expire,path,params) -- 查询本地缓存 local val=item_cache:get(key) if not val then ngx.log(ngx.ERR,&quot;本地缓存查询失败，尝试查询redis，key:&quot;,key) -- 查询redis val=read_redis(&quot;127.0.0.1&quot;,6379,key) -- 判断查询结果 if not val then -- redis查询失败，尝试查询tomcat ngx.log(ngx.ERR,&quot;redis查询失败，尝试查询tomcat，key:&quot;,key) val=read_http(path,params) end end -- 查询成功，把数据写入本地缓存 item_cache:set(key,val,expire) return valend-- 获取路径参数local id=ngx.var[1]-- 查询商品信息local itemJson=read_data(&quot;item:id:&quot;..id,1800,&quot;/item/&quot;..id,nil)-- 查询库存信息local stockJson=read_data(&quot;item:stock:id:&quot;..id,60,&quot;/item/stock/&quot;..id,nil)-- dto转换-- json数据转换成lua中的tablelocal item=cjson.decode(itemJson)local stock=cjson.decode(stockJson)-- 组合数据item.stock=stock.stockitem.sold=stock.sold-- 返回结果ngx.say(cjson.encode(item)) 缓存同步缓存数据同步的常见方式有三种: 设置有效期:给缓存设置有效期，到期后自动删除。再次查询时更新 优势:简单、方便 缺点:时效性差，缓存过期之前可能不-致 场景:更新频率较低，时效性要求低的业务 同步双写: 在修改数据库的同时，直接修改缓存 优势:时效性强，缓存与数据库强一致 缺点:有代码侵入,耦合度高; 场景:对一致性、时效性要求较高的缓存数据 异步通知:修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据 优势:低耦合，可以同时通知多个缓存服务 缺点:时效性一般，可能存在中间不一致状态 场景:时效性要求-般，有多个服务需要同步 基于MQ的异步通知基于Canal的异步通知Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下: MySQL master将数据变更写入二进制日志( binary log)，其中记录的数据叫做binary log events MySQL slave将master的binary log events拷贝到它的中继日志(relay log) MySQL slave重放relay log中事件,将数据变更反映它自己的数据 初识CanalCanal就是把自己伪装成MySQL的一个slave节 点,从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。 开启MySQL主从 修改配置文件 /tmp/mysql/conf/my.cnf 添加内容 log-bin=/var/lib/mysql/mysql-binbinlog-do-db=heima 重启mysql docker restart mysql-demo 设置用户权限接下来添加一个用于数据同步的用户，出于安全的考虑，这里仅提供对heima这个库的操作权限 create user canal@&#x27;%&#x27; IDENTIFIED by &#x27;canal&#x27;;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;canal&#x27;;FLUSH PRIVILEGES; 执行成功后，查看到该用户 如果从库的position小于主库的position，则证明有数据需要同步 创建网络我们需要创建一个网络，将MySQL、Canal、MQ放到同一个Docker网络中： docker network create heima 让mysql加入这个网络： docker network connect heima mysql-demo 然后运行命令创建Canal容器： docker run -p 11111:11111 --name canal \\-e canal.destinations=heima \\-e canal.instance.master.address=mysql-demo:3306 \\-e canal.instance.dbUsername=canal \\-e canal.instance.dbPassword=canal \\-e canal.instance.connectionCharset=UTF-8 \\-e canal.instance.tsdb.enable=true \\-e canal.instance.gtidon=false \\-e canal.instance.filter.regex=heima\\\\..* \\--network heima \\-d canal/canal-server:v1.1.5 说明: -p 11111:11111：这是canal的默认监听端口 -e canal.instance.master.address=mysql:3306：数据库地址和端口，如果不知道mysql容器地址，可以通过docker inspect 容器id来查看 -e canal.instance.dbUsername=canal：数据库用户名 -e canal.instance.dbPassword=canal ：数据库密码 -e canal.instance.filter.regex=：要监听的表名称表名称监听支持的语法：mysql 数据解析关注的表，Perl正则表达式.多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\\\) 常见例子：1. 所有表：.* or .*\\\\..*2. canal schema下所有表： canal\\\\..*3. canal下的以canal打头的表：canal\\\\.canal.*4. canal schema下的一张表：canal.test15. 多个规则组合使用然后以逗号隔开：canal\\\\..*,mysql.test1,mysql.test2 查看是否互联成功 docker exec -it canal /bin/bash# 查看运行日志more /home/admin/canal-server/logs/canal/canal.logmore /home/admin/canal-server/logs/heima/heima.log 监听Canal实现缓存同步导入依赖 &lt;dependency&gt; &lt;groupId&gt;top.javatool&lt;/groupId&gt; &lt;artifactId&gt;canal-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1-RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写配置 canal: # canal实例名称，要跟canal-server运行时设置的destination一致 destination: heima # canal地址 server: 192.168.56.10:11111 import com.heima.item.pojo.Item;import org.springframework.stereotype.Component;import top.javatool.canal.client.annotation.CanalTable;import top.javatool.canal.client.handler.EntryHandler;@Component@CanalTable(&quot;tb_item&quot;)public class ItemHandler implements EntryHandler&lt;Item&gt; &#123; @Override public void insert(Item item) &#123; // 新增数据到redis &#125; @Override public void update(Item before, Item after) &#123; // 更新redis数据 // 更新本地数据 &#125; @Override public void delete(Item item) &#123; // 删除redis数据 // 清理本地缓存 &#125;&#125; 此时Canal还无法将表的字段映射到对应的DTO，需要添加Canal的注解进行指定 import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import org.springframework.data.annotation.Id;import org.springframework.data.annotation.Transient;import java.util.Date;@Data@TableName(&quot;tb_item&quot;)public class Item &#123; /** * 商品id */ @TableId(type = IdType.AUTO) @Id private Long id; /** * 商品名称 */ private String name; /** * 商品标题 */ private String title; /** * 价格（分） */ private Long price; /** * 商品图片 */ private String image; /** * 分类名称 */ private String category; /** * 品牌名称 */ private String brand; /** * 规格 */ private String spec; /** * 商品状态 1-正常，2-下架 */ private Integer status; /** * 创建时间 */ private Date createTime; /** * 更新时间 */ private Date updateTime; @Transient @TableField(exist = false) private Integer stock; @Transient @TableField(exist = false) private Integer sold;&#125; @Componentpublic class RedisHandler implements InitializingBean &#123; @Autowired private StringRedisTemplate template; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; private static final ObjectMapper MAPPER = new ObjectMapper(); @Override public void afterPropertiesSet() throws Exception &#123; // 初始化缓存 // 1.查询商品信息 List&lt;Item&gt; itemList = itemService.list(); // 2.存入缓存 for (Item item : itemList) &#123; // 将item序列化成json String json = MAPPER.writeValueAsString(item); // 存入缓存 template.opsForValue().set(&quot;item:id:&quot;+item.getId(),json); &#125; // 3.查询库存信息 List&lt;ItemStock&gt; stockList = stockService.list(); // 2.存入缓存 for (ItemStock stock : stockList) &#123; // 将item序列化成json String json = MAPPER.writeValueAsString(stock); // 存入缓存 template.opsForValue().set(&quot;item:stock:id:&quot;+stock.getId(),json); &#125; &#125; /** * 保存项目 * * @param item 项目 */ public void saveItem(Item item)&#123; // 将item序列化成json String json = null; try &#123; json = MAPPER.writeValueAsString(item); &#125; catch (JsonProcessingException e) &#123; throw new RuntimeException(e); &#125; template.opsForValue().set(&quot;item:id:&quot;+item.getId(),json); &#125; /** * 按 ID 删除项目 * * @param id */ public void removeItemById(Long id)&#123; template.delete(&quot;item:id:&quot;+id); &#125;&#125; import com.github.benmanes.caffeine.cache.Cache;import com.heima.item.config.RedisHandler;import com.heima.item.pojo.Item;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import top.javatool.canal.client.annotation.CanalTable;import top.javatool.canal.client.handler.EntryHandler;@Slf4j@Component@CanalTable(&quot;tb_item&quot;)public class ItemHandler implements EntryHandler&lt;Item&gt; &#123; @Autowired private RedisHandler redisHandler; @Autowired private Cache&lt;Long,Item&gt; itemCache; @Override public void insert(Item item) &#123; // 新增数据到JVM进程缓存 log.info(&quot;新增数据到JVM进程缓存&quot;); itemCache.put(item.getId(),item); // 新增数据到redis log.info(&quot;新增数据到redis&quot;); redisHandler.saveItem(item); &#125; @Override public void update(Item before, Item after) &#123; // 更新JVM进程缓存 log.info(&quot;更新JVM进程缓存&quot;); itemCache.put(after.getId(),after); // 更新redis数据 log.info(&quot;更新redis数据&quot;); redisHandler.saveItem(after); &#125; @Override public void delete(Item item) &#123; // 删除JVM进程缓存 log.info(&quot;删除JVM进程缓存&quot;); itemCache.invalidate(item.getId()); // 删除redis数据 log.info(&quot;删除redis数据&quot;); redisHandler.removeItemById(item.getId()); &#125;&#125; 访问http://localhost:8081/进行后台管理，修改数据后，访问http://localhost:8081/item/10001和redis发现数据已经修改","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"Dubbo.html","slug":"编程语言/Java/学习/框架/Dubbo/Dubbo","date":"2024-06-01T14:12:24.000Z","updated":"2024-06-01T14:12:24.923Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/dubbo/dubbo.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/dubbo/dubbo.html","excerpt":"","text":"Dubbo 本次使用JDK17、Dubbo3 JDK8与Dubbo3.1.x以前的版本匹配，在使用Zookeeper注册作为注册中心时，消费者会出现节点已经存在的异常 JDK17与Dubbo3.1.x之前的版本搭配使用会出现如下问题 JDK9之后的深反射问题，需要通过JVM参数配置解决-Dio.netty.tryReflectionSetAccessible-true--add-opensjava.base/jdk.internal.misc=ALL - UNNAMED--add-opensjava.base/java.nio=ALL-UNNAMED--add-opensjava.base/java.lang=ALL-UNNAMED Dubbo3.2.0.beat4以前的版本使用的是Spring5.2.x不能支持JDK17会产生如下异常Unsupported class file major version 61 [major 61对应17 ]版本需要升级到Dubbo3.2.0.beat5以上版本","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"Redis","slug":"编程语言/Java/学习/框架/Redis/Redis","date":"2024-04-24T13:30:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/redis/redis.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/redis/redis.html","excerpt":"","text":"Redis单点Redis的问题 数据丢失问题Redis是内存存储，服务重启可能会丢失数据 并发能力问题单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 故障恢复问题如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段 存储能力问题Redis基于内存，单节点能存储的数据量难以满足海量数据需求 解决方案 数据丢失问题实现Redis数据持久化 并发能力问题搭建主从集群，实现读写分离(提高并发能力，实现高可用，进一步避免宕机导致的数据丢失) 故障恢复问题利用Redis哨兵，实现健康检测和自动恢复 存储能力问题搭建分片集群，利用插槽机制实现动态扩容 Redis持久化RDB RDB全称Redis Database Backup file ( Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件,恢复数据。 快照文件称为RDB文件，默认是保存在当前运行目录。 redis-cli# 由Redis主进程来执行RDB，会阻塞其他命令# 而将数据备份到磁盘中的速度又很慢，不推介这种方法save# 子进程在后台异步执行RDB，避免主进程受到影响bgsave Redis停机时，会自动进行一次RDB备份 C:\\Users\\Administrator&gt;redis-cli# 测试redis连接127.0.0.1:6379&gt; pingPONG# 存数据127.0.0.1:6379&gt; set num 123OK# 取数据127.0.0.1:6379&gt; get num&quot;123&quot;127.0.0.1:6379&gt; 停止Redis，日志打印如下 D:\\Redis&gt;redis-server.exe redis.windows.conf _._ _.-``__ &#x27;&#x27;-._ _.-`` `. `_. &#x27;&#x27;-._ Redis 3.0.504 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &#x27;&#x27;-._ ( &#x27; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;| Port: 6379 | `-._ `._ / _.-&#x27; | PID: 3204 `-._ `-._ `-./ _.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | http://redis.io `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; |`-._`-._ `-.__.-&#x27; _.-&#x27;_.-&#x27;| | `-._`-._ _.-&#x27;_.-&#x27; | `-._ `-._`-.__.-&#x27;_.-&#x27; _.-&#x27; `-._ `-.__.-&#x27; _.-&#x27; `-._ _.-&#x27; `-.__.-&#x27;[3204] 15 Apr 21:11:30.427 # Server started, Redis version 3.0.504[3204] 15 Apr 21:11:30.443 * DB loaded from disk: 0.000 seconds[3204] 15 Apr 21:11:30.443 * The server is now ready to accept connections on port 6379[3204] 15 Apr 21:12:39.581 # User requested shutdown...[3204] 15 Apr 21:12:39.581 * Saving the final RDB snapshot before exiting.[3204] 15 Apr 21:12:39.581 * DB saved on disk[3204] 15 Apr 21:12:39.581 # Redis is now ready to exit, bye bye... 这里有一句Saving the final RDB snapshot before exiting. Redis将文件保存在运行目录中 我这是windows系统，如果是linux则使用ls、ll但是我们担心如果突然宕机还没来得及持久化怎么办，我们更加希望隔一段时间持久化一次 Redis内部有触发RDB的机制，可以在redis.conf文件中找到， 格式如下: # 900秒内，如果至少一个key被修改，则执行bgsave# 如果是save &quot;&quot; 则表示禁用Redissave 900 1save 300 10save 60 10000 RDB的其他配置也可以在配置文件中设置 # 是否压缩，建议不开启，压缩也会消耗CPU，磁盘不值钱rdbcompression yes# RDB文件名称dbfilename dump.rdb# 文件保存的路径dir ./ bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。fork采用的是copy-on-write技术:当主进程执行读操作时,访问共享内存;当主进程执行写操作时，则会拷贝一份数据，执行写操作。 总结RDB方式bgsave的基本流程? fork主进程得到一-个子进程，共享内存空间 子进程读取内存数据并写入新的RDB文件 用新RDB文件替换旧的RDB文件。RDB会在什么时候执行? save 60 1000代表什么含义? 默认是服务停止时。 代表60秒内至少执行1000次修改则触发RDBRDB的缺点? RDB执行间隔时间长，两次RDB之间写入数据有丟失的风险 fork子进程、压缩、写出RDB文件都比较耗时 AOF AOF全称为Append Only File ( 追加文件)。Redis处理的每-一个写命令都会记录在AOF文件，可以看做是命令日志文件。 如果需要恢复数据，将日志文件里的命令全部执行一遍即可AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF: # 是否开启A0F功能，默认是no appendonly no# AOF文件的名称appendfilename &quot;appendonly.aof&quot; AOF的命令记录的频率也可以通过redis.conf文件来配: # 表示每执行一次写命令，立即记录到AOF文件appendfsync always# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案appendfsync everysec# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘appendfsync no 由于AOF记录的是命令操作，而不是直接记录值，所以会比RDB文件大很多因为是记录命令, AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一-次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置: # AOF文件比上次文件增长超过多少百分比则触发重写auto-aof-rewrite-percentage 100# AOF文件体积最小多大以上才触发重写auto-aof-rewrite-min-size 64mb RDB和AOF各有自己的优缺点，如果对数据安全性要求较高,在实际开发中往往会结合两者来使用。 Redis主从 单节点Redis的并发能力是有上限的，要近一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。开启RDB，关闭AOF 一主二从 A（B、C） 一个master两个slave&#x2F;replica # 禁用RDB# save &quot;&quot;save 900 1save 300 10save 60 10000appendonly no windowswindows配置redis集群查看该博客 主节点从节点从节点只能读数据，不能写数据关闭主节点后，从节点的状态重启主节点后，从节点的状态 linux 接下来演示docker配置redis集群，参考博客链接可以看到本地已经拉取了redis镜像在/root目录下新建一个redis.conf文件和data目录data用以存储redis持久化文件，redis.conf作为redis的配置文件，这里配置主从集群，所以需要新建三个conf和data，目录及文件如下redis-7001.conf下载链接 启动容器，这里使用7001作为端口号 docker run --name redis-master \\-v /root/redis/redis-7001.conf:/etc/redis/redis.conf \\-v /root/redis/data:/data \\-dp 7001:6379 \\redis:latest \\redis-server /etc/redis/redis.conf 配置文件直接复制7001即可，反正将来也是以容器为单位启动，不会造成端口冲突，但是虚拟机(宿主机)的端口映射则不能都写7001了 7001端口已经被master占据了，剩下两个slave使用7002、7003 修改对应的持久化目录redis-7001.conf文件中添加如下配置 slave-announce-ip 192.168.56.10slave-announce-port 7001 redis-7002.conf、redis-7003.conf也是一样 slave-announce-ip 192.168.56.10slave-announce-port 7002 slave-announce-ip 192.168.56.10slave-announce-port 7003 启动slave 在启动 slave 的命令中需要指出其 slaveof 于谁，这种是临时方案，重启失效 永久方案是在conf文件中配置slaveof &lt;master_ip&gt; &lt;master_port&gt; redis5.0之后新增replicaof效果和slaveof 一样 docker run --name redis-slave1 \\-v /root/redis/redis-7002.conf:/etc/redis/redis.conf \\-v /root/redis/data:/data \\-dp 7002:6379 \\redis:latest \\redis-server /etc/redis/redis.conf --slaveof 192.168.56.10 7001 docker run --name redis-slave2 \\-v /root/redis/redis-7003.conf:/etc/redis/redis.conf \\-v /root/redis/data:/data \\-dp 7003:6379 \\redis:latest \\redis-server /etc/redis/redis.conf --slaveof 192.168.56.10 7001 关系查看 docker exec -it redis-master redis-cli info replication docker exec -it redis-slave1 redis-cli info replication docker exec -it redis-slave2 redis-cli info replication slave1slave2此时停止master docker stop redis-master 尝试向slave中写入数据 docker exec -it redis-slave1 /bin/bashredis-cliset name tigerhhzz11 向master中写入数据，在slave中读出 数据同步原理步骤主从第一次同步是全量同步 master怎么知道slave是否是第一次请求数据呢？这里会用到两个很重要的概念: Replication id:简称replid, 是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid,slave则会继承master节点的replid offset:偏移量,随着记录在repl_baklog 中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset,说明slave数据落后于master,需要更新。 因此slave做数据同步,必须向master声明自己的replication id和offset, master才可以判断到底需要同步哪些数据 master需要根据replid判断slave节点是否是第一次来做数据同步，replid不一致就是第一次做数据同步查看容器日志可以查看容器日志，数据同步步骤请看总结 docker logs redis-master docker logs redis-slave1 docker logs redis-slave2 总结 slave节点请求增量同步 master节点判断replid,发现不一致, 拒绝增量同步 master将完整内存数据生成RDB，发送RDB到slave slave清空本地数据，加载master的RDB master将RDB期间的命令记录在repl_baklog,并持续将log中的命令发送给slave slave执行接收到的命令，保持与master之间的同步 增量同步主从第一次同步是全量同步,但如果slave重启后同步，则执行增量同步 repl_baklog本质是一个环形数组，slave与master数据之间的差异&#x3D;master-slave（图中红色线段的部分） 当数据记完一圈后，会覆盖掉上次的内容继续往下记载，slave也会继续跟着master往后同步数据 但是这样就存在无法进行增量同步的情况 repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致数据被覆盖,则无法实现增量同步，只能再次全量同步。 如果master已经覆盖掉上一次的内容，开始记入第二圈的数据，而slave由于某种原因宕机，导致master覆盖的数据并没有同步完成此时就只能做全量同步了，无法进行增量同步 应当尽可能的减少全量同步，因为它的性能较差。或许可以进一步优化全量同步的性能 可以从以下几个方面来优化Redis主从就集群: 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。 (避免磁盘读写，采用网络传输，适用于磁盘较慢、网络较快的情况) Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复,尽可能避免全量同步 限制一个master上的slave节点数量，如果实在是太多slave,则可以采用主-从-从链式结构，减少master压力 总结简述全量同步和增量同步区别? 全量同步: master将完整 内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_ baklog, 逐个发送给slave。 增量同步: slave提交自己的offset到master, master获取repl_ baklog中 从offset之后的命令给slave什么时候执行全量同步? slave节点第一次连接master节点时 slave节点断开时间太久，repl_baklog中的offset已经被覆盖时什么时候执行增量同步?slave节点断开又恢复,并且在repl_baklog中 能找到offset时 Redis哨兵哨兵的作用和工作原理 slave节点宕机恢复后可以找master节点同步数据，如果master节点宕机怎么办? master节点如果宕机，那么此时用户无法进行redis数据写入的操作，可用性下降了 我们需要去监控集群中的节点状态，在master节点挂掉之后，选一个新的master，增进挂掉的master重启后，作为slaveRedis提供了哨兵(Sentinel) 机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下:监控: Sentinel 会不断检查您的master和slave是否按预期工作自动故障恢复:如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主通知: Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端 服务状态监控Sentinel基于心跳机制监测服务状态,每隔1秒向集群的每个实例发送ping命令: 主观下线:如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。 客观下线:若超过指定数量( quorum)的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。 选举新的master一旦发现master故障，sentinel需 要在salve中选择- -一个作为新的master,选择依据是这样的: 首先会判断slave节点与master节点断开时间长短，如果超过指定值( down-after-milliseconds * 10)则会排除该slave节点 然后判断slave节点的slave-priority值, 越小优先级越高，如果是0则永不参与选举 如果slave-prority一样，则判断slave节点的effset值， 越大说明数据越新，优先级越高 最后是判断slave节点的运行id大小，越小优先级越高。 实现故障转移当选中了其中一个slave为新的master后(例如slave1)，故障的转移的步骤如下: sentinel给 备选的slave1节点发送slaveof no one命令,让该节点成为master sentinel给所有其它slave发送slaveof 192.168.150.101 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据。 最后，sentinel将故障节点标记为slave,当故障节点恢复后会自动成为新的master的slave节点 总结Sentinel的三个作用是什么? 监控 故障转移 通知Sentinel如何判断一个redis实例是否健康? 每隔1秒发送一次ping命令，如果超过一定时间没有 相向则认为是主观下线 如果大多数sentinel都认为实例主观下线，则判定服务下线故障转移步骤有哪些? 首先选定一个slave作为新的master,执行slaveof no one 然后让所有节点都执行slaveof 新master 修改故障节点配置，添加slaveof 新master 搭建哨兵集群 手动创建sentinel下的s1、s2、s3，然后配置sentinel.conf文件 port 27001sentinel announce-ip 192.168.56.10sentinel monitor redis-master 192.168.56.10 7001 2sentinel down-after-milliseconds redis-master 5000sentinel failover-timeout redis-master 60000 解读： port 27001：是当前sentinel实例的端口 sentinel monitor redis-master192.168.56.10 7001 2：指定主节点信息 redis-master：主节点名称，自定义，任意写 192.168.56.10 7001：主节点的ip和端口 2：选举master时的quorum值 启动sentinel的jar包启动三个sentinel容器 docker run --name sentinel-1 \\-v /root/redis/sentinel/sentinel1.conf:/etc/redis/sentinel.conf \\-dp 27001:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-2 \\-v /root/redis/sentinel/sentinel2.conf:/etc/redis/sentinel.conf \\-dp 27002:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-3 \\-v /root/redis/sentinel/sentinel3.conf:/etc/redis/sentinel.conf \\-dp 27003:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf 关系查看 docker exec -it sentinel-1 redis-cli -h 192.168.56.10 -p 27001 info sentinel 注意目录对应关系，如果在运行容器时，将conf路径写错了，则可能出现如下情况此时停止redis-master节点，查看sentinel日志 docker stop redis-master docker logs sentinel-1 解决办法，直接挂载整个目录，而不是只挂载某个conf文件，注意权限设置为777，目录和文件都要设置 chmod 777 -R &lt;file&gt; docker run --name sentinel-1 \\-v /root/redis/sentinel/s1:/etc/redis \\-dp 27001:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-2 \\-v /root/redis/sentinel/s2:/etc/redis \\-dp 27002:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-3 \\-v /root/redis/sentinel/s3:/etc/redis \\-dp 27003:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf 但是日志打印还有一个警告1:X 21 Apr 2024 23:33:24.072 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.解决办法 vim /etc/sysctl.conf 文件新增如下内容 net.core.somaxconn = 1024vm.overcommit_memory = 1 添加完成后，刷新内核参数，立即生效 /sbin/sysctl -p 但是我这里并没有生效，所以采用如下方法 docker run --name sentinel-1 --sysctl net.core.somaxconn=1024 \\-v /root/redis/sentinel/s1:/etc/redis \\-dp 27001:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-2 --sysctl net.core.somaxconn=1024 \\-v /root/redis/sentinel/s2:/etc/redis \\-dp 27002:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf docker run --name sentinel-3 --sysctl net.core.somaxconn=1024 \\-v /root/redis/sentinel/s3:/etc/redis \\-dp 27003:26379 \\redis:latest \\redis-sentinel /etc/redis/sentinel.conf 问题已经解决停掉redis-master 查看sentinel日志 docker logs sentinel-3 查看redis节点状态，发现7003确实成为master了 docker exec -it redis-slave2 redis-cli info replication 重启7001，发现原来的master变成slave了 RedisTemplate的哨兵模式 新建项目，导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; server: port: 8080logging: level: io.lettuce.core: debug pattern: dateformat: yyyy-MM-dd HH:mm:ss:SSSspring: data: redis: sentinel: # 指定master 节点名称 master: mymaster # 指定redis-sentinel集群信息 nodes: - 192.168.56.10:27001 - 192.168.56.10:27002 - 192.168.56.10:27003 @RestControllerpublic class TestController &#123; private StringRedisTemplate redisTemplate; @Autowired public TestController(StringRedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; @GetMapping(&quot;/get/&#123;key&#125;&quot;) public String get(@PathVariable String key) &#123; return redisTemplate.opsForValue().get(key); &#125; @GetMapping(&quot;/set/&#123;key&#125;/&#123;value&#125;&quot;) public String set(@PathVariable String key,@PathVariable String value) &#123; redisTemplate.opsForValue().set(key,value); return &quot;success&quot;; &#125;&#125; 配置Redis读写分离 @SpringBootApplicationpublic class RedisDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RedisDemoApplication.class, args); &#125; /** * 配置Redis的读写策略，实现master写入、slave读取(读写分离 * MASTER:从主节点读取 * MASTER_PREFERRED: 优先从master节点读取，master不可用才读取replica * REPLICA:从slave (replica) 节点读取 * REPLICA_PREFERRED: 优先从slave (replica) 节点读取，所有的slave都不可用才读取master) * * @return &#123;@link LettuceClientConfigurationBuilderCustomizer&#125; */ @Bean public LettuceClientConfigurationBuilderCustomizer configurationBuilderCustomizer()&#123; return clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED); &#125;&#125; 报错io.lettuce.core.RedisCommandExecutionException: ERR No such master with that name 名称改为redis-master，与sentinel.conf文件中的配置保持一致 server: port: 8080logging: level: io.lettuce.core: debug pattern: dateformat: yyyy-MM-dd HH:mm:ss:SSSspring: data: redis: sentinel: # 指定master 节点名称 master: redis-master # 指定redis-sentinel集群信息 nodes: - 192.168.56.10:27001 - 192.168.56.10:27002 - 192.168.56.10:27003 访问http://localhost:8080/get/name(得有一个叫name的数据)可以看到这里通过7002来获取数据访问http://localhost:8080/set/name/333可以看到这里通过7003来设置数据重启redis-slave2 docker restart redis-slave2 此时slave1(7002)被选为master7003为replica使用idea连接虚拟机 Deployment-&gt;Configuration新建SFTP查看虚拟机文件 Deployment-&gt;Browse Remote Host右侧就可以看到虚拟机的文件信息了打开命令窗口 点击Tools-&gt;Start SSH Session Redis分片集群 我们知道单节点的Redis内存不要设置过高，在内存的持久化或者数据同步的时候会导致大量的IO，性能会下降 但是如果内存降低之后无法存储海量的数据怎么办？ 解决了高并发读，高并发写怎么解决？ 分片集群结构主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决: 海量数据存储问题 高并发写的问题使用分片集群可以解决.上述问题，分片集群特征: 集群中有多个master,每个master保存不同数据 每个master都可以有多个slave节点 master之间通过ping监测彼此健康状态 客户端请求可以访问集群任意节点，最终都会被转发到正确节点 此时不再需要哨兵机制了，master节点之间可以互相监控各自的状态 集群结构如下表所示 序号 角色 容器名称 网络模式 地址及端口 1 master master-cluster-1 host 192.168.56.10:8001 2 master master-cluster-2 host 192.168.56.10:8002 3 master master-cluster-3 host 192.168.56.10:8003 4 slave slave-cluster-1 host 192.168.56.10:9001 5 slave slave-cluster-2 host 192.168.56.10:9002 6 slave slave-cluster-3 host 192.168.56.10:9003 在/root/redis-cluster下新建配置文件redis.conf 并打开以下两处的注释 # 开启 cluster 功能，即分布式系统功能cluster-enabled yes# 指定其需要的配置文件名称cluster-config-file nodes-6379.conf 重命名redis.conf为redis1.conf，并复制成其他五份redis2.conf、redis3.conf、redis4.conf、redis5.conf、redis6.conf 这6份配置文件内容完全相同 更改文件之后记得上传停止之前运行的redis、sentinel容器 docker stop redis-master redis-slave1 redis-slave2 sentinel-1 sentinel-2 sentinel-3 docker run --name master-cluster-1 \\--network host \\-v /root/redis-cluster/redis1.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/8001:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 8001 docker run --name master-cluster-2 \\--network host \\-v /root/redis-cluster/redis2.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/8002:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 8002 docker run --name master-cluster-3 \\--network host \\-v /root/redis-cluster/redis3.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/8003:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 8003 docker run --name slave-cluster-1 \\--network host \\-v /root/redis-cluster/redis4.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/9001:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 9001 docker run --name slave-cluster-2 \\--network host \\-v /root/redis-cluster/redis5.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/9002:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 9002 docker run --name slave-cluster-3 \\--network host \\-v /root/redis-cluster/redis6.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/9003:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 9003 6 个节点启动后，它们仍是 6 个独立的 Redis，通过 redis-cli --cluster create 命令可将 6个节点创建为一个分布式系统。–cluster replicas 1 指定每个 master 会带有一个slave 副本。 所以前三个是主，后三个是从 docker exec -it master-cluster-1 /bin/bashredis-cli --cluster create --cluster-replicas 1 192.168.56.10:8001 192.168.56.10:8002 192.168.56.10:8003 192.168.56.10:9001 192.168.56.10:9002 192.168.56.10:9003 查看节点信息 redis-cli -c -p 8003 cluster nodes 这样就可以查看到节点的信息了 散列插槽Redis会把每一个master节 点映射到0~16383共16384个插槽(hashslot) 上，查看集群信息时就能看到: 我们这里插槽分布如下 端口 插槽范围 8001 0-5460 8002 5461-10922 8003 10923-16383 数据key不是与节点绑定,而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况: key中包含”{}”,且”{}”中至少包含1个字符， “{}”中的部分是有效部分 key中不包含”{}” ，整个key都是有效部分例如: key是num,那么就根据num计算,如果是{itcast}num,则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余,得到的结果就是slot值。 连接redis 注意这里一定要加-c，代表集群模式 redis-cli -c -p 8001 redis会先算出插槽的值，最后找到对应的ip及端口，存储(获取)对应redis实例里的数据Redis如何判断某个key应该在哪个实例? 将16384个插槽分配到不同的实例 根据key的有 效部分计算哈希值，对16384取余余数作为插槽，寻找插槽所在实例即可如何将同一类数据固定的保存在同一个Redis实例?这一类数据使用相同的有效部分，例如key都以{typeld}为前缀，这样{a}name、{a}gender就能都存储在8003端口上 集群伸缩redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看: docker exec -it master-cluster-1 /bin/bashredis-cli --cluster help 向集群中添加一个新的master节点,并向其中存储num &#x3D; 10需求启动一个新的redis实例，端口为8004添加8004到之前的集群，并作为一个master节点给8004节点分配插槽，使得num这个key可以存储到8004实例分析，这里有几个关键点 新增redis(master)实例到集群 分配插槽，使其能够存储num作为key(hashkey为2765) 参考博客复制一份redis7.conf文件 docker run --name master-cluster-4 \\--network host \\-v /root/redis-cluster/redis7.conf:/etc/redis/redis.conf \\-v /root/redis-cluster/data/8004:/data \\-d redis:latest redis-server /etc/redis/redis.conf \\--port 8004 可以看到集群节点里并没有新建的8004 docker exec -it master-cluster-1 /bin/bashredis-cli -c -p 8003 cluster nodes 查看帮助文档 redis-cli --cluster help 添加节点到集群 redis-cli --cluster add-node 192.168.56.10:8004 192.168.56.10:8003 再次查看集群信息，可以看到8004是作为master的，但是并没有给它分配插槽 redis-cli -c -p 8003 cluster nodes 接下来需要为8004分配至少0~2765的插槽，这里就直接分配前3000个了输入yes 再次查看节点信息，可以看到已经分配了0-2999的插槽 redis-cli -p 8004 cluster nodes 试一下获取num，可以看到是从8004上获取的数据 redis-cli -c -p 8001 练习 删除8004节点转移插槽删除节点，可以看到8004节点已经被移除 redis-cli --cluster del-node 192.168.56.10:8004 969b40741ba2c93557ff9013a774f98322f77ba0 删除容器 docker rm -f master-cluster-4docker ps 故障转移自动故障转移 当集群中有一个master宕机会发生什么呢?重新启动8002可以看到8002变成了master，而9002变成了slaver，实现了自动故障转移 手动故障转移利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下:手动的Failover支持三种不同模式: 缺省:默认的流程，如图1~6步 force:省略了对offset的一致性校验 takeover:直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见 练习 手动故障转移，让8002重新变成master CLUSTER FAILOVER 看到8002重新变成master RedisTemplateRedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致: 引入redis的starter依赖 配置分片集群地址 配置读写分离与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下:# 配置分片集群spring: data: redis: cluster: # 指定分片集群的每一个节点信息 nodes: - 192.168.56.10:8001 - 192.168.56.10:8002 - 192.168.56.10:8003 - 192.168.56.10:9001 - 192.168.56.10:9002 - 192.168.56.10:9003 访问http://localhost:8080/get/a 查看日志，通过9003获取到a查看节点信息 9003的master是8003 redis-cli -c -p 8003 cluster nodes 访问http://localhost:8080/set/a/666 通过8003去set值","categories":[{"name":"Redis","slug":"Redis","permalink":"https://isunderachiever.github.io/categories/Redis/"}],"tags":[]},{"title":"Docker","slug":"编程语言/Java/学习/框架/Docker/Docker","date":"2024-04-21T04:12:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/docker/docker.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/docker/docker.html","excerpt":"","text":"Docker概念镜像:相当于容器的模板容器:可以理解成轻量级的虚拟机镜像仓库:存放镜像的仓库，官方的镜像仓库 https://hub.docker.com/以下内容可能会使用到某些文件下载链接 可以使用镜像来不断创建容器，而镜像仓库则是存放镜像的地方 命令 官网文档 # 查看帮助文档docker --help# 查看某一个命令的用法，如 pulldocker pull --help# 下列命令中，[]括起来的可写可不写# 下载镜像 标签如版本等，如果不指定标签，则默认是latest，如果不指定仓库，则默认是官方仓库docker pull [镜像仓库/]镜像名[:标签]# 查看镜像docker images [选项]# 衍生# 使用帮助手册查看参数 docker images --help# 查看镜像iddocker images -q# 查看所有镜像docker images -a# 查看所有镜像id# docker images -aq/docker images -a -q# 列出镜像名为mysql的镜像# 例子 docker images --filter=reference=&#x27;busy*:*libc&#x27;# REPOSITORY TAG IMAGE ID CREATED SIZE# busybox uclibc e02e811dd08f 5 weeks ago 1.09 MB# busybox glibc 21c16b6787c6 5 weeks ago 4.19 MBdocker images --filter=reference=&#x27;mysql&#x27;# 列出容器信息# 默认显示正在运行的信息docker ps [选项]# 显示全部容器docke ps -a# 列出所有退出状态的容器 docker ps -f status=exited# 列出所有退出状态的容器iddocker ps -qf status=exited 容器容器继续运行的条件 正常情况下docker容器运行必须有一个前台进程，如果没有前台进程执行，容器认为空闲，就会自动退出 # 创建并运行容器docker run [OPTIONS] IMAGES [COMMAND] [ARG...]# options 选项，重点关注-d,-p,-v,-e,--restart# images 镜像信息，推介使用 镜像名:tag 的写法# command 创建容器后要执行的命令# ars command命令的参数# 如docker run nginx:latest# 容器运行后执行 ls命令docker run nginx:latest lsdocker run nginx:latest ls -adocker run -d nginx:latest ls -a 容器的运行方式 后台运行 docker run nginx:latest 默认运行 docker run -d nginx:latest 交互式运行 docker run -it nginx:latest -i 以交互模式运行容器，通常与-t一起使用 -t 启动容器后，为容器分配一个命令行，通常与-i一起使用 主要在学习阶段和调试的时候会使用到，并且一般容器的执行命令会使用bash,这样才能在进入容器后去执行命令 docker run -it nginx:latest bash如果这样执行，则会覆盖nginx镜像默认的执行命令，此时并不会运行nginx，而是进入容器内部执行bash脚本 退出交互式exit 删除容器docker rm [选项] [容器ID或容器名...]# 例如 删除id为&quot;d34295b85f69&quot;的容器docker rm d34295b85f69# 删除id为&quot;d34295b85f69&quot;和&quot;c0c9bf25c6a7&quot;的容器# 容器id使用空格隔开docker rm d34295b85f69 c0c9bf25c6a7# 运行中的容器无法直接删除，解决办法# 1.停止运行容器，然后删除# 2.强制删除docker rm -f c0c9bf25c6a7# $()命令替换ls $(pwd)# pwd 会显示当前目录# ls $(pwd) 会打印当前目录下的内容# 删除所有容器docker rm $(docker ps -aq)# 强制删除所有容器docker rm -f $(docker ps -aq)# 删除所有非运行状态的容器docker rm $(docker ps -f status=exited -q) 进入容器执行命令docker exec [选项] 容器ID或容器名 命令[参数...]# 如 docker exec 容器id lsdocker exec 295731ae1fdf pwd# 但是一次只能携带一个命令，是否可以使用交互式的方式docke exec -it 295731ae1fdf bash# 使用curl的方式来查看nginx容器是否运行curl http://127.0.0.1 查看容器日志docker logs [选项] 容器ID或容器名docker logs 295731ae1fdf# 持续输出容器中的日志# 执行完并不会返回，而是会等待是否有新的日志docker logs -f 295731ae1fdf# 查看最近的20条日志docker logs -n 20 295731ae1fdf 容器文件拷贝 使用docker cp命令来实现容器与宿主机之间文件和目录的相互拷贝 # 把容器的文件拷贝到宿主机中docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH# docker cp 295731ae1fdf:/usr/share/nginx/html/index.html /home/index.html# 把宿主机的文件拷贝到容器中docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH# docker cp /home/cp_test 295731ae1fdf:/home/cp_test 停止容器docker stop [容器ID或容器名...]# docker stop 295731ae1fdf 运行容器docker start [容器ID或容器名...]# docker start 295731ae1fdf run命令详解-p# 将宿主机的端口映射到docker容器端口，通过宿主机的端口访问容器端口# 发布一个端口docker run -p 宿主机端口:容器端口 镜像名#发布多个端口docker run -p 宿主机端口1:容器端口1 -p 宿主机端口2:容器端口2 镜像名# 怎么知道容器需要发布哪些端口呢？# 1.DockerHub的介绍# 2.构建容器的DockerFile(EXPOSE 80)-v# 数据卷 数据卷为什么要使用数据卷？ 需要把容器中的数据持久化保存 需要在宿主机和容器之间完成数据共享 将宿主机目录或文件挂载到容器中，实现宿主机和容器之间的数据共享和持久化 -v -p 对外端口发布，即端口映射 -v 数据卷 -e 设置环境变量 –name 容器命名 –restart 容器退出后的重启策略docker run -v 数据卷别名:容器目录[:读写权限] 镜像名docker run -d -p 80:80 -v nginx_html:/usr/share/nginx/html nginx# 查看数据卷信息docker inspect fcbc47e85323# 其中有一段信息如下&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;nginx_html&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/nginx_html/_data&quot;, &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;z&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125;# Type为volume，表示数据卷，Source即为我们数据卷的路径# 可以cd到/var/lib/docker/volumes/nginx_html/_data里ls看一下，对应的是nginx中/usr/share/nginx/html的内容# 列出数据卷docker volume ls# 查看数据卷详情# 这里nginx_html是别名docker volume inspect nginx_htmldocker volume inspect 06f4db3290e6759861b085989a859257121aac46ad30e35fe26a1904f8ff7aea# 创建数据卷# volume_test为数据卷的名字docker volume create volume_test# 删除数据卷docker volume rm volume_test# 如果需要删除的数据卷正在被使用，是没有办法直接删除的# 强制删除容器然后删除数据卷 # 手动安装jdk 也可以使用docker安装jdk# docker安装jdk在后文# 在/usr/local 目录下安装jdkcd /usr/localwget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gztar -zxvf jdk-17_linux-x64_bin.tar.gz # 将jdk-17改名为javamv jdk-17.0.10 jdk17# 进入profile文件，按i进入编辑模式vim /etc/profile# 在文件最下方添加export JAVA_HOME=/usr/local/jdk17export PATH=$PATH:$JAVA_HOME/bin;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar;# 按下Esc退出编辑模式# 下一步按住shift 再按俩次 z 键，保存配置文件信息# 重新加载环境变量source /etc/profile# cd /java -version 练习将某html挂载到nginx目录下进行显示 第一个80端口是宿主机的端口，第二个80端口是容器nginx的端口 将宿主机的/home/html/index.html挂载到容器的/usr/share/nginx/html/index.html 不过一般不会直接挂载html，一般挂载整个目录，包括html、css、js等 docker run -d -p 80:80 -v /home/html/index.html:/usr/share/nginx/html/index.html nginx 访问http://虚拟机ip:80/ 如果我们将宿主机的/home/html/index.html改变内容，再次访问nginx，是否会发生变化 -e容器中某些变量不能直接写死，需要让使用者在创建容器的时候指定，这种情况镜像中一般是定义环境变量来使用。例如mysql容器的root密码。遇到这种镜像创建的容器我就可以使用-e来设置环境变量的值。用法如下 docker run -e 变量名=变量值 镜像名 练习 后台运行mysql容器 容器中的mysql可以被外部连接 mysql容器的数据需要持久化存储，不能因为容器被删除而丢失 mysql的root用户密码设置为rootdocker run -d -p 3306:3306 -v /home/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql:8.0.20 –name容器命名练习发布一个nginx页面，为容器命名为nginx-test docker run -d -p 81:80 --name nginx-test -v /home/html:/usr/share/nginx/html nginx –restart容器退出后的自动重启策略 docker run --restart 重启策略 镜像名# no 不自动重启# always 总自动重启# on-failure[:max-retries] 仅在非正常退出时，自动重启# unless-stopped 容器会在退出后自动重启，除非手动停止 其他镜像和容器命令# 查看镜像详细内容docker images inspect [OPTIONS] IMAGE [IMAGE...]docker image inspect 7614ae9453d1# 查看容器中的进程docker top CONTAINER[ps CONTAINER]docker top redis# 查看容器详细内容docker inspect 51764b94357b 运行jar包# docker拉取java17docker pull openjdk:17-jdk# 运行jar包java -jar xxx.jar# 根据application.properties来穿参数# 运行时参数，比如运行端口为8080，mysql的密码为rootjava -jar xxx.jar --server.port=8080 --spring.datasource.username=root --spring.datasource.password=rootdocker run -d \\-p 8080:8080 \\-v /usr/blog:/usr/blog \\--restart always \\--name jar_test \\openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar 网络docker inspect mysql # 查看运行的容器docker ps -f name=jar_test# 进入容器内部docker exec -it jar_test bash# ping mysql试试ping 172.17.0.3# 创建网络docker network create 网络名# 列出网络信息docker network ls# 加入网络有两种方式# 1.在创建容器时加入docker run --network 网络名 镜像名# 2.容器创建后加入docker network connect [选项] 网络名 容器名或容器id# 查看网络详情docker network inspect 网络名或网络iddocker run -d \\-p 8080:8080 \\-v /usr/blog:/usr/blog \\--network blog_test jar_test--restart always \\--name jar_test \\openjdk:17-jdk java -jar /usr/blog/demo-0.0.1-SNAPSHOT.jar \\&quot;--spring.datasource.url=jdbc:mysql://mysql:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&amp;useSSL=false&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;allowPublicKeyRetrieval=true&quot;# 在加入同一个网络后，这里spring.datasource.url并没有写ip地址了，而是写的容器名称mysql DockerFile基本语法 不区分大小写，但是最好习惯大写 基本以FROM开头 #开头代表注释练习自定义一个镜像，运行容器后输出helloworld(如:echo helloworld)FROM centos:7CMD [&quot;echo&quot;,&quot;helloworld&quot;] 将文件编译成镜像 使用-t可以指定镜像的名字和标签、-f指定基于哪个dockerfile文件来进行构建镜像、.表示文件在当前路径下 docker build -t hello:1.0 -f HelloWorld .# 测试是否成功docker run hello:1.0 FROM 用来定义基础镜像 作用时机:构建镜像的时候 FROM 镜像名:标签名FROM centos:7 CMD 用来定义容器运行时的默认命令，可以在docker run的时候覆盖掉CMD中定义的命令 CMD [&quot;命令1&quot;,&quot;参数1&quot;,&quot;参数2&quot;]# CMD [&quot;echo&quot;,&quot;helloworld&quot;]# 这种形式可以解析环境变量# CMD echo hello$HOME# 这种也可以解析环境变量# CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;hello $HOME&quot;]# 如果在一个dockerfile中有多个CMD，则只执行最后一个CMDFROM centos:7CMD [&quot;echo&quot;,&quot;helloworld&quot;]CMD echo hello,javaCMD echo hello,vue# 测试一下docker build -t hello:2.0 -f HelloWorld . ENV 用来定义环境变量 ENV 变量名=&quot;变量值&quot; 如ENV DIR=&quot;/root&quot; 作用时机为构建镜像时 ENV DIR=&quot;/root&quot; 需求：要求对打印内容进行改造，需要实现可以打印任意内容，具体内容在运行容器的时候通过环境变量的方式去指定 FROM centos:7ENV NAME=&quot;小花&quot;CMD echo hello,$NAME 编译测试 docker build -t test01:1.0 -f Test01 .docker run test01:1.0# 也可以在运行时指定环境变量docker run -e NAME=小红 test01:1.0 WORKDIR 用于设置当前工作的目录，如果该目录不存在会自动创建。 WORKDIR 目录WORKDIR /root/app 示例1 pwd打印出来是什么？ FROM centos:7WORKDIR /aWORKDIR bWORKDIR cCMD pwd pwd打印/a/b/c示例2 WORKDIR指定目录的父目录不存在会怎么样？ WORKDIR /a/b/c 如果指定目录的父目录不存在，会自动创建示例3WORKDIR指定的目录是否能使用环境变量 FROM centos:7ENV PATH=&quot;/a&quot;WORKDIR $PATHCMD pwd WORKDIR指定的目录可以使用环境变量 RUN 用来在构建过程中要执行的命令 而CMD则是在容器运行时执行命令 RUN echo abc 练习 定义一个CONTENT变量,默认值为hellodocker, 在镜像的&#x2F;app目录下创建一个sg目录，在其中创建一个content.txt文件, 文件的内容为CQNTENT变量的值。容器启动时打印content.txt的内容 # 如果是sh脚本，则可以这么实现export CONTENT=&quot;hellodocker&quot;mkdir -p /app/sgecho &quot;$CONTENT&quot; &gt; /app/sg/content.txtcat /app/sg/content.txt 如何改成DockerFile的写法 FROM centos:7ENV CONTENT=&quot;hellodocker&quot;WORKDIR /app/sgRUN echo &quot;$CONTENT&quot; &gt; /app/sg/content.txtCMD cat /app/sg/content.txt 测试 docker build -t test01:1.0 -f Test01 .docker run test01:1.0# 或者docker run -it test01:1.0 bashlscat content.txt 思考 [root@10 dockerfile_test]# docker run -e CONTENT=java test01:1.0hellodocker 为什么docker run -e CONTENT=java test01:1.0的时候，输出的不是java 因为只有CMD是在docker运行时执行，而其他指令如ENV、RUN等是在构建镜像时执行 所以输出的还是hellodocker ADD 把构建上下文的文件或者网络文件添加到镜像 如果文件是压缩包则自动解压，但是需要根据情况，如果是本地压缩包大概率没问题 但如果是网络上的如oss压缩包可能又不会解压，需要根据实际情况来定 作用时机为构建镜像的时候 ADD 原路径 目标路径ADD xxx.tar.gz .# 随便找一个 html+js+css的网页# 使用如下命令将html目录打成html.tar.gz压缩包tar zcvf html.tar.gz html 练习在构建目录下存放一个gz压缩包， 构建镜像的时候把这个包添加到镜像的&#x2F;app录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口 dockerfile:Test01 FROM nginx:latestWORKDIR /appADD html.tar.gz .RUN tar -xzvf html.tar.gzRUN cp -r html/* /usr/share/nginx/htmlCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] 测试 docker build -t test01:1.0 -f Test01 . 报错如下 [+] Building 0.4s (6/7) docker:default =&gt; [internal] load build definition from Test01 0.0s =&gt; =&gt; transferring dockerfile: 217B 0.0s =&gt; [internal] load metadata for docker.io/library/nginx:latest 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [1/4] FROM docker.io/library/nginx:latest 0.0s =&gt; [2/4] WORKDIR /app 0.0s =&gt; ERROR [3/4] RUN tar -xzvf html.tar.gz 0.3s------ &gt; [3/4] RUN tar -xzvf html.tar.gz: 0.263 tar (child): html.tar.gz: Cannot open: No such file or directory0.263 tar (child): Error is not recoverable: exiting now0.263 tar: Child returned status 20.263 tar: Error is not recoverable: exiting now------Test01:3-------------------- 1 | FROM nginx:latest 2 | WORKDIR /app 3 | &gt;&gt;&gt; RUN tar -xzvf html.tar.gz 4 | RUN cp html/* /usr/share/nginx/html 5 | CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]--------------------ERROR: failed to solve: process &quot;/bin/sh -c tar -xzvf html.tar.gz&quot; did not complete successfully: exit code: 2 可以看到是在解压tar.gz包的时候报错了，好像是没有找到文件那怎么调试呢？现在镜像都没构建，更别说进入到容器内部查看文件是否存在了 将Test01改成如下内容 注释掉报错部分，先创建镜像，然后进入容器内部查看报错原因 FROM nginx:latestWORKDIR /appADD html.tar.gz .#RUN tar -xzvf html.tar.gz#RUN cp -r html/* /usr/share/nginx/htmlCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] 构建成功 docker build -t test01:1.0 -f Test01 .docker run -it test01:1.0 bash# ls发现tar.gz已经被自动解压了# 说明ADD一个压缩包，会自动解压ls 最终将dockerFile改为如下 FROM nginx:latestWORKDIR /appADD html.tar.gz .RUN cp -r html/* /usr/share/nginx/htmlCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] 构建后运行镜像 因为我虚拟机已经运行了一个nginx容器了，所以80端口已经被占用了，这里指定的端口是81 docker run -d -p 81:80 --name=dockerfile_test01 test01:1.0 访问链接，这里docker1是指虚拟机的ip 我这里是因为配了主机的hosts文件 hosts文件路径：C:\\Windows\\System32\\drivers\\etchosts文件 192.168.56.10 docker1 http://docker1:81/ EXPOSE 暴露需要发布的端口，让镜像使用者知道应该发布哪些端口 EXPOSE 端口1 端口2EXPOSE 80 8080 dockerfile FROM nginx:latestWORKDIR /appADD html.tar.gz .RUN cp -r html/* /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] COPY 从构建上下文中复制内容到镜像中 COPY 原路径 目标路径COPY html.tar.gz . COPY的作用和ADD好像非常类似，具体如何抉择？ ADD可以下载网络文件,并且可以自动解压 COPY就是单纯的拷贝练习在构建目录下存放一个html.tar.gz包，构建镜像的时候把这个包复制到镜像的&#x2F;app目录下解压，然后把其中的dist目录的内容存放到存放在nginx的htmI目录下，声明开放80端口FROM nginx:latestWORKDIR /appCOPY html.tar.gz .RUN tar -xzvf html.tar.gzRUN cp -r html/* /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] ENTRYPOINT 用来定义容器运行时的默认命令。docker run的时候无法覆盖ENTRYPOINT里的内容。 运行时机在运行容器的时候 ENTRYPOINT [&quot;命令1&quot;,&quot;参数1&quot;,&quot;参数2&quot;]ENTRYPOINT [&quot;echo&quot;,&quot;helloworld&quot;] 实际使用 实际使用往往是存在部分命令不能更改，也存在部分命令可以被更改 比如java -jar aaa.jar 我们希望java -jar这部分命令是固定的，无法在运行时被修改 而jar包的名称可以在运行时修改 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]CMD [&quot;aaa.jar&quot;] 练习在上个案例要求的基础上，还要求容器的nginx的启动命令不能在运行容器时被覆盖 分析一下这个练习 docker run -d -p 82:80 test01:1.0 bash 执行上述命令后，容器处于退出状态Exited 为啥呢？因为bash将dockerfile最后一行的cmd命令覆盖了CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] FROM nginx:latestWORKDIR /appCOPY html.tar.gz .RUN tar -xzvf html.tar.gzRUN cp -r html/* /usr/share/nginx/htmlEXPOSE 80ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] docker build -t entrypoint_test02:1.0 -f Test01 .docker run -d -p 82:80 entrypoint_test02:1.0 bash 发现容器依然没有运行，查看容器日志 docker run -d -p 82:80 entrypoint_test02:1.0 bash#fa075623cdbf3d01ead7b405c8d61b224e0f70e9fffcdb2a3c5bd91100ecd35ddocker logs fa075623cdbf3d#nginx: invalid option: &quot;bash&quot; 因为此时在nginx容器内执行了bash命令，nginx无法识别 优化部署流程 我们希望后端的镜像当中就包含了后端的jar包，镜像启动的时候默认就是会启动该jar包，前端的镜像中就包含了前端的包 基础版配置nginx反向代理/etc/nginx/conf.d/default.conf server &#123; listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 主要是添加如下代码 ... location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/; &#125;... # 我这里的nginx的镜像名为nginx-testdocker inspect volume nginx-test# &quot;Mounts&quot;: [# &#123;# &quot;Type&quot;: &quot;bind&quot;,# &quot;Source&quot;: &quot;/home/html&quot;,# &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,# &quot;Mode&quot;: &quot;&quot;,# &quot;RW&quot;: true,# &quot;Propagation&quot;: &quot;rprivate&quot;# &#125;# ], 而nginx镜像配置的数据卷在宿主机的路径为/home/html，所以我们将前端文件放在宿主机的/home/html路径下 ll#total 16#drwxr-xr-x. 2 root root 57 Mar 24 13:13 assets#-rw-r--r--. 1 root root 1169 Mar 24 15:07 default.conf#-rw-r--r--. 1 root root 456 Mar 24 13:13 index.html#-rw-r--r--. 1 root root 834 Mar 24 14:06 nginx.conf#-rw-r--r--. 1 root root 1497 Mar 20 23:01 vite.svgpwd#/home/html 到时候前端输入虚拟机ip:80/就会显示/home/html/index.html文件如http://192.168.56.10:80/显示前端页面 运行后端 注意更换自己mysql的账号和密码 docker run -d \\-p 8080:8080 \\-v /usr/blog:/usr/blog \\--restart always \\--name jar_test \\openjdk:17-jdk java -jar /usr/blog/demo.jar --spring.datasource.username=root --spring.datasource.password=123456 这里将jar包放在了/usr/blog下，也可以自己定义路径 MySQL还需要配置mysql,新建一个test数据库 create table user( id int auto_increment comment &#x27;用户编号&#x27; primary key, username varchar(20) null comment &#x27;账号&#x27;, password varchar(20) null comment &#x27;密码&#x27;, nick_name varchar(20) null comment &#x27;昵称&#x27;, avatar varchar(255) null comment &#x27;头像&#x27;) comment &#x27;用户表&#x27;;INSERT INTO test.user (id, username, password, nick_name, avatar) VALUES (1, &#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;默认昵称&#x27;, null); 优化 dockerfile FROM openjdk:17-jdkWORKDIR /appADD demo.jar .EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]CMD [&quot;demo.jar&quot;] cd /usr/dockerfile_testdocker build -t demo_jar:1 -f /usr/dockerfile_test/demo_jar .# network 添加到同一个网络# mysql也需要docker run -d \\-p 8080:8080 \\--network blog_test \\--restart always \\--name jar_demo \\demo_jar:1 前端 demo_ngxin是dockerfile文件 blog-vue下则是前端文件 FROM nginx:latestWORKDIR /appCOPY blog-vue .RUN cp -r dist/* /usr/share/nginx/htmlEXPOSE 80ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] docker build -t blog_vue:1 -f demo_nginx .docker run -d \\-p 80:80 \\--restart always \\-d \\--name blog_vue \\blog_vue:1 访问发现后端接口404，是因为基于nginx镜像FROM nginx:latest，这里反向代理依然需要配置 解决方法：进入blog_vue容器内部重新配置反向代理 docker exec -it blog_vue bash 镜像推送到镜像仓库注册Docker Hub账号官网:https://hub.docker.com/ 登录镜像仓库docker login# 然后输入账号密码即可登录 构建镜像docker build -t username/镜像名:tag .# username是Docker Hub的帐号 给镜像打上标签 以便于与Docker Hub上的仓库关联 # 第一个镜像名是本地的镜像名# 第二个镜像名是Docker Hub仓库中的镜像名docker tag username/镜像名:tag username/镜像名:tag 推送镜像docker push username/镜像名:tag DockerCompose入门 DockerCompose是用来定义和运行一个或多个容器(通常都是多个)运行和应用的工具 当前版本的Docker不需要单独安装 docker compose version# 查看版本 services: test: image: nginx:latest test2: image: nginx:latest # 运行以上定义的所有镜像docker compose up# -d 后台运行docker compose up -d# 会停止并删除yaml中运行的容器docker compose down 元素 command 覆盖容器启动后的默认指令 environment 指定环境变量，相当于run的-e选项 image 用来指定镜像 networks 指定网络, 相当于run的–network ports 用来指定要发布的端口 ，相当于run的-p volumes 用来指定数据卷， 相当于-V restart 用来指定重启策略,相当于–restartservices: # mysql blog_mysql: image: mysql:8.0.20 # 已经存在的数据卷 mysql_data volumes: - mysql_data:/var/lib/mysql ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: 123456 restart: always networks: - blog_net # redis blog_redis: image: redis:latest volumes: - redis_data:/data ports: - 6379:6379 restart: always command: [&#x27;redis-server&#x27;,&#x27;--appendonly&#x27;,&#x27;yes&#x27;] networks: - blog_net # 后端服务 sg_blog: image: sb_blog:01 ports: - 8080:8080 networks: - blog_net restart: always # 前端服务 sg_blog_vue: image: sb_blog_vue:01 ports: - 80:80 restart: alwaysnetworks: blog_net:volumes: mysql_data: # 表示数据卷已经存在，不需要自动创建 external: true redis_data: external: true 设置好docker-compose.yaml后 docker compose up -ddocker compose down","categories":[{"name":"Docker","slug":"Docker","permalink":"https://isunderachiever.github.io/categories/Docker/"}],"tags":[]},{"title":"Seata","slug":"编程语言/Java/学习/框架/Seata/Seata","date":"2024-04-16T00:31:00.000Z","updated":"2024-06-01T14:32:53.515Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/seata/seata.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/seata/seata.html","excerpt":"","text":"Seata概念事务的ACID原则 原子性事务中的所有操作，要么全部成功,要么全部失败 一致性要保证数据库内部完整性约束、声明性约束 隔离性对同一资源操作的事务不能同时发生 持久性对数据库做的一切修改将永久保存,不管是否出现故障 案例微服务下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务: 账户服务负责扣减用户余额 库存服务负责扣减商品库存 我们希望创建订单、扣减余额、扣件商品库存三个操作同时成功或者失败这里新建三个数据库sentinel_account create table account_tbl( id int auto_increment comment &#x27;账户编号&#x27; primary key, user_id varchar(255) null comment &#x27;用户编号&#x27;, money int(11) unsigned default 0 null comment &#x27;余额&#x27;) comment &#x27;账户表&#x27; charset = utf8 row_format = COMPACT; INSERT INTO sentinel_account.account_tbl (id, user_id, money) VALUES (1, &#x27;user202103032042012&#x27;, 1000); sentinel_ordercreate table order_tbl( id int auto_increment comment &#x27;订单编号&#x27; primary key, user_id varchar(255) null comment &#x27;用户编号&#x27;, commodity_code varchar(255) null comment &#x27;商品编码&#x27;, count int default 0 null comment &#x27;数量&#x27;, money int default 0 null comment &#x27;金额&#x27;) comment &#x27;订单表&#x27; charset = utf8 row_format = COMPACT; sentinel_storagecreate table storage_tbl( id int auto_increment comment &#x27;库存编号&#x27; primary key, commodity_code varchar(255) null comment &#x27;商品编码&#x27;, count int(11) unsigned default 0 null comment &#x27;库存数量&#x27;, constraint commodity_code unique (commodity_code)) comment &#x27;库存表&#x27; charset = utf8 row_format = COMPACT; INSERT INTO sentinel_storage.storage_tbl (id, commodity_code, count) VALUES (1, &#x27;100202003032041&#x27;, 10); 基础项目的链接调用client实现扣余额、扣库存使用ApiFox测试订单创建请求看看数据，发现该商品还剩下10个我们直接买20个，正常来讲库存不足应该要失败，这次用户要跟账户表保持一致报错刷新之后发现，库存表数量没变(扣减失败)，但是账户表金额被扣了它们每个服务是独立的，各自提交自己的事务，所以并没有达成事务的一致总结：在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务， 要保证所有分支事务最终状态一致,这样的事务就是分布式事务。 理论知识CAP定理1998年，加州大学的计算机科学家Eric Brewer提出，分布式系统有三个指标: Consistency (一致性) Availability (可用性) Partition tolerance (分区容错性)Eric Brewer说，分布式系统无法同时满足这三个指标。这个结论就叫做CAP定理。 一致性Consistency (一致性) :用户访问分布式系统中的任意节点,得到的数据必须一致 可用性Availability (可用性) :用户访问集群中的任意健康节点,必须能得到响应，而不是超时或拒绝 分区容错Partition (分区) :因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。Tolerance (容错) :在集群出现分区时,整个系统也要持续对外提供服务 总结分布式系统节点通过网络连接，一定会出现分区问题(P)，当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足 思考elasticsearch集群是CP还是AP?ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于CP BASE理论BASE理论是对CAP的一种解决思路,包含三个思想:Basically Available(基本可用) :分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。SoftState (软状态) :在一定时间内，允许出现中间状态，比如临时的不一致状态。Eventually Consistent (最终一致性) :虽然无法保证强-致性,但是在软状态结束后，最终达到数据一致。而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论:AP模式:各子事务分别执行和提交,允许出现结果不一致,然后采用弥补措施恢复数据即可，实现最终一致。CP模式:各个子事务执行后互相等待，同时提交,同时回滚,达成强一致。但事务等待过程中,处于弱可用状态。因为会锁定资源导致无法访问 分布式事务模型解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者(子系统事务)。 这里的子系统事务，称为分支事务;有关联的各个分支事务在一起称为全局事务 初识SeataSeata架构Seata事务管理中有三个重要的角色: TC (Transaction Coordinator) -事务协调者:维护全局和分支事务的状态，协调全局事务提交或回滚。 TM (Transaction Manager) -事务管理器:定义全局事务的范围、开始全局事务、提交或回滚全局事务。 RM (Resource Manager) -资源管理器:管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。Seata提供了四种不同的分布式事务解决方案: XA模式:强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 TCC模式:最终一致的分阶段事务模式，有业务侵入 AT模式:最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式 SAGA模式:长事务模式，有业务侵入 安装Seata下载前往Github下载，这里选择seata-server-1.7.0的版本 配置nacos为注册中心和配置中心 application.example.yml的配置很全，我们copy需要的配置到application.yml即可修改后的配置 # Copyright 1999-2019 Seata.io Group.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.server: port: 7091spring: application: name: seata-serverlogging: config: classpath:logback-spring.xml file: path: $&#123;user.home&#125;/logs/seata extend: logstash-appender: destination: 127.0.0.1:4560 kafka-appender: bootstrap-servers: 127.0.0.1:9092 topic: logback_to_logstashconsole: user: username: seata password: seataseata: config: # support: nacos 、 consul 、 apollo 、 zk 、 etcd3 type: nacos nacos: server-addr: 127.0.0.1:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c # group: SEATA_GROUP group: DEFAULT_GROUP username: nacos password: nacos context-path: ##if use MSE Nacos with auth, mutex with username/password attribute #access-key: #secret-key: data-id: seataServer.properties registry: # support: nacos 、 eureka 、 redis 、 zk 、 consul 、 etcd3 、 sofa type: nacos preferred-networks: 30.240.* nacos: application: seata-server server-addr: 127.0.0.1:8848 # group: SEATA_GROUP group: DEFAULT_GROUP namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c cluster: default username: nacos password: nacos context-path: ##if use MSE Nacos with auth, mutex with username/password attribute #access-key: #secret-key: store: # support: file 、 db 、 redis mode: db# server:# service-port: 8091 #If not configured, the default is &#x27;$&#123;server.port&#125; + 1000&#x27; security: secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017 tokenValidityInMilliseconds: 1800000 ignore: urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.jpeg,/**/*.ico,/api/v1/auth/login 在nacos中新增配置 配置文件可以查看新增配置如下下面除了db外的配置都是默认的，写到nacos是为了方便后期修改，db之外的配置不写也没事 这里的driverClassName我用的是com.mysql.cj.jdbc.Driver，注意修改成自己的数据库名、账号、密码 # 数据存储方式，db代表数据库store.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.cj.jdbc.Driverstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=truestore.db.user=rootstore.db.password=123456store.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000# 事务、日志等配置server.recovery.committingRetryPeriod=1000server.recovery.asynCommittingRetryPeriod=1000server.recovery.rollbackingRetryPeriod=1000server.recovery.timeoutRetryPeriod=1000server.maxCommitRetryTimeout=-1server.maxRollbackRetryTimeout=-1server.rollbackRetryTimeoutUnlockEnable=falseserver.undo.logSaveDays=7server.undo.logDeletePeriod=86400000# 客户端与服务端传输方式transport.serialization=seatatransport.compressor=none# 关闭metrics功能，提高性能metrics.enabled=falsemetrics.registryType=compactmetrics.exporterList=prometheusmetrics.exporterPrometheusPort=9898 db配置，注意这里新增一个undo_log表，该表的建表语句在sql中不存在 完整sql如下 -- -------------------------------- The script used when storeMode is &#x27;db&#x27; ---------------------------------- the table to store GlobalSession dataCREATE TABLE IF NOT EXISTS `global_table`( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store BranchSession dataCREATE TABLE IF NOT EXISTS `branch_table`( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store lock dataCREATE TABLE IF NOT EXISTS `lock_table`( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0:locked ,1:rollbacking&#x27;, `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `distributed_lock`( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;AsyncCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryRollbacking&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;TxTimeoutCheck&#x27;, &#x27; &#x27;, 0);-- 注意此处0.3.0+ 增加唯一索引 ux_undo_logCREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 而且业务数据库也需要增加该表双击seata-server.bat启动即可服务已经注册到nacos中了注意命名空间，我们springboot的demo是public的，所以需要将seata的命名空间改为public 基本使用 引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;&lt;/dependency&gt; 在微服务中新增如下配置 seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH 完整的配置如下 server: port: 8070spring: application: name: account-service cloud: nacos: config: server-addr: localhost:8848 discovery: server-addr: localhost:8848 config: import: nacos:nacos-config-example.properties?refresh=true datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据库连接地址 name: defaultDataSource # 数据库用户名&amp;密码： username: root password: 123456 # 数据源名称 url: jdbc:mysql://localhost:3306/sentinel_account?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8mybatis-plus: configuration: # 配置mybatis-plus 打印sql日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # mybatis-plus下划线转驼峰配置，默认为true map-underscore-to-camel-case: true # xml文件路径 mapper-locations: classpath:/mapper/**/*.xml # 配置mybatis-plus 包路径 type-aliases-package: com.example.account.entityseata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH 如果需要锁定一个服务，我们需要确定以下四个配置 命名空间 服务分组 服务名称 集群名称集群如下再改一下seata的配置，配置SH集群我们并没有在微服务的application文件中配置cluster并不能在registry下直接配置cluster 正确做法是配置事务组，将事务分组，比如account、order、storage将来会被同一个tc集群管理，所以需要将它们配置到同一个事务组下 再根据事务组获取到映射关系，最终找到集群名称 这部分涉及到了seata的高可用，暂时不用过多深究启动服务启动微服务后，seata控命令窗口打印日志如下 RM register success,message:RegisterRMRequest&#123;resourceIds=&#x27;jdbc:mysql://localhost:3306/sentinel_account&#x27;, version=&#x27;1.7.0-native-rc2&#x27;, applicationId=&#x27;account-service&#x27;, transactionServiceGroup=&#x27;seata-demo&#x27;, extraData=&#x27;null&#x27;&#125;,channel:[id: 0xc06aa8c5, L:/192.168.56.1:8091 - R:/192.168.56.1:57929],client version:1.7.0-native-rc2 动手实践XA模式概念 XA规范是x&#x2F;Open组织定义的分布式事务处理(DTP, Distributed Transaction Processing)标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。XA模式是一种强一致性、低可用性的模式正常情况异常情况 Seata中的XA模式 seata的XA模式做了一些调整,但大体相似RM一阶段的工作: 注册分支事务到TC 执行分支业务sq|但不提交 报告执行状态到TCTC二阶段的工作: TC检测各分支事务执行状态​ a.如果都成功，通知所有RM提交事务​ b.如果有失败，通知所有RM回滚事务RM二阶段的工作:接收TC指令，提交或回滚事务 总结XA模式的优点是什么? 事务的强一致性,满足ACID原则。 常用数据库都支持，实现简单，并且没有代码侵入XA模式的缺点是什么? 因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差 依赖关系型数据库实现事务(如redis就无法实现) 实现XA模式 修改application.yml文件，开启XA模式seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH # 开启XA模式 data-source-proxy-mode: XA 给发起全局事务的入口方法添加@GlobalTransactional注解@Slf4j@Servicepublic class OrderServiceImpl implements OrderService &#123; private final AccountClient accountClient; private final StorageClient storageClient; private final OrderMapper orderMapper; public OrderServiceImpl(AccountClient accountClient, StorageClient storageClient, OrderMapper orderMapper) &#123; this.accountClient = accountClient; this.storageClient = storageClient; this.orderMapper = orderMapper; &#125; @Override @GlobalTransactional public Long create(Order order) &#123; // 创建订单 orderMapper.insert(order); try &#123; // 扣用户余额 accountClient.deduct(order.getUserId(), order.getMoney()); // 扣库存 storageClient.deduct(order.getCommodityCode(), order.getCount()); &#125; catch (FeignException e) &#123; log.error(&quot;下单失败，原因:&#123;&#125;&quot;, e.contentUTF8(), e); throw new RuntimeException(e.contentUTF8(), e); &#125; return order.getId(); &#125;&#125; 重启服务并测试运行前的数据运行后的数据 可以看到实现了全局事务 AT模式概念 AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。阶段一RM的工作: 注册分支事务 记录undo-log (数据快照) 执行业务sql并提交 报告事务状态 阶段二提交时RM的工作:删除undo-log即可 阶段二回滚时RM的工作:根据undo-log恢复数据到更新前案例如下一个分支业务的SQL是这样的: update tb account set money = money- 10 where id = 1 总结简述AT模式与XA模式最大的区别是什么? XA模式一阶段不提交事务，锁定资源; AT模式一阶段直接提交，不锁定资源。 XA模式依赖数据库机制实现回滚; AT模式利用数据快照实现数据回滚。 XA模式强一致; AT模式最终一致 AT模式的脏写问题 事务1在提交事务之后，紧接着被事务2获取到了锁，而事务1的全局事务需要回滚，则此时事务1会将money恢复到100，但是影响到了事务2的操作 原因就是事务没有做到隔离，解决方式就是引入全局锁，标记对某行数据的拥有权，在事务提交前，其他事务无法修改事务1在提交事务后，释放DB锁；而DB锁马上被事务2获取到了，但全局事务锁在事务1手上，事务2拿不到 而DB锁在事务2手上，事务1拿不到，此时产生了死锁，但由于获取全局事务锁的过程有重试机制，任务超时会回滚并释放DB锁 这时事务1获取到了DB锁有一个问题，如果在事务1的1.3~2.1过程中，有一个不被seata管理的事务修改了值，也会产生脏写问题在保存快照时，保存两份数据，一个是修改前的，一个是修改后的 当释放全局锁时，对比修改后的数据，如果不一致，说明在这段时间有其他事务修改了数据 这就没办法了，只能人工介入，这是比较极端的情况 总结AT模式的优点: 一阶段完成直接提交事务,释放数据库资源，性能比较好 利用全局锁实现读写隔离 没有代码侵入,框架自动完成回滚和提交AT模式的缺点: 两阶段之间属于软状态，属于最终一致 框架的快照功能会影响性能,但比XA模式要好很多 步骤 新建两张表，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库，这些操作在Seata配置阶段已经做过了 修改application.yml，将事务模式改为AT即可 seata: registry: type: nacos nacos: server-addr: localhost:8848 namespace: public group: DEFAULT_GROUP # tc服务在nacos的注册名称 application: seata-server username: nacos password: nacos # 事务组，根据这个获取tc服务的cluster名称 tx-service-group: seata-demo service: # 事务组与TC服务cluster的映射关系 vgroup-mapping: seata-demo: SH data-source-proxy-mode: AT 重启服务测试 TCC模式概念TCC模式与AT模式非常相似,每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复，而非自动恢复(生成快照)。需要实现三个方法: Try: 资源的检测和预留; Confirm: 完成资源操作业务;要求Try成功Confirm一定要能成功。 Cancel: 预留资源释放,可以理解为try的反向操作。 总结TCC模式的每个阶段是做什么的? Try:资源检查和预留 Confirm:业务执行和提交 Cancel:预留资源的释放TCC的优点是什么? 一阶段完成直接提交事务,释放数据库资源,性能好 相比AT模型，无需生成快照，无需使用全局锁，性能最强 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库TCC的缺点是什么? 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦 软状态，事务是最终一致 需要考虑Confirm和Cancel的失败情况，做好幂等处理。(失败后，seata会重试，需要考虑重复处理的情况) 案例需求如下: 修改account-service,编写try、confirm、 cancel逻辑 try业务:添加冻结金额，扣减可用金额 confirm业务:删除冻结金额 cancel业务:删除冻结金额，恢复可用金额 保证confirm、cancel接口的幂等性（业务接口不会因为重复调用出现问题） 允许空回滚 拒绝业务悬挂 有几个需要注意的点，资源预留是为了修改目标数据的值，但是新增订单是一个新增逻辑，这并不适合TCC模式，用AT模式就很好了 扣减余额和扣减库存可以使用TCC模式，在一个分布式事务当中既有TCC模式又有AT模式可以么？ 答案是可以的 空回滚问题当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚,就是空回滚。这里并没有进行资源预留也无法进行回滚，但是这里也不能进行报错，否则Seata会认为cancel失败，应该返回正常结束。 业务悬挂 此时阻塞的业务终于畅通了，但是这个事务已经提交了，后续既没有进行confirm也没有执行cancel 对于已经空回滚的业务，如果以后继续执行try,就永远不可能confirm或cancel,这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂为了避免空回滚，应该在cancel判断是否进行了try 为了避免业务悬挂，应该在try判断是否进行了cancel 这样就必须在数据库里记录当前状态，判断当前是在try？还是在confirm或者cancel？ -- auto-generated definitioncreate table accoutn_freeze_tbl_8( xid varchar(188) not null comment &#x27;事务编号&#x27; primary key, user_id varchar(255) null comment &#x27;用户编号`&#x27;, freeze_money int unsigned default 0 null comment &#x27;冻结金额&#x27;, state int null comment &#x27;事务状态(0:try、1:confirm、2:cancel)&#x27;) comment &#x27;冻结金额表&#x27;; try业务 记录冻结金额和事务状态到account_ freeze表 扣减account表可用金额 confirm业务根据xid删除account_freeze表的冻结记录 cancel业务 修改account_ freeze表,冻结金额为0，state为2 修改account表，恢复可用金额 如何判断是否空回滚cancel业务中，根据xid查询account_freeze,如果为null则说明try还没做，需要空回滚 如何避免是否业务悬挂try业务中，根据xid查询account_freeze如果已经存在则证明Cancel已经执行，拒绝执行try业务 代码实现TCC的Try、Confirm、 Cancel方法都需要在接口中基于注解来声明，语法如下: name指定try方法、commitMethod指定confirm方法、rollbackMethod指定cancel方法 public interface AccountTCCService &#123; /** * 从用户账户中扣款 * * @param userId 用户 ID * @param money 钱 */ @TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;) void deduct(@BusinessActionContextParameter(paramName = &quot;userId&quot;) String userId, @BusinessActionContextParameter(paramName = &quot;money&quot;) int money); boolean confirm(BusinessActionContext context); boolean cancel(BusinessActionContext context);&#125; @Data@TableName(&quot;account_freeze_tbl&quot;)public class AccountFreeze &#123; @TableId(type = IdType.INPUT) private String xid; private String userId; private Integer freezeMoney; private Integer state; public static abstract class State &#123; public final static int TRY = 0; public final static int CONFIRM = 1; public final static int CANCEL = 2; &#125;&#125; public interface AccountFreezeMapper extends BaseMapper&lt;AccountFreeze&gt; &#123;&#125; @Slf4j@Servicepublic class AccountTCCServiceImpl implements AccountTCCService &#123; private final AccountMapper accountMapper; private final AccountFreezeMapper accountFreezeMapper; @Autowired public AccountTCCServiceImpl(AccountMapper accountMapper, AccountFreezeMapper accountFreezeMapper) &#123; this.accountMapper = accountMapper; this.accountFreezeMapper = accountFreezeMapper; &#125; /** * 扣除金额 * TCC try方法 * * @param userId 用户 ID * @param money 钱 */ @Transactional @Override public void deduct(String userId, int money) &#123; // 获取事务id String xid = RootContext.getXID(); // 数据库字段设置为unsigned int，所以不能为负数 // 1.扣减金额 accountMapper.deduct(userId,money); // 2.记录冻结金额、事务状态 AccountFreeze accountFreeze = new AccountFreeze(); accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(money); accountFreeze.setState(AccountFreeze.State.TRY); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); &#125; /** * 确认 * TCC confirm方法 * * @param context 上下文 * @return boolean */ @Override public boolean confirm(BusinessActionContext context) &#123; // 获取事务id String xid = context.getXid(); // 删除了一条数据 return accountFreezeMapper.deleteById(xid)==1; &#125; /** * 取消 * TCC cancel方法 * * @param context 上下文 * @return boolean */ @Override public boolean cancel(BusinessActionContext context) &#123; // 查询冻结记录 String xid = context.getXid(); AccountFreeze accountFreeze = accountFreezeMapper.selectById(xid); // 1.恢复可用余额 accountMapper.refund(accountFreeze.getUserId(),accountFreeze.getFreezeMoney()); // 2.将冻结金额清零，状态设置为CANCEL accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); int count = accountFreezeMapper.updateById(accountFreeze); return count==1; &#125;&#125; 以上是基本内容 接下来增加对于空回滚和业务悬挂的判断 @Slf4j@Servicepublic class AccountTCCServiceImpl implements AccountTCCService &#123; private final AccountMapper accountMapper; private final AccountFreezeMapper accountFreezeMapper; @Autowired public AccountTCCServiceImpl(AccountMapper accountMapper, AccountFreezeMapper accountFreezeMapper) &#123; this.accountMapper = accountMapper; this.accountFreezeMapper = accountFreezeMapper; &#125; /** * 扣除金额 * TCC try方法 * * @param userId 用户 ID * @param money 钱 */ @Transactional @Override public void deduct(String userId, int money) &#123; // 获取事务id String xid = RootContext.getXID(); // 判断业务悬挂 AccountFreeze selectedById = accountFreezeMapper.selectById(xid);) if(selectedById!=null)&#123; // cancel已经执行过 return; &#125; // 数据库字段设置为unsigned int，所以不能为负数 // 1.扣减金额 accountMapper.deduct(userId,money); // 2.记录冻结金额、事务状态 AccountFreeze accountFreeze = new AccountFreeze(); accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(money); accountFreeze.setState(AccountFreeze.State.TRY); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); &#125; /** * 确认 * TCC confirm方法 * * @param context 上下文 * @return boolean */ @Override public boolean confirm(BusinessActionContext context) &#123; // 获取事务id String xid = context.getXid(); // 删除了一条数据，删除数据本来就是幂等性的 return accountFreezeMapper.deleteById(xid)==1; &#125; /** * 取消 * TCC cancel方法 * * @param context 上下文 * @return boolean */ @Override public boolean cancel(BusinessActionContext context) &#123; // 查询冻结记录 String xid = context.getXid(); String userId = context.getActionContext(&quot;userId&quot;).toString(); AccountFreeze accountFreeze = accountFreezeMapper.selectById(xid); // 空回滚的判断 if(accountFreeze==null)&#123; // 记录空回滚的数据 accountFreeze.setUserId(userId); accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); accountFreeze.setXid(xid); accountFreezeMapper.insert(accountFreeze); return true; &#125; // 幂等性判断 if(accountFreeze.getState()==AccountFreeze.State.CANCEL)&#123; // 已经执行过cancel方法了，无需重复执行 return true; &#125; // 1.恢复可用余额 accountMapper.refund(accountFreeze.getUserId(),accountFreeze.getFreezeMoney()); // 2.将冻结金额清零，状态设置为CANCEL accountFreeze.setFreezeMoney(0); accountFreeze.setState(AccountFreeze.State.CANCEL); int count = accountFreezeMapper.updateById(accountFreeze); return count==1; &#125;&#125; Saga模式Saga模式是SEATA提供的长事务解决方案。也分为两个阶段: 一阶段:直接提交本地事务 二阶段:成功则什么都不做;失败则通过编写补偿业务来回滚Saga模式的缺点是没有隔离性Saga模式优点: 事务参与者可以基于事件驱动实现异步调用，吞吐高 一阶段直接提交事务，无锁，性能好 不用编写TCC中的三个阶段，实现简单缺点: 软状态持续时间不确定，时效性差 没有锁，没有事务隔离，会有脏写 模式对比","categories":[{"name":"Seata","slug":"Seata","permalink":"https://isunderachiever.github.io/categories/Seata/"}],"tags":[{"name":"Seata","slug":"Seata","permalink":"https://isunderachiever.github.io/tags/Seata/"}]},{"title":"Resilience4j","slug":"编程语言/Java/学习/框架/Resilience4j/Resilience4j","date":"2024-04-15T00:30:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/resilience4j/resilience4j.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/resilience4j/resilience4j.html","excerpt":"","text":"Resilience4j项目搭建 熔断限流框架 &lt;properties&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud.version&gt;2022.0.0-RC2&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 可直接导入spring-cloud-starter-circuitbreaker-resilience4j依赖或者导入resilience4j-spring-boot3 aop的依赖一定要导入 &lt;dependency&gt; &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt; &lt;artifactId&gt;resilience4j-spring-boot3&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; server: port: 8080spring: application: name: resilience4j-demo# 配置Resilience4jresilience4j: # 重试机制 retry: # 定义多个重试策略实例 instances: # 充实策略实例名称 retryApi: # 最大重试次数 max-attempts: 3 # 每次重试等待1s wait-duration: 1s # 断路器 circuitbreaker: # 定义多个断路器实例 instances: # 第一个断路器实例名称 circuitBreakerApi: # 健康监测 register-health-indicator: true # 滑动窗口大小 sliding-window-size: 10 # 但断路器处于半开状态时，允许的最大调用次数为3 permitted-number-of-calls-in-half-open-state: 3 # 滑动窗口类型 sliding-window-type: time_based # 断路器打开的最小请求数 minimum-number-of-calls: 5 # 断路器打开的时间 wait-duration-in-open-state: 5s # 失败率达到20%时，断路器打开 failure-rate-threshold: 20 # 事件缓冲区大小 event-consumer-buffer-size: 10 # 配置限流 ratelimiter: # 定义多个限流策略实例 instances: # 第一个限流策略实例名称 flowLimitApi: # 在一个特定的时间周期内，允许的最大请求数量为（QPS为1） limit-for-period: 1 # 这个时间周期的长度是1秒，即每1秒会重置请求计数 limit-refresh-period: 1s # 当请求超过限制时，客户端应立即收到超时的响应，而不等待处理 timeout-duration: 100ms 配置RestTemplate，待会测试失败重试机制，我这里就直接放在启动类下了 @SpringBootApplicationpublic class Resilience4jDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Resilience4jDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 统一返回格式 @Data@AllArgsConstructor@NoArgsConstructorpublic class JsonData &#123; /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() &#123; return new JsonData(0, null, null); &#125; // 成功，传入数据 public static JsonData buildSuccess(Object data) &#123; return new JsonData(0, data, null); &#125; // 失败，传入描述信息 public static JsonData buildError(String msg) &#123; return new JsonData(-1, null, msg); &#125; // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) &#123; return new JsonData(code, null, msg); &#125;&#125; 新建TestController import com.example.utils.JsonData;import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;import io.github.resilience4j.ratelimiter.annotation.RateLimiter;import io.github.resilience4j.retry.annotation.Retry;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.Random;@Slf4j@RestControllerpublic class TestController &#123; private RestTemplate restTemplate; @Autowired public TestController(RestTemplate restTemplate) &#123; this.restTemplate = restTemplate; &#125; /** * 测试重试 * * @return &#123;@link JsonData&#125; */ @Retry(name = &quot;retryApi&quot;,fallbackMethod = &quot;fallback&quot;) @GetMapping(&quot;/test1&quot;) public JsonData test1() &#123; log.info(&quot;test1 received&quot;); // 访问一个不存在的地址 String forObject = restTemplate.getForObject(&quot;http://localhost:8085/test1&quot;, String.class); return JsonData.buildSuccess(&quot;test1&quot;); &#125; /** * 测试熔断 * * @return &#123;@link JsonData&#125; */ @CircuitBreaker(name = &quot;circuitBreakerApi&quot;,fallbackMethod = &quot;fallback&quot;) @GetMapping(&quot;/test2&quot;) public JsonData test2() &#123; int i = new Random().nextInt(100); // 40%的可能报异常，超过20%则熔断 if(i&gt;60)&#123; throw new RuntimeException(&quot;Unexpected Exception&quot;); &#125; return JsonData.buildSuccess(&quot;test2&quot;); &#125; /** * 测试限流 * * @return &#123;@link JsonData&#125; */ @RateLimiter(name = &quot;flowLimitApi&quot;,fallbackMethod = &quot;fallback&quot;) @GetMapping(&quot;/test3&quot;) public JsonData test3() &#123; return JsonData.buildSuccess(&quot;test3&quot;); &#125; /** * fallback * * @param throwable 可投掷 * @return &#123;@link JsonData&#125; */ private JsonData fallback(Throwable throwable)&#123; log.error(&quot;fallback:&quot;,throwable); return JsonData.buildError(throwable.getMessage()); &#125;&#125; 重试测试 查看日志 熔断测试 限流测试 快速访问","categories":[{"name":"Resilience4j","slug":"Resilience4j","permalink":"https://isunderachiever.github.io/categories/Resilience4j/"}],"tags":[{"name":"Resilience4j","slug":"Resilience4j","permalink":"https://isunderachiever.github.io/tags/Resilience4j/"}]},{"title":"踩坑","slug":"报错记录/SpringBoot/server.port启动端口不生效","date":"2024-04-10T22:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/springboot/server.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/springboot/server.html","excerpt":"","text":"server.port启动端口不生效 配置里写的端口是8088，然而启动的依然是8080首先清理一下缓存发现没什么用 maven clean后重新编译 依然没用 转properties，有用 我这里是装过了插件，可能是由于插件的影响","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://isunderachiever.github.io/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"server.port启动端口不生效","slug":"server-port启动端口不生效","permalink":"https://isunderachiever.github.io/tags/server-port%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/"}]},{"title":"SpringCloud","slug":"编程语言/Java/学习/框架/SpringCloud/SpringCloud","date":"2024-04-10T00:40:00.000Z","updated":"2024-06-01T14:32:53.453Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/springcloud.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/springcloud.html","excerpt":"","text":"SpringCloud服务的注册发现Http请求 微服务远程调用可以采用Http和RPC的方式 项目搭建注册RestTemplate，通过RestTemplate来实现http请求调用其他服务 新建一个空项目，名为cloud-demo 在cloud-demo下新建一个order项目和user项目(这里采用jdk17新建springboot3工程)cloud-demo&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-demo&lt;/name&gt; &lt;description&gt;cloud-demo&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;user&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2022.0.0.0-RC2&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;2022.0.0-RC2&lt;/spring-cloud.version&gt; &lt;mysql.version&gt;8.3.0&lt;/mysql.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;mybatis-plus.version&gt;3.5.5&lt;/mybatis-plus.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; user&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;user&lt;/name&gt; &lt;description&gt;user&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; order与user一样 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;order&lt;/name&gt; &lt;description&gt;order&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; user&#x2F;application.properties spring.application.name=user-service# 应用服务 WEB 访问端口server.port=8080# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-user?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.user.domain# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto order&#x2F;application.properties spring.application.name=order-service# 应用服务 WEB 访问端口server.port=8090# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.order.domain# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto 这里使用idea自带的数据库管理工具来新建数据库user数据库如下，输入cloud-user，order同理cloud-order 右键数据库，选择创建表 create table user( id int auto_increment comment &#x27;用户编号&#x27;, username varchar(20) null comment &#x27;账号&#x27;, address varchar(50) null comment &#x27;地址&#x27;, constraint user_pk primary key (id)) comment &#x27;用户表&#x27;; INSERT INTO `cloud-user`.user (id, username, address) VALUES (1, &#x27;admin&#x27;, &#x27;湖北&#x27;);INSERT INTO `cloud-user`.user (id, username, address) VALUES (2, &#x27;zhangsan&#x27;, &#x27;湖南&#x27;);INSERT INTO `cloud-user`.user (id, username, address) VALUES (3, &#x27;lisi&#x27;, &#x27;山西&#x27;); create table `orders`( id int auto_increment comment &#x27;订单编号&#x27;, name varchar(20) null comment &#x27;名称&#x27;, price decimal null comment &#x27;价格&#x27;, num int null comment &#x27;数量&#x27;, user_id int null comment &#x27;用户编号&#x27;, constraint order_pk primary key (id)) comment &#x27;订单表&#x27;; INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (1, &#x27;小米手机&#x27;, 4999, 1, 1);INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (2, &#x27;华为手机&#x27;, 5999, 3, 1);INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (3, &#x27;魅族手机&#x27;, 3999, 2, 2);INSERT INTO `cloud-order`.`orders` (id, name, price, num, user_id) VALUES (4, &#x27;OPPO手机&#x27;, 4000, 1, 3); 我们的需求是:根据订单id查询订单的同时，把订单所属的用户信息一起返回 这里就是MyBatisX一键生成mapper、service代码了 这里需要注意个问题表名不要叫order，order属于数据库的关键字，选择orders 编写controller代码@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @PostMapping public Boolean save(@RequestBody Orders orders) &#123; return ordersService.saveOrUpdate(orders); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Boolean delete(@PathVariable Integer id) &#123; return ordersService.removeById(id); &#125; @GetMapping public List&lt;Orders&gt; findAll() &#123; return ordersService.list(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; return ordersService.getById(id); &#125; @GetMapping(&quot;/page&quot;) public Page&lt;Orders&gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) &#123; return ordersService.page(new Page&lt;&gt;(pageNum, pageSize)); &#125;&#125; @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @PostMapping public Boolean save(@RequestBody User user) &#123; return userService.saveOrUpdate(user); &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public Boolean delete(@PathVariable Integer id) &#123; return userService.removeById(id); &#125; @GetMapping public List&lt;User&gt; findAll() &#123; return userService.list(); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) public User findOne(@PathVariable Integer id) &#123; return userService.getById(id); &#125; @GetMapping(&quot;/page&quot;) public Page&lt;User&gt; findPage(@RequestParam Integer pageNum, @RequestParam Integer pageSize) &#123; return userService.page(new Page&lt;&gt;(pageNum, pageSize)); &#125;&#125; 输入http://localhost:8080/user/1即可访问到`user`的结果 输入http://localhost:8090/order/1即可访问到`order`的结果 根据订单id查询订单的同时，把订单所属的用户信息一起返回 需求可以转变为 在OrderController中请求一下user的结果，然后封装返回配置Order服务的RestTemplate import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * Http请求调用配置 * @author: 不是菜狗爱编程 * @date: 2024/04/04/8:40 * @description: */@Configurationpublic class HttpConfig &#123; /** * 创建RestTemplate并注入spring容器 * * @return &#123;@link RestTemplate&#125; */ @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 复制User实体类到Order服务 @Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private Integer id; private String username; private String address;&#125; Order服务新增一个User属性 @TableName(value =&quot;orders&quot;)@Datapublic class Orders implements Serializable &#123; @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer price; private Integer num; private Integer userId; @TableField(exist = false) private User user; @TableField(exist = false) private static final long serialVersionUID = 1L;&#125; 修改OrdersController方法 @RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; private static final String USER_SERVICE_URL=&quot;http://localhost:8080/user/&quot;; @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(USER_SERVICE_URL + orders.getUserId(), User.class); orders.setUser(user); return orders; &#125;&#125; 访问http://localhost:8090/order/1以上，实现了跨入服务的远程调用 Eureka概念服务提供者: 一次业务中，被其它微服务调用的服务。(提供接口给其它微服务)服务消费者: 一次业务中，调用其它微服务的服务。(调用其它微服务提供的接口)以上代码的实现中，User是服务的提供者，Order是服务的消费者代码中使用硬编码将url写在代码中，将来如果部署成集群，则硬编码应该怎么办？应该选择哪一台？选的那一台实例是否依然正常？Eureka、Nacos可以实现上述需求 在每一个服务启动时，将自己的服务信息注册到Eureka中，这时候Eureka中已经存储了相关的Order和User服务的信息 在Order服务调用User服务时，Order服务前往Eureka中找到User服务的url 那怎么知道找到的User服务是否依然正常运行？ 服务会每30s向Eureka发送心跳，如果心跳停止，说明服务异常在Eureka架构中，微服务角色有两类: EurekaServer: 服务端，注册中心 记录服务信息 心跳监控 EurekaClient: 客户端 Provider: 服务提供者，例如案例中的user-service 注册自己的信息到EurekaServer 每隔30秒向EurekaServer发送心跳 consumer:服务消费者，例如案例中的order-service 根据服务名称从EurekaServer拉取服务列表 基于服务列表做负载均衡，选中一个微服务后发起远程调用 搭建Eureka服务 引入依赖 编写启动类，添加@EnableEurekaServer注解 配置application.properties cloud-demo&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-demo&lt;/name&gt; &lt;description&gt;cloud-demo&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;user&lt;/module&gt; &lt;module&gt;eureka&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud.version&gt;2022.0.0-RC2&lt;/spring-cloud.version&gt; &lt;mysql.version&gt;8.3.0&lt;/mysql.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;mybatis-plus.version&gt;3.5.5&lt;/mybatis-plus.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; eureka&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;eureka&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka&lt;/name&gt; &lt;description&gt;eureka&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; @EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; # 应用服务 WEB 访问端口server.port=8070# 是否将自己注册到注册中心eureka.client.register-with-eureka=false# 是否从EurekaServer抓取已有的注册信息，默认为true。 单节点无所谓， 集群必须设置为true才能配合ribbon使用负载均衡eureka.client.fetch-registry=falseeureka.client.service-url.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/# 关闭自我保护机制eureka.server.enable-self-preservation=falseeureka.server.eviction-interval-timer-in-ms=2000 Eureka配置成功，只是此时并没有服务注册到Eureka 服务注册 配置user和order，将服务注册进eureka &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; eureka.instance.hostname=$&#123;spring.application.name&#125;# 是否显示ipeureka.instance.prefer-ip-address=true#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)eureka.instance.lease-renewal-interval-in-seconds=3#Eureka,服务端在收到最后-次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务eureka.instance.lease-expiration-duration-in-seconds=5eureka.client.service-url.defaultZone=http://localhost:8070/eureka/ 可以看到此时服务已经注册到Eureka了，但这些服务都是一个实例，启动多个实例试试如果找不到Services，可以在View - Tool Windows处添加右键服务，选择Copy Configuration # 配置服务启动端口-Dserver.port=8081 右键启动该实例前往Eureka页面查看 服务发现 我们希望Order服务调用User服务时，前往Eureka注册中心获取到User服务的信息 而不是使用硬编码的形式写死User服务的ip和端口 修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口:String url = &quot;http://user-service/user/&quot; + order.getUserId(); 在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解:@Bean@LoadBalancedpublic RestTempLate restTempLate() &#123; return new RestTemplate() ;&#125; 在启动类山添加@EnableDiscoveryClient注解 修改HttpConfig的代码 @Configurationpublic class HttpConfig &#123; /** * 创建RestTemplate并注入spring容器 * * @return &#123;@link RestTemplate&#125; */ @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改OrdersController代码 @RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(&quot;http://user-service/user/&quot; + orders.getUserId(), User.class); orders.setUser(user); return orders; &#125;&#125; 如果报错No instances available for user-service 请查看博客如果依然不能解决，请查看application.properties里是否配置了如下内容，如果是，删除后重启即可解决 # 是否从EurekaServer抓取已有的注册信息，默认为true。 单节点无所谓， 集群必须设置为true才能配合ribbon使用负载均衡eureka.client.fetch-registry=false 这样就可以通过服务名的方式来完成服务之间的调用，哪怕服务启动了多个实例 负载均衡基础 Ribbon实现负载均衡Ribbon是如何实现负载均衡的呢？添加了@LoadBalanced注解后，表明该RestTemplate发起的请求，需要被Ribbon来拦截处理 而拦截的动作是LoadBalancerInterceptor来完成的 idea中按两下shift后搜索即可而LoadBalancerInterceptor类实现了ClientHttpRequestInterceptor接口它会去拦截由客户端发起的Http请求，而RestTemplate正是一个发Http请求的客户端 LoadBalancerInterceptor类实现了intercept方法 在LoadBalancerInterceptor打断点调试一下，debug运行Order 发现请求确实被LoadBalancerInterceptor拦截了可以看到Order服务发起了一个Http请求，Url是http://user-service/user/1执行完String serviceName = originalUri.getHost();代码之后，获取到了主机名user-service进入loadBalancer.execute方法，继续执行发现这里已经获取到User服务的ip了，我们运行了多个User服务的实例，这里大家可能看到的是8080或者8090 是在这一行代码上获取到了User服务那它怎么知道或者按什么规则来获取的其中一个User服务呢？ 继续进去，发现可能是在loadBalancer.choose获取到的再往里走就是一个接口了ReactiveLoadBalancer 按住Ctrl H查看这个接口的实现类这里Eureka默认的调度机制其实是轮询 策略通过定义IRule实现可以修改负载均衡规则，有两种方式:代码方式:在配置类中，定义一个新的IRule:(全局配置，不管调用哪个服务，都会采用这个负载均衡规则) @Beanpubtic IRuLe randomRuLe() &#123; return new RandomRuLe();&#125; 第二种配置方案是properties，而这种方法是针对每个服务来配置负载均衡规则 #负载均衡规则user-service.ribbon.NFLoadBalancerRuLeCLassName=com.netflix.Loadbalancer.RandomRuLe 饥饿加载Ribbon默认是采用懒加载，即第一 次访问时才会去创建LoadBalanceClient, 请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载 # 开启饥饿加载ribbon.eager-load.enabled=true# 对指定服务饥饿加载ribbon.eager-load.clients=user-service Nacos安装SpringBoot、SpringCloud、Alibaba版本对应关系Nacos下载选择2.2.1版本的Naocsnacos-2.2.1/bin/startup.cmd用vscode或者记事本打开 双击发现闪退，在结尾处加上如下代码 pauseendlocal 再次双击，查看到报错信息，找到博客 还需要配置conf目录下的application.properties nacos.core.auth.default.token.secret.key这个参数必须配置为base64编码而且不能小于32位，随便找个在线网站编码一下即可重新启动nacos账号密码都是nacos在父工程中配置pom.xml &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud.version&gt;2022.0.0&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;2022.0.0.0-RC2&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud-netflix.version&gt;2.2.0.RELEASE&lt;/spring-cloud-netflix.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;nacos-client.version&gt;1.4.4&lt;/nacos-client.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-netflix.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;$&#123;nacos-client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Order和User服务的pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.properties # 端口server.port=8090# 服务名spring.application.name=order-servicespring.cloud.nacos.discovery.server-addr=localhost:8848spring.cloud.nacos.config.server-addr=localhost:8848spring.cloud.nacos.config.import-check.enabled=false 测试一下负载均衡是否可用 此时还没有意识到事情的严重性，然后就一直报错了 解决报错 查看博客 因为Netflix的组件从2020年开始停止维护，因此spring cloud会逐渐弃用他家的组件,Ribbon就在其中 依然没有解决该错误后，前往官网查看，发现官方给了例子 但是版本跟我们的有区别 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意，我我们在父pom里配置了nacos-client的版本 我使用官方例子的版本1.1.0和1.2.0报错如下 java.lang.NoClassDefFoundError: com/alibaba/nacos/client/logging/NacosLogging 上网查询资料发现应该是版本不匹配，后打开依赖分析，发现有一堆依赖都不匹配 nacos-client版本改为1.4.4后以上报错解决，但是依然无法实现RestTemplate调用服务 问题也是出在依赖上 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; 将spring-cloud-starter-netflix-ribbon改为spring-cloud-loadbalancer，这里无需写版本号 启动后解决问题 依赖 重新给一遍pom依赖，这里我使用的版本并不需要使用bootstrap.properties文件来配置，application.properties足矣网上有说需要导入spring-cloud-starter-bootstrap依赖，我们这里并不需要cloud-demo&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-demo&lt;/name&gt; &lt;description&gt;cloud-demo&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;user&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2022.0.0.0-RC2&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;2022.0.0-RC2&lt;/spring-cloud.version&gt; &lt;mysql.version&gt;8.3.0&lt;/mysql.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;mybatis-plus.version&gt;3.5.5&lt;/mybatis-plus.version&gt; &lt;nacos-client.version&gt;1.4.4&lt;/nacos-client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;$&#123;nacos-client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; order&#x2F;pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;order&lt;/name&gt; &lt;description&gt;order&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;17&lt;/source&gt; &lt;target&gt;17&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.order.OrderApplication&lt;/mainClass&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;netflix-candidates&lt;/id&gt; &lt;name&gt;Netflix Candidates&lt;/name&gt; &lt;url&gt;https://artifactory-oss.prod.netflix.net/artifactory/maven-oss-candidates&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; user依赖也是一样application.properties # 应用服务 WEB 访问端口server.port=8090# 服务名spring.application.name=order-service# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.order.domainspring.cloud.nacos.discovery.server-addr=localhost:8848spring.cloud.nacos.config.server-addr=localhost:8848spring.cloud.nacos.config.import-check.enabled=false 项目Gitee地址，切换到nacos分支即可测试发现，负载均衡也可以使用 服务分级存储模型入门 每个服务启动多个实例，将这些实例划分到不同的集群 服务调用尽可能选择本地集群的服务，跨集群调用延迟较高 本地集群不可访问时，再去访问其它集群点击Nacos服务 &quot;详情&quot;集群是default，即没有集群配置集群属性 修改application.properties，添加如下内容 # 配置集群名称，也就是机房位置，例如JS(江苏)spring.cloud.nacos.discovery.cluster-name=JS 在Nacos控制台看到集群的变化再起一个User服务实例，现在是3个User服务实例了 将UserApplication1和UserApplication2设置到JS江苏集群，将UserApplication3设置到HN湖南集群 启动UserApplication1和UserApplication2，然后将集群改为HN，启动UserApplication3即可总结Nacos服务分级存储模型 一级是服务，例如userservice 二级是集群，例如杭州或上海 三级是实例，例如杭州机房的某台部署了userservice的服务器 服务集群属性 这样配置还不算完，我们需要让Order服务调用User服务时，优先选择本地集群这里并没有优先使用JS的User服务，依然采用的是轮询方案 服务在选择实例时，是由负载均衡决定的，这里并没有配置，所以采用的是默认轮询 # 负载均衡规则userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule 实现以上配置之后即可完成实现优先访问本地集群的服务 实测之后发现只能在较低版本的Nacos中生效，高版本的Nacos已经取消了对Ribbon的支持 解决办法查看博客,实测可行 但是随着Spring Cloud Gateway或者其他更先进的API Gateway的广泛应用，以及服务网格（Service Mesh）架构的发展 例如采用Istio或阿里云的ASM（Application Service Mesh），这种跨可用区或跨集群的流量调度通常会交由服务网格层面处理，而非仅仅依赖客户端SDK内置的负载均衡机制 那么可能需要转向服务网格或Spring Cloud Gateway级别的路由规则定义，所以负载均衡应该由网关服务来承担，而非消费服务自身 权重设置实际部署中会出现这样的场景:服务器设备性能有差异，部分实例所在机器性能较好，另一些较差， 我们希望性能好的机器承担更多的用户请求Nacos提供了权重配置来控制访问频率,权重越大则访问频率越高步骤 在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮 将权重设置为0.1,测试可以发现8081被访问到的频率大大降低（权重值位于0~1之间） 那这个时候理论上，8081的访问次数应该是8080的1/10，测试发现确实如此，权重配置已经生效 权重设置为0，则该服务不会被访问到 这种特性可以用以服务的版本升级 正常情况下是不会重启某个服务来实现版本升级的，此时用户还在访问呢，如何在用户无感知的前提下实现版本升级呢？ 在服务启动多个实例的情况下，如8081、8082、8083可以先将8081的实例权重设置为0，渐渐的8081就不会承担用户请求了，此时用户是无感知的这个时候对8081停机之后进行升级，然后重启，权重先设置小一点，如果用户请求没有bug，就可以增大权重实现升级了 环境隔离 Nacos中服务存储和数据存储的最外层都是一个名为命名空间(namespace)的东西，用来做最外层隔离 Namespace &gt; Group &gt; Service(服务) &gt; 集群 &gt; 实例 Group 用作分组，可以将相关度较高的业务划分为一个组此时就可以看到dev命名空间了，但是里面没有任何服务啊 需要去代码层面添加命名空间配置 # 命名空间idspring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c 重启order服务 发现在dev下可以看到order服务，而user服务仍然还在public下测试一下能否调用 不行报错如下 java.lang.IllegalStateException: No instances available for userservice 没有找到可用的实例，因为它们处在不同的命名空间下 Nacos注册中心原理 服务的消费者并不是每次都去拉去提供者的信息，而是会将拉去的服务列表进行缓存 而一直不拉取服务也不行，因为服务提供者的信息可能变化，所以需要每隔一段时间比如30s拉取一次 但是Nacos和Eureka还有一些差别在健康检测方面 Nacos会将所有的服务提供者分为临时实例和非临时实例，所有实例默认都是临时实例临时实例在Nacos中的健康检测是心跳检测，临时实例每隔一段时间向Nacos发送心跳，但频率会比Eureka的快一些 一旦心跳检测出现异常、不跳了，Nacos就会将其在服务列表中直接剔除 非临时实例不需要做心跳检测，而是Nacos主动发请求询问实例是否正常 Nacos不会将非临时实例在服务列表中剔除，而是会等待其恢复健康 Nacos和Eureka在消费者方面也有一些区别，Eureka会每隔30s拉取一次服务 但如果在30s内，有提供者的实例异常，消费者是不知道的呀，此时就会出问题 Nacos会主动将提供者变更的消息推送给消费者 Eureka主要是采用pull，而Nacos是pull和push结合 # 是否是临时实例spring.cloud.nacos.discovery.ephemeral=false 停止服务Nacos支持服务端主动检测提供者状态:临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式; Eureka采用AP方式Nacos与eureka的共同点都支持服务注册和服务拉取都支持服务提供者心跳方式做健康检测 配置管理 将一些配置信息放在Nacos上，如数据库、MyBatis，而且这些配置可以动态刷新，无需重启项目 一般写的是开关类型的配置，如赋值true就开启某个活动在 Nacos Spring Cloud 中，dataId 的完整格式如下： $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125; prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profiles.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 $&#123;prefix&#125;.$&#123;file-extension&#125; file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 Nacos配置管理的依赖我们已经引入 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 这里我就直接把application.properties中的DB配置和MyBatis配置写进来了order-service-dev.properties # 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.order.domain user-service-dev.properties# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-user?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.user.domain order/application.properties# 应用服务 WEB 访问端口server.port=8090# 服务名spring.application.name=order-service# nacos服务发现spring.cloud.nacos.discovery.server-addr=localhost:8848# 配置集群名称，也就是机房位置，例如JS(江苏)spring.cloud.nacos.discovery.cluster-name=JS# 命名空间idspring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# 是否是临时实例spring.cloud.nacos.discovery.ephemeral=false# nacos服务配置spring.cloud.nacos.config.server-addr=localhost:8848#spring.cloud.nacos.config.import-check.enabled=falsespring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# dataId前缀spring.cloud.nacos.config.prefix=$&#123;spring.application.name&#125;# 环境 (前缀-环境.后缀 如user-dev.properties)spring.profiles.active=dev# dataId后缀spring.cloud.nacos.config.file-extension=propertiesspring.config.import=nacos:$&#123;spring.cloud.nacos.config.prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true user/application.properties# 应用服务 WEB 访问端口server.port=8080# 服务名spring.application.name=user-service# nacos服务发现spring.cloud.nacos.discovery.server-addr=localhost:8848# 配置集群名称，也就是机房位置，例如JS(江苏)spring.cloud.nacos.discovery.cluster-name=JS# 命名空间idspring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# 是否是临时实例spring.cloud.nacos.discovery.ephemeral=false# nacos服务配置spring.cloud.nacos.config.server-addr=localhost:8848spring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# dataId前缀spring.cloud.nacos.config.prefix=$&#123;spring.application.name&#125;# 环境 (前缀-环境.后缀 如user-dev.properties)spring.profiles.active=dev# dataId后缀spring.cloud.nacos.config.file-extension=propertiesspring.config.import=nacos:$&#123;spring.cloud.nacos.config.prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true 注意之前配置过spring.cloud.nacos.config.import-check.enabled=false，需要删掉。还有spring.cloud.nacos.config.namespace一定要指定，因为我们不是配置在默认的public，而是自己新建的dev。否则在启动项目时会找不到DB配置信息报错 spring.cloud.nacos.discovery.ephemeral=false这个也要加上（因为已经在前面被注册成非临时实例了）否则会爆错Current service DEFAULT_GROUP@@order-service is persistent service, can’t register ephemeral instance意思是“DEFAULT_GROUP@@order-service”这个服务是一个持久化服务，不能注册为临时实例。 配置热更新Nacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现: 方式一:在@Value注入的变量所在类上添加注解@RefreshScope@RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @Value(&quot;$&#123;author.name&#125;&quot;) private String name; @Value(&quot;$&#123;author.date&#125;&quot;) private String date; @Value(&quot;$&#123;author.description&#125;&quot;) private String description; @GetMapping(&quot;/&#123;id&#125;&quot;) public Map&lt;String,Object&gt; findOne(@PathVariable Integer id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(&quot;http://user-service/user/&quot; + orders.getUserId(), User.class); orders.setUser(user); map.put(&quot;orders&quot;,orders); map.put(&quot;name&quot;,name); map.put(&quot;date&quot;,date); map.put(&quot;description&quot;,description); return map; &#125;&#125; 在order-service-dev.properties新增配置 author.name=不是菜狗爱编程author.date=2024/04/04/9:13author.description=暂无描述 重启项目后，访问配置修改配置后，不重启项目 author.name=不是菜狗爱编程author.date=2024/04/05/9:13author.description=第一次发布 方式二:使用@ConfigurationProperties注解新建Author.java@Data@Component@AllArgsConstructor@NoArgsConstructor@ConfigurationProperties(prefix = &quot;author&quot;)public class Author &#123; private String name; private String date; private String description;&#125; @RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private RestTemplate restTemplate; @Autowired private Author author; @GetMapping(&quot;/&#123;id&#125;&quot;) public Map&lt;String,Object&gt; findOne(@PathVariable Integer id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); Orders orders = ordersService.getById(id); User user = restTemplate.getForObject(&quot;http://user-service/user/&quot; + orders.getUserId(), User.class); orders.setUser(user); map.put(&quot;orders&quot;,orders); map.put(&quot;author&quot;,author); return map; &#125;&#125; 依然可以实现动态更新配置 多环境配置共享 nacos&#x2F;order-service-dev.properties # 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称spring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.order.domain nacos&#x2F;order-service.properties author.name=不是菜狗爱编程author.date=2024/04/05/9:13author.description=第一次发布 配置如下 # 应用服务 WEB 访问端口server.port=8090# 服务名spring.application.name=order-service# nacos服务发现spring.cloud.nacos.discovery.server-addr=localhost:8848# 配置集群名称，也就是机房位置，例如JS(江苏)spring.cloud.nacos.discovery.cluster-name=JS# 命名空间idspring.cloud.nacos.discovery.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# 是否是临时实例spring.cloud.nacos.discovery.ephemeral=false# nacos服务配置spring.cloud.nacos.config.server-addr=localhost:8848spring.cloud.nacos.config.namespace=d2455f6d-ed00-41ba-9915-09021bc0df6c# dataId前缀spring.cloud.nacos.config.prefix=$&#123;spring.application.name&#125;# 环境 (前缀-环境.后缀 如user-dev.properties)spring.profiles.active=dev# dataId后缀spring.cloud.nacos.config.file-extension=propertiesspring.config.import[0]=optional:nacos:$&#123;spring.cloud.nacos.config.prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=truespring.config.import[1]=optional:nacos:$&#123;spring.cloud.nacos.config.prefix&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true 如果使用yml的方式 spring: config: import: - optional:nacos:order-service.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true - optional:nacos:order-service-dev.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true 持久化 将nacos持久化到数据库 **注意**先导出一份配置，待会持久化到mysql之后导入之前的配置打开SQL执行界面注意不要直接执行，需要新建数据库，这里命令为nacos_config use nacos_config 注意账号、密码不要写错否则会报错如下导入之前的配置（order-service-dev.properties、order-service.properties、user-service-dev.properties）可以看到数据库里已经保存了该配置的数据 Feign入门 feign是一个http客户端 先来看我们以前利用RestTemplate发起远程调用的代码: User user = restTemplate.getForObject(&quot;http://user-service/user/&quot; + orders.getUserId(), User.class); 存在下面的问题: 代码可读性差，编程体验不统一 参数复杂URL难以维护Feign是一个声明式的http客户端，官方地址: https://github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送,解决上面提到的问题。 启动类上添加@EnableFeignClients注解 @FeignClient(&quot;provider-service&quot;)注解指定服务名，并复制服务发布者的controller方法到interface里，如@FeignClient(&quot;provider-service&quot;)public interface ProviderClient &#123; @GetMapping(&quot;/provider/&#123;string&#125;&quot;) public String echo(@PathVariable(value = &quot;string&quot;) String string);&#125; 然后注入ProviderClient即可使用@RestController@RequestMapping(&quot;consumer&quot;)public class ConsumerController &#123; @Autowired private ProviderClient providerClient; @GetMapping(&quot;/&#123;str&#125;&quot;) public Map&lt;String, Object&gt; echo(@PathVariable String str) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); String provider = providerClient.echo(str); map.put(&quot;provider&quot;,provider); map.put(&quot;consumer&quot;,&quot;this is consumer,&quot;+str); return map; &#125;&#125; 现在尝试一下， 原本的RestTemplate代码可以删掉了 //@Bean//@LoadBalanced//public RestTemplate restTemplate()&#123;// return new RestTemplate();//&#125; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; @EnableFeignClients@EnableDiscoveryClient@MapperScan(&quot;com.example.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 这里的配置需要注意一下，容易出问题 @FeignClient指定了服务名 @GetMapping(&quot;/user/&#123;id&#125;&quot;)这里一定要和被调用服务controller里写的一样才行，那边User服务类上有@RequestMapping(&quot;user&quot;)注解所以这里@GetMapping(&quot;/&#123;id&#125;&quot;)前面一定要加/user 方法名，返回值一定都得一样，建议直接去复制UserController即可 @FeignClient(&quot;user-service&quot;)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User findOne(@PathVariable(value = &quot;id&quot;) Integer id);&#125; @RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125;&#125; 这样就很优雅了 SpringBoot3新特性 SpringBoot3新特性内置声明式HTTP客户端，这里浅试一下 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; @EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125; @Bean public ProviderFluxClient userRestClient() &#123; WebClient client = WebClient.builder() .baseUrl(&quot;http://localhost:8080&quot;) .build(); HttpServiceProxyFactory factory = HttpServiceProxyFactory.builder(WebClientAdapter.forClient(client)) .build(); return factory.createClient(ProviderFluxClient.class); &#125;&#125; @HttpExchange(&quot;/provider&quot;)public interface ProviderFluxClient &#123; @GetExchange(&quot;/&#123;string&#125;&quot;) Flux&lt;String&gt; echo(@PathVariable(value = &quot;string&quot;) String string);&#125; @RestController@RequestMapping(&quot;consumer&quot;)public class ConsumerController &#123; @Autowired private ProviderFluxClient providerFluxClient; @GetMapping(&quot;/&#123;str&#125;&quot;) public String echo(@PathVariable String str) &#123; providerFluxClient.echo(str).subscribe( data -&gt; System.out.println(&quot;data:&quot; + data) ); return &quot;this is consumer,&quot; + str; &#125;&#125; 还是回到主题feign来 Feign自定义配置 # springboot默认日志日志级别logging.level.com.example=debug# default是全局配置，如果写服务名称，则是针对某个微服务的配置# 日志级别是 full#spring.cloud.openfeign.client.config.default.logger-level=fullspring.cloud.openfeign.client.config.user-service.logger-level=full 也可以使用java代码配置 import feign.Logger;import org.springframework.context.annotation.Bean;public class FeignClientConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; &#125;&#125; 如果希望这个配置在全局生效，在启动类上配置如下 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) 如果希望针对某个服务生效 @FeignClient(value = &quot;user-service&quot;,configuration = FeignClientConfiguration.class) 正常使用Basic即可，调试错误用Full，日志会对性能有影响 性能优化Feign底层的客户端实现: URLConnection:默认实现，不支持连接池 Apache HttpClient:支持连接池 OKHttp:支持连接池添加如下依赖&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;9.4.0&lt;/version&gt;&lt;/dependency&gt; # springboot默认日志日志级别logging.level.com.example=debugspring.cloud.openfeign.client.config.user-service.logger-level=basic# 开启对httpclient的支持spring.cloud.openfeign.httpclient.enabled=true# 最大连接数200spring.cloud.openfeign.httpclient.max-connections=200# 每个路径的最大连接数spring.cloud.openfeign.httpclient.max-connections-per-route=50 这两个值max-connections和max-connections-per-route的最佳选择还是需要使用压测工具来针对自己项目测试得出 最佳实践 Feign的最佳实践 方式一(继承):给消费者的FeignClient和提供者的controller定义统-的父接口作为标准。缺点 服务紧耦合 父接口参数列表中的映射不会被继承 方式二( 抽取) :将FeignClient抽取为独立模块,并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用缺点引用了过多的api，或许order只需要引入user的一两个api即可，但是现在却全部引入了 尝试一下方式二，现在再新建两个项目common和feign-api，将一些公共类抽取到common中，如实体类User或者Ordercommon&#x2F;pom.xml &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; @Data@AllArgsConstructor@NoArgsConstructorpublic class Order &#123; private Integer id; private String name; private Integer price; private Integer num; private Integer userId; private User user;&#125; @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String username; private String address;&#125; feign-api&#x2F;pom.xml 导入common依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; @FeignClient(value = &quot;user-service&quot;)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User findOne(@PathVariable(value = &quot;id&quot;) Integer id);&#125; import feign.Logger;import org.springframework.context.annotation.Bean;public class FeignClientConfiguration &#123; @Bean public Logger.Level feignLogLevel()&#123; return Logger.Level.BASIC; &#125;&#125; order&#x2F;pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;feign-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)@EnableDiscoveryClient@MapperScan(&quot;com.example.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.example.common.entity.User;import com.example.feign.api.UserFeignClient;import com.example.order.domain.Orders;import com.example.order.service.OrdersService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.*;import java.util.List;@RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125;&#125; 启动确报错 Consider defining a bean of type &#x27;com.example.feign.api.UserFeignClient&#x27; in your configuration. 因为包扫描的问题，order服务的默认包扫描在com.example.order下，但是feign-api的包在com.example.feign.api下建议选第二种 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class, basePackageClasses = &#123; UserFeignClient.class &#125;)@EnableDiscoveryClient@MapperScan(&quot;com.example.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 再次启动即可 Gateway入门为什么需要网关?网关功能: 身份认证和权限校验 服务路由、 负载均衡 请求限流在SpringCloud中网关的实现包括两种: gateway zuulZuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是 基于Spring5中提供的WebFlux,属于响应式编程的实现，具备更好的性能。 项目创建gateway&#x2F;pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; gateway&#x2F;application.yml 注意这里网关一定要和order、user服务加入到同一个nacos命名空间，否则会报503 而且要添加spring-cloud-loadbalancer的依赖，否则也会报503 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/**server: port: 8888 可以看到已经成功路由到order服务了 整个流程如下图所示路由配置包括 路由id:路由的唯一标示. 路由目标(uri):路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡 路由断言(predicates):判断路由的规则, 路由过滤器(filters):对请求或响应做处理 路由断言工厂我们在配置文件中写的断言规则只是字符串,这些字符串会被Predicate Factory读取并处理,转变为路由判断的条件例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的 详细查看spring官网 这里试一下After，如果不知道时间格式怎么写，可以使用如下方法打印 @Testvoid contextLoads() &#123; ZonedDateTime now = ZonedDateTime.now(); System.out.println(&quot;now = &quot; + now);&#125; spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** - After=2024-04-07T07:43:30.566635800+08:00[Asia/Shanghai]server: port: 8888 当路由中没有匹配的路由，就会报404无法路由 路由过滤器GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** filters: # 添加请求头 - AddRequestHeader=color,this is redserver: port: 8888 @RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id,@RequestHeader(&quot;color&quot;) String color) &#123; System.out.println(&quot;color = &quot; + color); Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125;&#125; 通过网关路由到order服务，order服务控制台打印color = this is red 如果希望配置所有网关都配置该过滤器，可以使用默认过滤器 默认过滤器对所有路由都生效 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** # 默认过滤器 default-filters: - AddRequestHeader=color,this is redserver: port: 8888 全局过滤器 全局过滤器的作用也是处理一-切进 入网关的请求和微服务响应，与GatewayFilter的作用一样。 区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。 感觉和default-filters很像，但是如果需要自定义一些复杂的逻辑，就得使用GatewayFilter了 定义方式是实现GatewayFilter接口 public interface GlobalFilter &#123; /** * Process the Web request and (optionally) delegate to the next &#123;@code WebFilter&#125; * through the given &#123;@link GatewayFilterChain&#125;. * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return &#123;@code Mono&lt;Void&gt;&#125; to indicate when request processing is complete */ Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125; 需求定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件: 参数中是否有authorization authorization参数值是否为admin 在gateway服务下新建AuthorizationFilter并实现GlobalFilter接口 整体步骤如下 public class AuthorizationFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 获取请求参数 // 获取参数中的authorization参数 // 判断参数值是否等于admin // 是，则放行。否，则拦截 return null; &#125;&#125; 具体实现如下 // 过滤器优先级，越小越高@Order(1)@Componentpublic class AuthorizationFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams(); // 获取参数中的 authorization 参数 String authorization = queryParams.getFirst(&quot;authorization&quot;); // 判断参数值是否等于admin if(&quot;admin&quot;.equals(authorization))&#123; // 是，则放行 return chain.filter(exchange); &#125; // 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 否，则拦截 return exchange.getResponse().setComplete(); &#125;&#125; 除了通过@Order注解来定义过滤器优先级，还可以实现Ordered接口来重写getOrder方法定义过滤器优先级 @Componentpublic class AuthorizationFilter implements GlobalFilter , Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams(); // 获取参数中的 authorization 参数 String authorization = queryParams.getFirst(&quot;authorization&quot;); // 判断参数值是否等于admin if(&quot;admin&quot;.equals(authorization))&#123; // 是，则放行 return chain.filter(exchange); &#125; // 设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 否，则拦截 return exchange.getResponse().setComplete(); &#125; @Override public int getOrder() &#123; return 1; &#125;&#125; 访问http://localhost:8888/order/1访问http://localhost:8888/order/1?authorization=admin 过滤器执行顺序 请求进入网关会碰到三类过滤器:当前路由的过滤器、DefaultFilter. GlobalFilter请求路由后，会将当前路由过滤器和DefaultFjlter、GlobalFilter, 合并到一个过滤器链(集合)中，排序后依次执行每个过滤器 在GatewayFilterAdapter中GatewayFilter被适配成了GatewayFilter 网关中的所有过滤器最终都是GatewayFilter过滤器执行顺序 每一个过滤器都必须指定一个int类型的order值， order值越小， 优先级越高，执行顺序越靠前。 GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定 路由过滤器和defaultFilter的order由Spring指定,默认是按照声明顺序从1递增。 当过滤器的order值一样时， 会按照defaultFilter &gt;路由过滤器&gt; GlobalFilter的顺序执行。 跨域问题处理 网关是基于WebFlux来实现的，之前的Servlet Api就无法使用了跨域:域名不一致就是跨域，主要包括: 域名不同: www.taobao.com 和www.taobao.org和www.jd.com和miaosha.jd.com 域名相同，端口不同: localhost:8080和localhost8081跨域问题:浏览器禁止请求的发起者与服务端发生跨域ajax请求,请求被浏览器拦截的问题网关处理跨域采用的同样是CORS方案,并且只需要简单配置即可实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;spring: cloud: gateway: globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: &#x27;[/**]&#x27;: allowedOrigins: # 允许哪些网站的跨域请求 - &quot;http://localhost:8090&quot; - &quot;http://www.leyou.com&quot; allowedMethods: # 允许的跨域ajax的请求方式 - &quot;GET&quot; - &quot;POST&quot; - &quot;DELETE&quot; - &quot;PUT&quot; - &quot;OPTIONS&quot; allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期&lt;/pre&gt;&lt;/body&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; axios.get(&quot;http://localhost:10010/user/1?authorization=admin&quot;) .then(resp =&gt; console.log(resp.data)) .catch(err =&gt; console.log(err))&lt;/script&gt;&lt;/html&gt; 使用VS Code启动配置 spring: cloud: gateway: globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: &#x27;[/**]&#x27;: allowedOrigins: # 允许哪些网站的跨域请求 - &quot;http://localhost:8090&quot; - &quot;http://www.leyou.com&quot; allowedMethods: # 允许的跨域ajax的请求方式 - &quot;GET&quot; - &quot;POST&quot; - &quot;DELETE&quot; - &quot;PUT&quot; - &quot;OPTIONS&quot; allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期 没用，依然报错跨域问题 由于spring-framework从5.3.0版本开始，关于CORS跨域配置类 CorsConfiguration中将 allowedOrigins 变量名修改为 allowedOriginPatterns 所以，如果项目中 spring-framework 版本高于5.3.0，请使用如下配置代码 spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** default-filters: - AddRequestHeader=color,this is red globalcors: # 全局的跨域处理 add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题 corsConfigurations: &#x27;[/**]&#x27;: allowedOriginPatterns: # 允许哪些网站的跨域请求 - &quot;http://localhost:8090&quot; - &quot;http://localhost:5500&quot; - &quot;http://www.leyou.com&quot; allowedMethods: # 允许的跨域ajax的请求方式 - &quot;GET&quot; - &quot;POST&quot; - &quot;DELETE&quot; - &quot;PUT&quot; - &quot;OPTIONS&quot; allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带cookie maxAge: 360000 # 这次跨域检测的有效期,一定时间内不需要在验证跨域，直接访问server: port: 8888","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://isunderachiever.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://isunderachiever.github.io/tags/SpringCloud/"}]},{"title":"Sentinel","slug":"编程语言/Java/学习/框架/Sentinel/Sentinel","date":"2024-04-10T00:00:00.000Z","updated":"2024-06-01T14:32:53.515Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/sentinel/sentinel.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/sentinel/sentinel.html","excerpt":"","text":"Sentinel初识Sentinel雪崩问题 故障的服务D，会导致服务A的tomcat资源耗尽 微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。解决雪崩问题的常见方式有四种: 超时处理:设定超时时间，请求超过-定时间没有响应就返回错误信息，不会无休止等待 舱壁模式:限定每个业务能使用的线程数,避免耗尽整个tomcat的资源，因此也叫线程隔离。 熔断降级:由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。 流量控制:限制业务访问的QPS，避免服务因流量的突增而故障。 技术选型 同类型的框架还有Resilience4j、Polly、Envoy等 安装SentinelSentinel下载地址，选择sentinel-dashboard-xxx.jar，自己新建一个startup.txt java -jar sentinel-dashboard-1.8.5.jar 然后将startup.txt后缀改为bat，双击运行 或者自定义启动端口号 java -Dserver.port=8718 -jar sentinel-dashboard-1.8.5.jar 账号密码默认是sentinel配置开机自启动博客链接 创建项目 在order服务导入sentinel依赖，并配置application.properties然后访问一下order服务的controller http://localhost:8090/order/1 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; # 配置控制台地址spring.cloud.sentinel.transport.dashboard=localhost:8089 sentinel主要采用线程池隔离、熔断降级、流量控制的方式来解决雪崩问题 簇点链路簇点链路:就是项目内的调用链路,链路中被监控的每个接口就是一个资源。 默认情况下sentinel会监控SpringMVC的每一个端点(Endpoint) ，因此SpringMVC的每一个端点(Endpoint)就是调用链路中的一-个资源。流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则:需求:给&#x2F;order&#x2F;{orderld}这个资源设置流控规则，QPS不能超过5。然后进行压力测试。 流控模式 在添加限流规则时，点击高级选项，可以选择三种流控模式: 直接:统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式 关联:统计与当前资源相关的另一一个资源，触发阈值时，对当前资源限流 链路:统计从指定链路访问到本资源的请求，触发阈值时,对指定链路限流 关联模式统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流使用场景:比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁,产生竞争。业务需求是有限支付和更新订单的业务,因此当修改订单业务触发阈值时，需要对查询订单业务限流，防止影响到更新订单的业务。需求 在OrderController新建两个端点: /order/query和/order/update, 无需实现业务 配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流@RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125; @GetMapping(&quot;/query&quot;) public String query() &#123; return &quot;查询订单成功&quot;; &#125; @GetMapping(&quot;/update&quot;) public String update() &#123; return &quot;更新订单成功&quot;; &#125;&#125; 然后访问一下 http://localhost:8090/order/query 和 http://localhost:8090/order/update、 对/order/query添加流控对update压力测试，限流query 满足下面条件可以使用关联模式: 两个有竞争关系的资源 一个优先级较高，一个优先级较低，我们希望当优先级高的触发阈值时，对优先级低的进行限流 链路模式链路模式:只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。例如有两条请求链路:&#x2F;test1 -&gt; &#x2F;common&#x2F;test2 -&gt; &#x2F;common如果只希望统计从&#x2F;test2进入到&#x2F;common的请求，则可以这样配置:需求:有查询订单和创建订单业务,两者都需要查询商品。针对从查询订单进入到查询商品的请求统计并设置限流。步骤: 在OrderService 中添加一个queryGoods方法，不用实现业务 在OrderController中 ，改造&#x2F;order&#x2F;query端点，调用OrderService中的queryGoods方法 在OrderController中 添加一个&#x2F;order&#x2F;save的端 点,调用OrderService的queryGoods方法 给queryGoods设 置限流规则,从&#x2F;order&#x2F;query进 入queryGoods的方法限制QPS必须小于2@Servicepublic class OrdersServiceImpl extends ServiceImpl&lt;OrdersMapper, Orders&gt; implements OrdersService&#123; @Override public void queryGoods() &#123; System.out.println(&quot;查询商品成功&quot;); &#125;&#125; @RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125; @GetMapping(&quot;/query&quot;) public String query() &#123; ordersService.queryGoods(); return &quot;查询订单成功&quot;; &#125; @GetMapping(&quot;/update&quot;) public String update() &#123; return &quot;更新订单成功&quot;; &#125; @GetMapping(&quot;/save&quot;) public String save() &#123; ordersService.queryGoods(); return &quot;创建订单成功&quot;; &#125;&#125; 而service中的queryGoods()并没有被sentinel监控，无法配置限流规则，所以应该对其进行监控Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解 @Servicepublic class OrdersServiceImpl extends ServiceImpl&lt;OrdersMapper, Orders&gt; implements OrdersService&#123; @SentinelResource(&quot;goods&quot;) @Override public void queryGoods() &#123; System.out.println(&quot;查询商品成功&quot;); &#125;&#125; Sentinel默认会将Controller方法做context整合,导致链路模式的流控失效当 Sentinel 默认开启 web-context-unify 时，会将所有 Controller 方法的上下文路径进行整合，这意味着所有通过 Controller 的调用都会被视作一个统一的资源路径，这可能会导致链路模式下的流控规则失效。具体来说，假设你有一个服务内部有多个接口相互调用形成了一条调用链路，如 /save -&gt; /goods 和 /query -&gt; /goods，如果你想要针对 /query 调用到 /goods 的这条特定调用链路设置流量控制，那么在 context 整合的情况下，Sentinel 无法区分这两个不同的调用链路，因为它们在上下文路径上都被视为同一个资源。需要修改application.properties,添加配置# 配置控制台地址spring.cloud.sentinel.transport.dashboard=localhost:8089# 关闭 context 整合spring.cloud.sentinel.web-context-unify=false 如果不关闭context整合，所有的controller会被认为是同一个根链路发展而来的子链路 访问一下 http://localhost:8090/order/query 和 http://localhost:8090/order/save删除其他的流控规则使用Jmeter进行压力测试&#x2F;order&#x2F;save&#x2F;order&#x2F;query总结直接:对当前资源限流关联:高优先级资源触发阈值，对低优先级资源限流。链路:阈值统计时，只统计从指定资源进入当前资源的请求是对请求来源的限流 流控效果概念流控效果是指请求达到流控阈值时应该采取的措施，包括三种: 快速失败:达到阈值后，新的请求会被立即拒绝并拋出FlowException异常。是默认的处理方式。 warm up:预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一-个较小值逐渐增加到最大阈值。 排队等待:让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长 预热模式warm upwarm up也叫预热模式，是应对服务冷启动的一种方案。threshold为最大阈值，coldFactor为冷启动因子，请求阈值初始值是threshold/coldFactor,持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3.例如，我设置QPS的threshold为10，预热时间为5秒,那么初始阈值就是10/3，也就是3,然后在5秒后逐渐增长到10需求给/order/&#123;id&#125;这个资源设置限流,最大QPS为10,利用warm up效果,预热时长为5秒 排队等待当请求超过QPS阈值时，快速失败和warm up会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中,然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长,则会被拒绝。例如: QPS&#x3D;5,意味着每200ms处理一个队列中的请求; timeout &#x3D; 2000， 意味着预期等待超过2000ms的请求会被拒绝并抛出异常需求给/order/&#123;id&#125;这个资源设置限流，最大QPS为10， 利用排队的流控效果，超时时长设置为5s 而Jmeter配置的QPS是15，如果按照之前的情况（直接失败），则会有5个QPS无法处理到后面请求超时则会直接失败 总结流控效果有哪些？ 快速失败: QPS超过阈值时，拒绝新的请求 warm up: QPS超过阈值时，拒绝新的请求; QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。 排队等待:请求会进入队列，按照阈值允许的时间间隔依次执行请求;如果请求预期等待时长大于超时时间，直接拒绝 热点参数限流 之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求,判断是否超过QPS阈值。案例 给/order/&#123;id&#125;这个资源添加热点参数限流，规则如下: 默认的热点参数规则是每1秒请求量不超过2 给1这个参数设置例外:每1秒请求量不超过4 给2这个参数设置例外:每1秒请求量不超过10 需要注意的是热点参数限流对默认的SpringMVC资源无效，只有通过@SentinelResource注解声明的资源才能生效 @RefreshScope@RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @Autowired private UserFeignClient userFeignClient; @SentinelResource(&quot;hot&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; Orders orders = ordersService.getById(id); User user = userFeignClient.findOne(orders.getUserId()); orders.setUser(user); return orders; &#125;&#125; 可以看到/order/1的QPS是4可以看到/order/2的QPS是10，全部通过可以看到/order/3的QPS是默认阈值，即2 隔离和降级 虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离(舱壁模式)和熔断降级手段了。 不管是线程隔离还是熔断降级,都是对客户端(调用方，示例中的服务A)的保护。SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。 修改OrderService的application.properties文件，开启Feign的Sentinel功能 feign.sentinel.enabled=true 给FeignClient编写失败后的降级逻辑，但调用的服务异常时，返回备用方案 方式一: FallbackClass,无法对远程调用的异常做处理 方式二: FallbackFactory,可以对远程调用的异常做处理，我们选择这种 在feign-api项目中定义类，实现FallbackFactory 不少教程导入的是hystrix包下的FallbackFactory，但是sentinel已经不再使用hystrix依赖了，而openfeign包下也有一个FallbackFactory 不确定是不是这个原因导致后文报错 @Slf4jpublic class UserClientFallbackFactory implements FallbackFactory&lt;UserFeignClient&gt; &#123; @Override public UserFeignClient create(Throwable cause) &#123; return new UserFeignClient() &#123; @Override public User findOne(Integer id) &#123; log.info(&quot;findOne方法异常，执行降级逻辑&quot;); return new User(); &#125; &#125;; &#125;&#125; 在feign-api项目中将UserClientFallbackFactory注册为一个Bean:这里没有加@Configuration注解是因为在OrderApplication配置了@EnableFeignClients public class FeignClientConfiguration &#123; @Bean public Logger.Level feignLogLevel() &#123; return Logger.Level.BASIC; &#125; @Bean public UserClientFallbackFactory userClientFallbackFactory() &#123; return new UserClientFallbackFactory(); &#125;&#125; @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class, basePackageClasses = &#123; UserFeignClient.class &#125;)@EnableDiscoveryClient@MapperScan(&quot;com.example.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 在feign-api项目中的UserClient接口中使用UserClientFallbackFactory: @FeignClient(value = &quot;user-service&quot;,fallbackFactory = UserClientFallbackFactory.class)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User findOne(@PathVariable(value = &quot;id&quot;) Integer id);&#125; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;consumerController&#x27;: Unsatisfied dependency expressed through field &#x27;providerClient&#x27;: Error creating bean with name &#x27;feignSentinelBuilder&#x27; defined in class path resource [com/alibaba/cloud/sentinel/feign/SentinelFeignAutoConfiguration.class]: Post-processing of merged bean definition failedCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;feignSentinelBuilder&#x27; defined in class path resource [com/alibaba/cloud/sentinel/feign/SentinelFeignAutoConfiguration.class]: Post-processing of merged bean definition failedCaused by: java.lang.IllegalStateException: Failed to introspect Class [com.alibaba.cloud.sentinel.feign.SentinelFeign$Builder] from ClassLoader [jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b]Caused by: java.lang.NoClassDefFoundError: org/springframework/cloud/openfeign/FeignClientFactoryCaused by: java.lang.ClassNotFoundException: org.springframework.cloud.openfeign.FeignClientFactory at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) ~[na:na] at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) ~[na:na] 这里整合feign各种报错，估计是版本原因 我尝试使用2.3.12.RELEASE的springboot是可以实现feign + nacos + sentinel的(还是jdk17) demo链接放到github上了，链接 做了个springboot3、nacos、openfeign、sentinel的demo，还是上面的这个链接，请切换boot3版本 springboot3报错解决，不使用UserClientFallbackFactory，删除该文件，feign.sentinel.enabled配置也删除 使用@SentinelResource配合blockHandler属性在服务被调用方新增 @RestController@RequestMapping(&quot;provider&quot;)public class ProviderController &#123; @SentinelResource(value = &quot;providerQuery&quot;,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/query&quot;) public String query()&#123; return &quot;query...&quot;; &#125; public static String blockHandler(BlockException e) &#123; return &quot;请稍后再试！&quot;; &#125;&#125; 添加流控规则访问provider服务 访问provider自然是没有问题的，关键是consumer那边怎么样可以，也被限流了 需要注意的是blockHandler指定的方法返回值要和被标记@SentinelResource的方法(这里是query)保持一致，得是String 否则会报错如下 com.alibaba.csp.sentinel.slots.block.flow.FlowException: null 我们希望能同意来配置，而不是每个类都写一个单独的限流方法 /** * 全局限流处理 * @author: 不是菜狗爱编程 * @date: 2024/04/10/7:27 * @description: */public class GlobeBlockException &#123; public static String blockHandler(BlockException e) &#123; return &quot;您访问太频繁了，请稍后再试！&quot;; &#125;&#125; @RestController@RequestMapping(&quot;provider&quot;)public class ProviderController &#123; @SentinelResource(value = &quot;providerQuery&quot;,blockHandlerClass = GlobeBlockException.class, blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/query&quot;) public String query()&#123; return &quot;query...&quot;; &#125;&#125; 以上代码在github中，链接 注意切换boot3分支，main分支使用的是2.3.12.RELEASE版本springboot，2.3.12.RELEASE版本springboot可以正常使用自定义FallbackFactory类 以上是关于大概的解法，下面展示order和user模块的写法user模块注意这里设置的blockHandler方法参数要比@SentinelResource标记的方法参数多一个BlockException，其它参数保持一致 public class GlobeBlockException &#123; public static User blockHandler(@PathVariable Integer id,BlockException e) &#123; return new User(); &#125;&#125; @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @SentinelResource(value = &quot;userQueryById&quot;,blockHandlerClass = GlobeBlockException.class,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public User findOne(@PathVariable Integer id) &#123; return userService.getById(id); &#125;&#125; 又出现一个问题，springboot启动多个user实例，但是sentinel设置限流规则后只对其中一个实例有效看sentinel界面 在这里设置多个即可order也有效 线程隔离 左侧是线程隔离，右侧是信号量隔离对比将原本的QPS换成线程数即可需求给UserClient的查询用户接口设置流控规则，线程数不能超过2。然后利用jemeter测试。这里的请求都是正常，因为之前配置了降级的逻辑，所以会直接返回一个空的user对象，而不是报错 熔断降级概念熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求;而当服务恢复时,断路器会放行访问该服务的请求。 熔断策略–慢调用断路器熔断策略有三种:慢调用、异常比例、异常数慢调用:业务的响应时长(RT)大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如:解读: RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次,并且慢调用比例不低于0.5则触发熔断，熔断时长为5秒。然后进入half-open状态,放行一次请求做测试。需求 给UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms,统计时间为1秒，最小请求数量为5，失败阈值比例为0.4,熔断时长为5 为了增加业务耗时，可以设置Thread.sleep(60) @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @SentinelResource(value = &quot;userQueryById&quot;,blockHandlerClass = GlobeBlockException.class,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public User findOne(@PathVariable Integer id) &#123; try &#123; Thread.sleep(60); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; return userService.getById(id); &#125;&#125; 此时我们正常的响应时间是71ms快速访问多次后熔断，熔断之后已经不再去尝试了，而是直接返回失败结果，这里的时间为4ms服务的调用方响应如下针对多实例也有效 熔断策略–异常比例、异常数异常比例或异常数:统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值(或超过指定异常数) ,则触发熔断。例如:解读:统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.5,则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次 请求做测试。 故意抛出异常即可 @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @SentinelResource(value = &quot;userQueryById&quot;,blockHandlerClass = GlobeBlockException.class,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public User findOne(@PathVariable Integer id) &#123; if(id==2)&#123; throw new RuntimeException(&quot;抛出异常了&quot;); &#125; return userService.getById(id); &#125;&#125; 如果觉得直接返回报错不太友好，可以使用@RestControllerAdvice来进行统一的异常处理，这里不过多介绍这个注解，先看看熔断是否生效再看看order服务调用是否正常 总结Sentinel熔断降级的策略有哪些?慢调用比例:超过指定时长的调用为慢调用，统计单位时长内慢调用的比例，超过阈值则熔断异常比例:统计单位时长内异常调用的比例，超过阈值则熔断异常数:统计单位时长内异常调用的次数,超过阈值则熔断 授权规则 当时在gateway网关的时候有做过过滤，可以阻止某些请求通过网关路由到微服务 但如果有一天微服务的地址及端口被泄露出去了，请求就可能不通过网关，直接访问服务的的地址，这个时候微服务就很危险了授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。白名单:来源(origin) 在白名单内的调用者允许访问黑名单:来源(origin)在黑名单内的调用者不允许访问例如，我们限定只允许从网关来的请求访问order-service，不允许浏览器来直接访问,那么流控应用中就填写网关的名称.这里的流控应用其实不是指的网关服务的名称，而是指的orign请求来源的名称Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。而sentinel默认情况下，从gateway和浏览器到达的orign名称都是default，无法对网关和浏览器进行区分所以需要实现RequestOriginParser该接口来自定义实现，比如 @Componentpublic class HeaderOriginParser implements RequestOriginParser &#123; @Override public String parse0rigin(HttpServletRequest request) &#123; String origin = request. getHeader(&quot;origin&quot;) ; if(Str ingUtils. isEmpty(origin))&#123; return &quot;blank&quot;; &#125; return origin; &#125;&#125; 但现实是网关和浏览器默认都没有origin请求头，而我们给网关来的请求添加上origin即可 网关过滤器AddRequestHeader可以实现，这里直接写成默认过滤器，所有经过网关的请求都添加上origin头 spring: cloud: gateway: default-filters: #添加名为origin的请求头，值为gateway -AddRequestHeader=origin,gateway 所以流控应用就填gateway，注意这里的值，即gateway不要暴露了理论结束，实践开始order服务 @Slf4j@Componentpublic class HeadOriginParser implements RequestOriginParser &#123; @Override public String parseOrigin(HttpServletRequest httpServletRequest) &#123; // 获取请求头 String origin = httpServletRequest.getHeader(&quot;origin&quot;); // 判空 if(!StringUtils.hasLength(origin))&#123; // origin为空 origin=&quot;blank&quot;; &#125; log.info(&quot;当前请求:&#123;&#125;,origin请求头:&#123;&#125;&quot;,httpServletRequest.getRequestURI(),origin); return origin; &#125;&#125; 网关服务配置，主要是- AddRequestHeader=origin,gateway spring: application: name: gateway-service cloud: nacos: config: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c import-check: enabled: false discovery: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c gateway: # 网关路由配置 routes: # 路由id，自定义唯一即可 - id: user-service # 目标路由地址，这种方式用的较少 # uri: http://localhost:8080 # lb就是LoadBalancer，负载均衡的意思，后面是服务名称 uri: lb://user-service # 路由断言，判断请求是否符合路由规则条件 predicates: # 路径匹配。匹配以/user/开头的路由 - Path=/user/** - id: order-service uri: lb://order-service predicates: - Path=/order/** default-filters:# - AddRequestHeader=color,this is red - AddRequestHeader=origin,gateway 通过网关服务访问直接访问 自定义异常结果默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口 判断这里异常的类型，然后返回自定义结果而BlockException包含很多个子类，分别对应不同的场景:具体写法可参考order服务 @Componentpublic class SentinelBlockHandler implements BlockExceptionHandler &#123; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception &#123; String msg = &quot;未知异常&quot;; int status = 429; if (e instanceof FlowException) &#123; msg = &quot;请求被限流了! &quot;; &#125; else if (e instanceof DegradeException) &#123; msg = &quot;请求被降级了! &quot;; &#125; else if (e instanceof ParamFlowException) &#123; msg = &quot;热点参数限流! &quot;; &#125; else if (e instanceof AuthorityException) &#123; msg = &quot;请求没有权限! &quot;; status = 401; &#125; httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;); httpServletResponse.setStatus(status); httpServletResponse.getWriter().println(&quot;&#123;\\&quot;message\\&quot;: \\&quot;&quot; + msg + &quot;\\&quot;， \\&quot;status\\&quot;: &quot; + status + &quot;&#125;&quot;); &#125;&#125; 重启服务后新建授权规则也可以使用@SentinelResource注解方式 @RestController@RequestMapping(&quot;order&quot;)public class OrdersController &#123; @Autowired private OrdersService ordersService; @SentinelResource(value = &quot;orderFindOne&quot;,blockHandlerClass = GlobeBlockException.class,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public Orders findOne(@PathVariable Integer id) &#123; return ordersService.queryByOrderId(id); &#125;&#125; @Slf4jpublic class GlobeBlockException &#123; public static Orders blockHandler(@PathVariable Integer id, BlockException e) &#123; log.error(&quot;当前服务繁忙，请稍后再试&quot;); return new Orders(); &#125;&#125; 配置授权规则虽然只能返回与使用@SentinelResource注解标注的方法相同的返回值类型，但是在springboot的restful风格的api中，我们通常会统一返回结果如JsonData或者R等统一返回值类型 规则持久化概念Sentinel的控制台规则管理有三种模式: 原始模式: Sentinel的默认模式，将规则保存在内存,重启服务会丢失。 pull模式 push模式 pull模式pull模式:控制台将配置的规则推送到Sentinel客户端,而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。 由于是定时轮询读取，所以存在时效性问题，导致了服务中规则不一致的问题 push模式push模式:控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户 端监听Nacos,获取配置变更的推送消息，完成本地配置更新。 总结Sentinel的三种配置管理模式是什么? 原始模式:保存在内存 pull模式:保存在本地文件或数据库，定时去读取 push模式:保存在nacos，监听变更实时更新 实现push模式 参考博客push模式实现最为复杂，依赖于nacos,并且需要修改Sentinel控制台源码。引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-datasource&lt;/artifactId&gt;&lt;/dependency&gt; 配置nacos地址 示例如下 spring: cloud: sentinel: datasource: flow: nacos: # nacos地址 server-addr: localhost:8848 dataId: orderservice-flow-rules groupId: SENTINEL_GROUP #还可以是: degrade(降级)、authority(授权)、 param-flow(参数限流) rule-type: flow # 如果需要多个配置，继续添加即可，如下所示 degrade: nacos: server-addr: localhost:8848 dataId: orderservice-degrade-rules groupId: SENTINEL_GROUP rule-type: degrade 以上是配置格式，接下来正式配置user server: port: 8080spring: application: name: user-service cloud: nacos: config: file-extension: properties namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c prefix: $&#123;spring.application.name&#125; server-addr: localhost:8848 discovery: cluster-name: JS ephemeral: false namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8089 web-context-unify: false datasource: flow: nacos: server-addr: localhost:8848 namespace: d2455f6d-ed00-41ba-9915-09021bc0df6c data-id: user-service-sentinel group-id: DEFAULT_GROUP data-type: json #还可以是: degrade(降级)、authority(授权)、 param-flow(参数限流) rule-type: flow config: import: nacos:$&#123;spring.cloud.nacos.config.prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;?refresh=true profiles: active: dev 上面配置中，sentinel规则配置到nacos dataId为user-service-sentinel的配置中了 [ &#123; &quot;resource&quot;: &quot;userQueryById&quot;, &quot;controlBehavior&quot;: 0, &quot;count&quot;: 5, &quot;grade&quot;: 1, &quot;limitApp&quot;: &quot;default&quot;, &quot;strategy&quot;: 0 &#125;] 以上配置是指 resource：资源名。limitApp：来源应用。grade：阈值类型。0 表示线程数，1 表示是QPS。count：单机阈值。strategy：流控模式。0 表示直接，1 表示关联，2 表示链路。controlBehavior：流控效果。0 表示快速失败，1 表示Warm up，2 表示排队等待。clusterMode：是否集群。false 表示否，true 表示是。**这里选择resource为userQueryById**，因为@SentinelResource标记资源为userQueryById还记得吗？ @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @SentinelResource(value = &quot;userQueryById&quot;,blockHandlerClass = GlobeBlockException.class,blockHandler = &quot;blockHandler&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public User findOne(@PathVariable Integer id) &#123; if(id==2)&#123; throw new RuntimeException(&quot;抛出异常了&quot;); &#125; return userService.getById(id); &#125;&#125; 测试一下是否可行order也没问题重启服务，查看sentinel控制台，规则是否还存在但是有个需要注意的点，这是sentinel读nacos配置的规则，而在sentinel中配置的规则，不能同步到nacos 如果需要让sentinel的配置同步到nacos，nacos修改的配置sentinel也能获取到，则需要修改sentinel-dashboard.jar的源码了 网上也有教程","categories":[{"name":"Sentinel","slug":"Sentinel","permalink":"https://isunderachiever.github.io/categories/Sentinel/"}],"tags":[{"name":"Sentinel","slug":"Sentinel","permalink":"https://isunderachiever.github.io/tags/Sentinel/"}]},{"title":"RabbitMQ","slug":"编程语言/Java/学习/框架/RabbitMq/RabbitMq","date":"2024-04-03T00:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/rabbitmq/rabbitmq.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/rabbitmq/rabbitmq.html","excerpt":"","text":"RabbitMQ 以下具体内容参考自黑马程序员课程微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程 初识MQ同步调用微服务间基于Feign的调用就属于同步方式，存在一些问题。业务代码耦合严重，除此之外对性能影响也很严重，因为需要等待被调用的服务返回结果。不仅如此，而且如果被调用的服务中，有某个服务挂了，则整个服务调用都会出现问题。 异步调用异步调用常见实现就是事件驱动模式优势 前三个解决了同步调用的问题 服务解耦，现在只需要发送成功事件即可，不需要更改业务代码 性能提高，吞吐量升高， 服务没有强依赖，无需担心级联失败问题 流量削峰，broker能起到缓冲的作用，右侧的服务则按照自身能力来获取broker的事件劣势 异步通信的缺点 依赖于Broker的可靠性、安全性、吞吐能力 架构复杂了，业务没有明显的流程线，不好追踪管理 MQ选型安装步骤省略rabbitmq的管理界面的端口为15672http://localhost:15672管理员的账号和密码是guest Overview Overview是总览，可以看到MQ的节点信息，当前为单节点运行，并不存在集群 Connections 无论是消息的发布者还是消息的消费者都需要与MQ建立连接 Channels Channels是通道，在建立连接后需要创建Channels通道，然后消息的发布者和消息的消费者才能基于Channels完成消息的发布和消费 Exchanges Exchanges交换机用于接收来自生产者的消息，将它们推入队列 Queues Queues队列用来做消息存储 Admin MQ架构 常见消息模型 基本消息队列和工作消息队列没有使用到交换机，属于简单队列模型 基本消息队列(BasicQueue) 工作消息队列(WorkQueue) 发布订阅( Publish、Subscribe )，又根据交换机类型不同分为三种 Fanout Exchange:广播 Direct Exchange:路由 Topic Exchange:主题 基本消息队列 这里建立的项目结构如下 rabbitmq-demo├─consumer│ └─src│ ├─main│ │ └─resources│ └─test└─publisher └─src ├─main │ ├─java │ └─resources └─test 父级pom &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;rabbitmq-demo&lt;/name&gt; &lt;description&gt;rabbitmq-demo&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;module&gt;publisher&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; publisher &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;publisher&lt;/artifactId&gt; &lt;name&gt;publisher&lt;/name&gt; &lt;description&gt;publisher&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; consumer与publisher一样，改名字即可 发送和监听消息的示例代码如下 需要注意的是：RabbitMQ的端口是5672，管理页面端口才是15672，这里端口需要写5672 import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */class SendMessageTest &#123; @Test void sendMessageTest() throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(&quot;localhost&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/&quot;); factory.setUsername(&quot;tong&quot;); factory.setPassword(&quot;123456&quot;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = &quot;simple.queue&quot;; channel.queueDeclare(queueName, false, false, false, null); // 4.发送消息 String message = &quot;hello, rabbitmq!&quot;; channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes()); System.out.println(&quot;发送消息成功：【&quot; + message + &quot;】&quot;); // 5.关闭通道和连接 channel.close(); connection.close(); &#125;&#125; import com.rabbitmq.client.*;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * RabbitMQ监听消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */class ListenMessageTest &#123; @Test void listenMessageTest() throws IOException, TimeoutException &#123; // 1.建立连接 ConnectionFactory factory = new ConnectionFactory(); // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码 factory.setHost(&quot;localhost&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/&quot;); factory.setUsername(&quot;tong&quot;); factory.setPassword(&quot;123456&quot;); // 1.2.建立连接 Connection connection = factory.newConnection(); // 2.创建通道Channel Channel channel = connection.createChannel(); // 3.创建队列 String queueName = &quot;simple.queue&quot;; channel.queueDeclare(queueName, false, false, false, null); // 4.订阅消息 channel.basicConsume(queueName, true, new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; // 5.处理消息 String message = new String(body); System.out.println(&quot;接收到消息：【&quot; + message + &quot;】&quot;); &#125; &#125;); System.out.println(&quot;等待接收消息。。。。&quot;); &#125;&#125; 基本消息队列的消息发送流程: 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息基本消息队列的消息接收流程: 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 SpringAMQP特征 侦听器容器，用异步处理入站消息 用于发送和接收消息的RabbitTemplate RabbitAdmin用于自动声明队列，交换机和绑定关系案例流程如下 在父工程中引入spring-amqp的依赖 在publisher服务中利用RabbitTemplate发送消息到simple.queue这个队列 在consumer服务中编写消费逻辑，绑定simple.queue这个队列import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import org.junit.jupiter.api.Test;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */@SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test void sendMessageWithRabbitMqTemplateTest()&#123; String queueName=&quot;simple.queue&quot;; String message=&quot;你好，这是【RabbitTemplate】发送的消息&quot;; rabbitTemplate.convertAndSend(queueName,message); &#125;&#125; application.properties # 主机名 192.168.XXX.XXXspring.rabbitmq.host=localhost# 端口spring.rabbitmq.port=5672# 虚拟主机spring.rabbitmq.virtual-host=/spring.rabbitmq.username=tongspring.rabbitmq.password=123456 点击simple.queueconsumer工程的properties也同样配置 @Slf4j@Componentpublic class RabbitMqListener &#123; /** * 简单队列侦听器 * 消息发送者发送的是字符串，所以这边也适用字符串来接收 * @param message 消息 */ @RabbitListener(queues = &#123;&quot;simple.queue&quot;&#125;) public void simpleQueueListener(String message)&#123; log.info(&quot;接收到的消息为:&#123;&#125;&quot;,message); &#125;&#125; 启动consumer工程后接收到消息发现消息消失了，因为这是MQ的机制，阅后即焚，消息不可重复消费 工作消息队列 两个消费者共同消费生产者发布的消息，由于消息阅后即焚的特性，所以只能消费者1消费一部分消息，消费者2消费一部分消息但是当发布的消息过多，两个消费者的能力不足，则多余的消息就会堆积在队列里当队列存储的消息达到上限时，则会发生消息丢失 **工作队列**，可以提高消息处理速度，避免队列消息堆积实现思路如下 在publisher服务中定义测试方法，每秒产生50条消息，发送到simple.queue的 在consumer服务中定义两个消息监听者，都监听simple.queue队列 消费者1每秒处理50条消息，消费者2每秒处理10条消息所以照理来说，消费者应该能在1s内消费完消息@SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 使用工作队列测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithWorkQueueTest() throws InterruptedException &#123; String queueName=&quot;simple.queue&quot;; String message=&quot;你好，这是消息&quot;; for (int i = 0; i &lt; 50; i++) &#123; rabbitTemplate.convertAndSend(queueName,message+i); Thread.sleep(20); &#125; &#125;&#125; @Slf4j@Componentpublic class RabbitMqListener &#123; /** * 工作队列侦听器1 * * @param message 消息 */ @RabbitListener(queues = &#123;&quot;simple.queue&quot;&#125;) public void workQueueListener1(String message) throws InterruptedException &#123; log.info(&quot;工作队列侦听器1:接收到的消息为:&#123;&#125;&quot;,message); Thread.sleep(20); &#125; /** * 工作队列侦听器2 * * @param message 消息 */ @RabbitListener(queues = &#123;&quot;simple.queue&quot;&#125;) public void workQueueListener2(String message) throws InterruptedException &#123; log.info(&quot;工作队列侦听器2:接收到的消息为:&#123;&#125;&quot;,message); Thread.sleep(200); &#125;&#125; 打印日志如下 2024-04-02T21:31:56.431+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息02024-04-02T21:31:56.456+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息12024-04-02T21:31:56.518+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息32024-04-02T21:31:56.580+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息52024-04-02T21:31:56.641+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息22024-04-02T21:31:56.641+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息72024-04-02T21:31:56.705+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息92024-04-02T21:31:56.767+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息112024-04-02T21:31:56.830+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息132024-04-02T21:31:56.845+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息42024-04-02T21:31:56.893+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息152024-04-02T21:31:56.956+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息172024-04-02T21:31:57.018+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息192024-04-02T21:31:57.049+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息62024-04-02T21:31:57.081+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息212024-04-02T21:31:57.145+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息232024-04-02T21:31:57.208+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息252024-04-02T21:31:57.253+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息82024-04-02T21:31:57.269+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息272024-04-02T21:31:57.333+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息292024-04-02T21:31:57.397+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息312024-04-02T21:31:57.458+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息102024-04-02T21:31:57.460+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息332024-04-02T21:31:57.522+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息352024-04-02T21:31:57.584+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息372024-04-02T21:31:57.651+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息392024-04-02T21:31:57.662+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息122024-04-02T21:31:57.710+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息412024-04-02T21:31:57.775+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息432024-04-02T21:31:57.837+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息452024-04-02T21:31:57.867+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息142024-04-02T21:31:57.900+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息472024-04-02T21:31:57.963+08:00 INFO 9600 --- [ntContainer#1-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器1:接收到的消息为:你好，这是消息492024-04-02T21:31:58.070+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息162024-04-02T21:31:58.276+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息182024-04-02T21:31:58.481+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息202024-04-02T21:31:58.687+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息222024-04-02T21:31:58.889+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息242024-04-02T21:31:59.096+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息262024-04-02T21:31:59.301+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息282024-04-02T21:31:59.507+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息302024-04-02T21:31:59.712+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息322024-04-02T21:31:59.917+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息342024-04-02T21:32:00.119+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息362024-04-02T21:32:00.321+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息382024-04-02T21:32:00.525+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息402024-04-02T21:32:00.730+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息422024-04-02T21:32:00.946+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息442024-04-02T21:32:01.150+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息462024-04-02T21:32:01.353+08:00 INFO 9600 --- [ntContainer#0-1] c.e.consumer.listener.RabbitMqListener : 工作队列侦听器2:接收到的消息为:你好，这是消息48 根据日志打印的时间得知，消息处理的时间为5s，但我们预计的时间是1s 这是因为由于rabbitmq的预取机制，会在消息消费前先平分获取到消息，但消息被消费者A获取后，其他的消费者就无法再消费这些消息了 所以这里可以看到工作队列侦听器1和工作队列侦听器2都各自消费了25条消息，且工作队列侦听器1消费的是奇数，工作队列侦听器2则是偶数 添加如下配置即可解决 # 应用服务 WEB 访问端口server.port=8090# 主机名 192.168.XXX.XXXspring.rabbitmq.host=localhost# 端口spring.rabbitmq.port=5672# 虚拟主机spring.rabbitmq.virtual-host=/spring.rabbitmq.username=tongspring.rabbitmq.password=123456# 每次只取一条消息，处理完成再获取下一条spring.rabbitmq.listener.simple.prefetch=1 发布、订阅概念 发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange (交换机)。常见exchange类型包括: Fanout: 广播 Direct: 路由 Topic: 话题注意: exchange负责消息路由，而不负责存储，路由失败则消息丢失 Fanout 发布订阅 Fanout Exchange会将接收到的消息路由到每一个跟其绑定的queue实现思路如下: 在consumer服务中，利用代码声明队列、交换机，并将两者绑定 在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2 在publisher中编写测试方法，向fanout.exchange发送消息/** * FanoutExchange配置 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:49 * @description: */@Configurationpublic class FanoutExchangeConfig &#123; /** * fanout交换机 * * @return &#123;@link FanoutExchange&#125; */ @Bean public FanoutExchange fanoutExchange() &#123; return new FanoutExchange(&quot;fanout.exchange&quot;); &#125; /** * fanout队列1 * * @return &#123;@link Queue&#125; */ @Bean public Queue fanoutQueue1() &#123; return new Queue(&quot;fanoutQueue1&quot;); &#125; /** * fanout队列2 * * @return &#123;@link Queue&#125; */ @Bean public Queue fanoutQueue2() &#123; return new Queue(&quot;fanoutQueue2&quot;); &#125; /** * 绑定队列1 * * @param fanoutQueue1 扇出队列1 * @param fanoutExchange 扇出交换 * @return &#123;@link Binding&#125; */ @Bean public Binding buildingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); &#125; /** * 绑定队列2 * * @param fanoutQueue2 扇出队列1 * @param fanoutExchange 扇出交换 * @return &#123;@link Binding&#125; */ @Bean public Binding buildingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); &#125;&#125; 配置交换机和队列以及它们的绑定关系 @Configurationpublic class FanoutExchangeConfig &#123; /** * fanout交换机 * * @return &#123;@link FanoutExchange&#125; */ @Bean public FanoutExchange fanoutExchange() &#123; return new FanoutExchange(&quot;fanout.exchange&quot;); &#125; /** * fanout队列1 * * @return &#123;@link Queue&#125; */ @Bean public Queue fanoutQueue1() &#123; return new Queue(&quot;fanoutQueue1&quot;); &#125; /** * fanout队列2 * * @return &#123;@link Queue&#125; */ @Bean public Queue fanoutQueue2() &#123; return new Queue(&quot;fanoutQueue2&quot;); &#125; /** * 绑定队列1 * * @param fanoutQueue1 扇出队列1 * @param fanoutExchange 扇出交换 * @return &#123;@link Binding&#125; */ @Bean public Binding buildingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange); &#125; /** * 绑定队列2 * * @param fanoutQueue2 扇出队列1 * @param fanoutExchange 扇出交换 * @return &#123;@link Binding&#125; */ @Bean public Binding buildingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange); &#125;&#125; @Slf4j@Componentpublic class RabbitMqListener &#123; /** * fanout队列侦听器1 * * @param message 消息 */ @RabbitListener(queues = &#123;&quot;fanoutQueue1&quot;&#125;) public void fanoutQueueListener1(String message)&#123; log.info(&quot;fanout队列侦听器1:接收到的消息为:&#123;&#125;&quot;,message); &#125; /** * fanout队列侦听器2 * * @param message 消息 */ @RabbitListener(queues = &#123;&quot;fanoutQueue2&quot;&#125;) public void fanoutQueueListener2(String message)&#123; log.info(&quot;fanout队列侦听器2:接收到的消息为:&#123;&#125;&quot;,message); &#125;&#125; @SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Fanout交换机测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithFanoutExchangeTest() throws InterruptedException &#123; String exchangeName=&quot;fanout.exchange&quot;; String message=&quot;你好，这是消息&quot;; for (int i = 0; i &lt; 50; i++) &#123; rabbitTemplate.convertAndSend(exchangeName,&quot;&quot;,message+i); Thread.sleep(20); &#125; &#125;&#125; DirectExchange Direct Exchange会将接收到的消息根据规则路由到指定的Queue,因此称为路由模式(routes) 。 每一个Queue都与Exchange设置一个BindingKey 发布者发送消息时，指定消息的RoutingKey Exchange将消息路由到BindingKey与消息RoutingKey一致的队列**需要注意**：一个队列，可以绑定多个key @Slf4j@Componentpublic class RabbitMqListener &#123; /** * direct队列侦听器1 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(&quot;directQueue1&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;,type = ExchangeTypes.DIRECT), key = &#123;&quot;red&quot;,&quot;blue&quot;&#125; )) public void directQueueListener1(String message)&#123; log.info(&quot;direct队列侦听器1:接收到的消息为:&#123;&#125;&quot;,message); &#125; /** * direct队列侦听器2 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(&quot;directQueue2&quot;), exchange = @Exchange(value = &quot;direct.exchange&quot;,type = ExchangeTypes.DIRECT), key = &#123;&quot;yellow&quot;,&quot;blue&quot;&#125; )) public void directQueueListener2(String message)&#123; log.info(&quot;direct队列侦听器2:接收到的消息为:&#123;&#125;&quot;,message); &#125;&#125; 启动consumer项目，前往rabbitmq网页。发现direct.exchange交换机和directQueue1、directQueue2队列已经声明了 查看绑定关系 @SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Direct交换机测试发送消息 * * @throws InterruptedException 中断异常 */ @Test void sendMessageWithDirectExchangeTest()&#123; String exchangeName = &quot;direct.exchange&quot;; String[] routingKeys=&#123;&quot;yellow&quot;,&quot;red&quot;,&quot;blue&quot;&#125;; for (String routingKey : routingKeys) &#123; rabbitTemplate.convertAndSend(exchangeName, routingKey, &quot;消息是:&quot;+routingKey); &#125; &#125;&#125; 日志打印如下 direct队列侦听器2:接收到的消息为:消息是:yellowdirect队列侦听器1:接收到的消息为:消息是:reddirect队列侦听器1:接收到的消息为:消息是:bluedirect队列侦听器2:接收到的消息为:消息是:blue TopicExchange TopicExchange与DirectExchange类似， 区别在于routingKey必须是多个单词的列表,并且以.分割。 Queue与Exchange指定BindingKey时可以使用通配符:#:代指0个或多个单词*:代指一个单词实现思路如下 并利用@RabbitListener声明Exchange、Queue、RoutingKey 在consumer服务中，编写两个消费者方法,分别监听topic.queue1和topic.queue2 在publisher中编写测试方法，向topic.exchange发送消息/** * RabbitMQ 侦听器 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:11 * @description: */@Slf4j@Componentpublic class RabbitMqListener &#123; /** * 主题队列侦听器1 * 接收 china 的一切信息 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(&quot;topicQueue1&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;,type = ExchangeTypes.TOPIC), key = &quot;china.#&quot; )) public void topicQueueListener1(String message)&#123; log.info(&quot;topic队列侦听器1:接收到的消息为:&#123;&#125;&quot;,message); &#125; /** * 主题队列侦听器2 * 接收一切 news 信息 * * @param message 消息 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(&quot;topicQueue2&quot;), exchange = @Exchange(value = &quot;topic.exchange&quot;,type = ExchangeTypes.TOPIC), key = &quot;#.news&quot; )) public void topicQueueListener2(String message)&#123; log.info(&quot;topic队列侦听器2:接收到的消息为:&#123;&#125;&quot;,message); &#125;&#125; 启动项目后，确认绑定关系/** * RabbitMQ发送消息测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/8:11 * @description: */@SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 使用Topic交换机测试发送消息 */ @Test void sendMessageWithTopicExchangeTest()&#123; String exchangeName = &quot;topic.exchange&quot;; String[] routingKeys=&#123;&quot;china.weather&quot;,&quot;china.news&quot;,&quot;Japan.weather&quot;,&quot;Japan.news&quot;&#125;; for (String routingKey : routingKeys) &#123; rabbitTemplate.convertAndSend(exchangeName, routingKey, &quot;消息是:&quot;+routingKey); &#125; &#125;&#125; 消息转换器 说明:在SpringAMQP的发送方法中，接收消息的类型是Object,也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。 @Configurationpublic class FanoutExchangeConfig &#123; /** * 对象队列 * * @return &#123;@link Queue&#125; */ @Bean public Queue objectQueue()&#123; return new Queue(&quot;objectQueue&quot;); &#125;&#125; @Slf4j@Componentpublic class RabbitMqListener &#123; @RabbitListener(queues = &#123;&quot;objectQueue&quot;&#125;) public void objectQueueListener(Object object)&#123; log.info(&quot;objectQueue队列侦听器:接收到的消息为:&#123;&#125;&quot;,object); &#125;&#125; 这里将consumer启动之后，就会创建objectQueue队列 @SpringBootTestclass SendMessageTest &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 发送对象消息测试 */ @Test void sendObjectMessageTest() &#123; String queueName=&quot;objectQueue&quot;; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;马小跳&quot;); map.put(&quot;gender&quot;,&quot;男&quot;); map.put(&quot;age&quot;,&quot;18&quot;); rabbitTemplate.convertAndSend(queueName,map); &#125;&#125; 消费消息的日志打印如下 objectQueue队列侦听器:接收到的消息为:(Body:&#x27;[serialized object]&#x27; MessageProperties [headers=&#123;&#125;, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=, receivedRoutingKey=objectQueue, deliveryTag=1, consumerTag=amq.ctag-6jbSNzh0393W9MP8GZ1z-w, consumerQueue=objectQueue]) 这次将consumer项目关闭，我们重新发送信息，去rabbitmq管理页面看一看消息rabbitmq原生只支持字节，但是spring允许我们发送对象，这是因为使用了jdk序列化，但是这种序列化有缺点 性能较差 安全性问题，容易出现注入问题 数据长度太长了（消息体越大，传输消息的速度越慢，而且占用额外的内存空间） 如何重新设定序列化的方式？ Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。 而默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化。 如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; @Configurationpublic class RabbitMqConfig &#123; /** * 采用json的方式将消息序列化 * * @return &#123;@link MessageConverter&#125; */ @Bean public MessageConverter messageConverter()&#123; return new Jackson2JsonMessageConverter(); &#125;&#125; 重新发送消息，前往rabbitmq管理页面查看消息消费也需要配置jackson依赖、RabbitMqConfig，上面代码复制粘贴即可，这里不再重复 /** * RabbitMQ 侦听器 * * @author: 不是菜狗爱编程 * @date: 2024/04/02/21:11 * @description: */@Slf4j@Componentpublic class RabbitMqListener &#123; /** * 对象队列侦听器 * * @param map 对象 */ @RabbitListener(queues = &#123;&quot;objectQueue&quot;&#125;) public void objectQueueListener(Map&lt;String,Object&gt; map)&#123; log.info(&quot;objectQueue队列侦听器:接收到的消息为:&#123;&#125;&quot;,map); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; System.out.println(&quot;entry = &quot; + entry); &#125; &#125;&#125; 总结SpringAMQP中消息的序列化和反序列化是怎么实现的? 利用MessageConverter实现的，默认是JDK的序列化 注意发送方与接收方必须使用相同的MessageConverter","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://isunderachiever.github.io/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://isunderachiever.github.io/tags/RabbitMQ/"}]},{"title":"elasticsearch复习","slug":"编程语言/Java/学习/框架/Elasticsearct/Elasticsearct复习","date":"2024-03-31T16:00:00.000Z","updated":"2024-06-01T14:32:53.437Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearct-fu-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearct-fu-xi.html","excerpt":"","text":"Elasticsearch基础 以下具体内容参考自黑马程序员课程微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程以及大佬的掘金博客 概念 文档 es的数据存储会被序列化成json的格式es是面向文档存储数据的，文档可以理解成一条条的数据 索引 索引是指相同类型文档的集合，索引可以理解成表 映射 文档与文档的结构会有些许差异，比如有的文档有name，有的有age索引中文档的字段约束信息类似于表结构约束es主要用于搜索，写入操作写入MySQL，可以将MySQL的数据同步到es 当使用分词搜索数据的时候，必须是通过分词器分析的数据才能搜索出来，否则无法搜索出数据 标准分词器POST /_analyze&#123; &quot;analyzer&quot;:&quot;standard&quot;, &quot;text&quot;:&quot;我爱中国&quot;&#125; 分词结果如下 特点是逐字一分，对中文不太友好 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;爱&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;国&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 3 &#125; ]&#125; ik分词器POST /_analyze&#123; &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;text&quot;:&quot;我爱中国&quot;&#125; 一般使用ik分词器和pinyin分词器对中文分词 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;爱&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125; ]&#125; pinyin分词器POST /_analyze&#123; &quot;analyzer&quot;:&quot;pinyin&quot;, &quot;text&quot;:&quot;我爱中国&quot;&#125; pinyin分词器可以将中文分词成拼音，一般结合ik分词器一起使用 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;wo&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 0, &quot;type&quot;: &quot;word&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;wazg&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 0, &quot;type&quot;: &quot;word&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;ai&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 0, &quot;type&quot;: &quot;word&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;zhong&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 0, &quot;type&quot;: &quot;word&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;guo&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 0, &quot;type&quot;: &quot;word&quot;, &quot;position&quot;: 3 &#125; ]&#125; 配置ik分词器结合pinyin分词器# 新建索引库并指定自定义分词器PUT /greatom&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;ik_smart_pinyin&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;ik_smart&quot;, &quot;filter&quot;: [&quot;my_pinyin&quot;, &quot;word_delimiter&quot;] &#125;, &quot;ik_max_word_pinyin&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;ik_max_word&quot;, &quot;filter&quot;: [&quot;my_pinyin&quot;, &quot;word_delimiter&quot;] &#125; &#125;, &quot;filter&quot;: &#123; &quot;my_pinyin&quot;: &#123; &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_separate_first_letter&quot; : true, &quot;keep_full_pinyin&quot; : true, &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;lowercase&quot; : true, &quot;remove_duplicated_term&quot; : true &#125; &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;greatom&quot;&#125; ik分词器、pinyin分词器结合 POST /greatom/_analyze&#123; &quot;analyzer&quot;:&quot;ik_smart_pinyin&quot;, &quot;text&quot;:&quot;我爱中国&quot;&#125; 执行结果 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;w&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;wo&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;a&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;ai&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;爱&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;z&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;zhong&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;g&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;guo&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;zg&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125; ]&#125; ik分词器拓展词库 配置文件在config下，为IKAnalyzer.cfg.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 --&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dict&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dict&lt;/entry&gt; &lt;!--用户可以在这里配置远程扩展字典 --&gt; &lt;!--&lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt; &lt;!--用户可以在这里配置远程扩展停止词字典--&gt; &lt;!--&lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt; 在config下新建ext.dict文件和ext_stopwords.dict文件 可以利用这个功能实现一些最新的流行词或者敏感词屏蔽需要重启生效，但是现在先不重启测试一下 POST /_analyze&#123; &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;text&quot;:&quot;兄弟们，坚持了，奥里给&quot;&#125; 执行结果 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;兄弟们&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;兄弟&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;们&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;坚持&quot;, &quot;start_offset&quot;: 4, &quot;end_offset&quot;: 6, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;了&quot;, &quot;start_offset&quot;: 6, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 4 &#125;, &#123; &quot;token&quot;: &quot;奥&quot;, &quot;start_offset&quot;: 8, &quot;end_offset&quot;: 9, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 5 &#125;, &#123; &quot;token&quot;: &quot;里&quot;, &quot;start_offset&quot;: 9, &quot;end_offset&quot;: 10, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 6 &#125;, &#123; &quot;token&quot;: &quot;给&quot;, &quot;start_offset&quot;: 10, &quot;end_offset&quot;: 11, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 7 &#125; ]&#125; 重启es服务 执行结果 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;兄弟们&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;兄弟&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;们&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;坚持&quot;, &quot;start_offset&quot;: 4, &quot;end_offset&quot;: 6, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;奥里给&quot;, &quot;start_offset&quot;: 8, &quot;end_offset&quot;: 11, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125; ]&#125; 索引库操作 常见的mapping属性type字段类型属性 text 可分词的文本 keyword 精确值，比如国家、品牌、ip地址、email，只有整体才有意义 数值 long、integer、short、byte、double、float 布尔 boolean 日期 date 对象 object，如人名分为姓和名两部分需要注意的是，es没有数组类型，但是支持某个类型多个值，比如double支持99.1或者[99.1,98.1]（这可不是数组）index是否创建索引，默认trueanalyzer使用哪种分词器properties该字段的子字段 创建索引库PUT /tb_user&#123; &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;object&quot;, &quot;properties&quot;:&#123; &quot;first_name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;last_name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125; &#125;, &quot;info&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_smart&quot; &#125; &#125; &#125;&#125; 想使用ik+pinyin分词 PUT /tb_user&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;ik_smart_pinyin&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;ik_smart&quot;, &quot;filter&quot;: [&quot;my_pinyin&quot;, &quot;word_delimiter&quot;] &#125;, &quot;ik_max_word_pinyin&quot;: &#123; &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;ik_max_word&quot;, &quot;filter&quot;: [&quot;my_pinyin&quot;, &quot;word_delimiter&quot;] &#125; &#125;, &quot;filter&quot;: &#123; &quot;my_pinyin&quot;: &#123; &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_separate_first_letter&quot; : true, &quot;keep_full_pinyin&quot; : true, &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;lowercase&quot; : true, &quot;remove_duplicated_term&quot; : true &#125; &#125; &#125; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;object&quot;, &quot;properties&quot;:&#123; &quot;first_name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;last_name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125; &#125;, &quot;info&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_smart_pinyin&quot; &#125; &#125; &#125;&#125; 更新索引库 索引库一旦创建无法修改(原有的字段)，但是可以新增新的字段 PUT /tb_user/_mapping&#123; &quot;properties&quot;:&#123; &quot;age&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:false &#125; &#125;&#125; 查看、删除索引库# 查看GET /tb_user# 删除DELETE /tb_user 文档操作新增文档格式如下 POST /索引库/_doc/文档id&#123; &quot;字段1&quot;:&quot;值1&quot;, &quot;字段2&quot;:&quot;值2&quot;, &quot;字段3&quot;:&#123; &quot;字段4&quot;:&quot;值4&quot;, &quot;字段5&quot;:&quot;值5&quot;, &#125;&#125; POST /tb_user/_doc/1&#123; &quot;info&quot;:&quot;小花的个人信息&quot;, &quot;name&quot;:&#123; &quot;first_name&quot;:&quot;小&quot;, &quot;last_name&quot;:&quot;花&quot; &#125;&#125; 查询文档GET /tb_user/_doc/1 删除文档DELETE /tb_user/_doc/1 修改文档 修改文档有些特殊，有两种方法 全量修改，先删除文档，然后新增（如果指定的文档不存在，则删除操作无效，但新增不受影响 &#x3D;&gt; 新增）post请求变为putPUT /tb_user/_doc/1&#123; &quot;info&quot;:&quot;小花的个人信息&quot;, &quot;name&quot;:&#123; &quot;first_name&quot;:&quot;小&quot;, &quot;last_name&quot;:&quot;花&quot; &#125;&#125; 增量修改格式如下POST /索引库/_update/文档id&#123; &quot;doc&quot;:&#123; &quot;字段名&quot;:&quot;新的值&quot; &#125;&#125; 例如 POST /tb_user/_update/1&#123; &quot;doc&quot;:&#123; &quot;name&quot;:&#123; &quot;last_name&quot;:&quot;花花&quot; &#125; &#125;&#125; 练习 详细使用方法 推介博客 create table tb_hotel( id bigint not null comment &#x27;酒店id&#x27; primary key, name varchar(255) not null comment &#x27;酒店名称&#x27;, address varchar(255) not null comment &#x27;酒店地址&#x27;, price int(10) not null comment &#x27;酒店价格&#x27;, score int(2) not null comment &#x27;酒店评分&#x27;, brand varchar(32) not null comment &#x27;酒店品牌&#x27;, city varchar(32) not null comment &#x27;所在城市&#x27;, star_name varchar(16) null comment &#x27;酒店星级，1星到5星，1钻到5钻&#x27;, business varchar(255) null comment &#x27;商圈&#x27;, latitude varchar(32) not null comment &#x27;纬度&#x27;, longitude varchar(32) not null comment &#x27;经度&#x27;, pic varchar(255) null comment &#x27;酒店图片&#x27;) collate = utf8mb4_general_ci row_format = COMPACT; 数据下载 在es中，我不仅希望根据酒店名称能搜索，而且还希望可以和其他几个字段一同搜索 copy_to的功能，将其他几个字段全部拷贝到一个字段 如下all同时具备了多个字段的搜索功能 &#123; ... &quot;all&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125; ...&#125; 构建es索引库 # 酒店PUT /hotel&#123; &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;address&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;price&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;bussiness&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;:&quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:&quot;false&quot; &#125;, &quot;all&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;ik_max_word&quot; &#125; &#125; &#125;&#125; 创建项目配置&lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--FastJson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.71&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;@Data@Slf4j@Configuration@ConfigurationProperties(prefix = &quot;elasticsearch&quot;)public class ElasticSearchConfig &#123; /** * 协议 */ private String schema; /** * 集群地址，如果有多个用“,”隔开 */ private String address; /** * 连接超时时间 */ private int connectTimeout; /** * Socket 连接超时时间 */ private int socketTimeout; /** * 获取连接的超时时间 */ private int connectionRequestTimeout; /** * 最大连接数 */ private int maxConnectNum; /** * 最大路由连接数 */ private int maxConnectPerRoute; /** * 连接ES的用户名 */ private String username; /** * 数据查询的索引 */ private String index; /** * 密码 */ private String passwd;&#125; # 应用名称spring.application.name=demo# 应用服务 WEB 访问端口server.port=8080# 查看es日志spring.jpa.show-sql=truelogging.level.tracer=TRACEelasticsearch.schema=httpelasticsearch.address=localhost:9200elasticsearch.connectTimeout=10000elasticsearch.socketTimeout=15000elasticsearch.connectionRequestTimeout=20000elasticsearch.maxConnectNum=100elasticsearch.maxConnectPerRoute=100elasticsearch.index=&quot;aha&quot;# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/es?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.domain# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.json.jackson.JacksonJsonpMapper;import co.elastic.clients.transport.ElasticsearchTransport;import co.elastic.clients.transport.rest_client.RestClientTransport;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.ArrayList;import java.util.List;/** * es java client */@Configurationpublic class ElasticsearchClientConfig &#123; private final ElasticSearchConfig elasticSearchConfig; public ElasticsearchClientConfig (ElasticSearchConfig elasticSearchConfig) &#123; this.elasticSearchConfig = elasticSearchConfig; &#125; @Bean public RestClient restClient() &#123; // 拆分地址 List&lt;HttpHost&gt; hostLists = new ArrayList&lt;&gt;(); String[] hostArray = elasticSearchConfig.getAddress().split(&quot;,&quot;); for (String temp : hostArray) &#123; String host = temp.split(&quot;:&quot;)[0]; String port = temp.split(&quot;:&quot;)[1]; hostLists.add(new HttpHost(host, Integer.parseInt(port), elasticSearchConfig.getSchema())); &#125; // 转换成 HttpHost 数组 HttpHost[] httpHost = hostLists.toArray(new HttpHost[]&#123;&#125;); // 构建连接对象 RestClientBuilder builder = RestClient.builder(httpHost); // 异步连接延时配置 builder.setRequestConfigCallback(requestConfigBuilder -&gt; &#123; requestConfigBuilder.setConnectTimeout(elasticSearchConfig.getConnectTimeout()); requestConfigBuilder.setSocketTimeout(elasticSearchConfig.getSocketTimeout()); requestConfigBuilder.setConnectionRequestTimeout(elasticSearchConfig.getConnectionRequestTimeout()); return requestConfigBuilder; &#125;); // 异步连接数配置 builder.setHttpClientConfigCallback(httpClientBuilder -&gt; &#123; httpClientBuilder.setMaxConnTotal(elasticSearchConfig.getMaxConnectNum()); httpClientBuilder.setMaxConnPerRoute(elasticSearchConfig.getMaxConnectPerRoute()); return httpClientBuilder; &#125;); return builder.build(); &#125; @Bean public ElasticsearchTransport elasticsearchTransport (RestClient restClient) &#123; return new RestClientTransport( restClient, new JacksonJsonpMapper()); &#125; @Bean public ElasticsearchClient elasticsearchClient (ElasticsearchTransport transport) &#123; return new ElasticsearchClient(transport); &#125;&#125; import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.io.Serializable;/** * * @TableName tb_hotel */@TableName(value =&quot;tb_hotel&quot;)@Datapublic class Hotel implements Serializable &#123; /** * 酒店id */ @TableId private Long id; /** * 酒店名称 */ private String name; /** * 酒店地址 */ private String address; /** * 酒店价格 */ private Integer price; /** * 酒店评分 */ private Integer score; /** * 酒店品牌 */ private String brand; /** * 所在城市 */ private String city; /** * 酒店星级，1星到5星，1钻到5钻 */ private String starName; /** * 商圈 */ private String business; /** * 纬度 */ private String latitude; /** * 经度 */ private String longitude; /** * 酒店图片 */ private String pic; @TableField(exist = false) private static final long serialVersionUID = 1L;&#125; import com.example.domain.Hotel;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldType;import org.springframework.data.elasticsearch.annotations.GeoPointField;import org.springframework.data.elasticsearch.core.geo.GeoPoint;/** * @auther: 不是菜狗爱编程 * @Date: 2024/03/27/7:45 * @Description: */@Data@AllArgsConstructor@NoArgsConstructor@Document(indexName = &quot;hotel&quot;,createIndex = true)public class HotelDoc &#123; @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); &#125;&#125; 操作索引import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.mapping.Property;import co.elastic.clients.elasticsearch.indices.CreateIndexResponse;import co.elastic.clients.elasticsearch.indices.DeleteIndexResponse;import co.elastic.clients.elasticsearch.indices.GetIndexResponse;import co.elastic.clients.transport.endpoints.BooleanResponse;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.Map;/** * 索引操作 */@Slf4j@SpringBootTestclass IndexTest &#123; @Autowired private ElasticsearchClient elasticsearchClient; /** * 创建索引 不使用mapping */ @Test void createIndexWithoutMappingTest() throws IOException &#123; CreateIndexResponse createIndexResponse = elasticsearchClient.indices() .create(createIndexRequest -&gt; createIndexRequest.index(&quot;elasticsearch-client&quot;)); log.info(&quot;== &#123;&#125; 索引创建是否成功: &#123;&#125;&quot;, &quot;elasticsearch-client&quot;, createIndexResponse.acknowledged()); &#125; /** * 创建索引 使用mapping */ @Test void createIndexWithMappingTest() throws IOException &#123; CreateIndexResponse createIndexResponse = elasticsearchClient.indices() .create(createIndexRequest -&gt; createIndexRequest.index(&quot;elasticsearch-client&quot;) .mappings(typeMapping -&gt; typeMapping.properties(&quot;name&quot;, objectBuild -&gt; objectBuild.text( textProperty -&gt; textProperty.index(true))) .properties(&quot;age&quot;,objectBuild -&gt; objectBuild.integer( textProperty -&gt; textProperty.index(false))) ) ); log.info(&quot;== &#123;&#125; 索引创建是否成功: &#123;&#125;&quot;, &quot;elasticsearch-client&quot;, createIndexResponse.acknowledged()); &#125; /** * 删除索引 */ @Test void deleteIndexTest() throws IOException &#123; DeleteIndexResponse deleteIndexResponse = elasticsearchClient.indices() .delete(deleteIndexRequest -&gt; deleteIndexRequest.index(&quot;elasticsearch-client&quot;)); log.info(&quot;== &#123;&#125; 索引删除是否成功: &#123;&#125;&quot;, &quot;elasticsearch-client&quot;, deleteIndexResponse.acknowledged()); &#125; /** * 判断索引是否存在 */ @Test void checkIndexExistTest() throws IOException &#123; BooleanResponse exists = elasticsearchClient.indices() .exists(existRequest -&gt; existRequest.index(&quot;elasticsearch-client&quot;)); log.info(&quot;== &#123;&#125; 索引是否存在: &#123;&#125;&quot;, &quot;elasticsearch-client&quot;, exists.value()?&quot;存在&quot;:&quot;不存在&quot;); &#125; /** * 查询索引详细信息 */ @Test void getIndexTest() throws IOException &#123; GetIndexResponse getIndexResponse = elasticsearchClient.indices() .get(getIndexRequest -&gt; getIndexRequest.index(&quot;elasticsearch-client&quot;)); Map&lt;String, Property&gt; properties = getIndexResponse.get(&quot;elasticsearch-client&quot;).mappings().properties(); for (String key : properties.keySet()) &#123; log.info(&quot;== &#123;&#125; 索引的详细信息为: == key: &#123;&#125;, Property: &#123;&#125;&quot;, &quot;elasticsearch-client&quot;, key, properties.get(key)._kind()); &#125; &#125;&#125; 文档操作import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.*;import co.elastic.clients.elasticsearch.core.bulk.BulkOperation;import com.example.domain.Hotel;import com.example.domain.doc.HotelDoc;import com.example.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * 文档操作 */@Slf4j@SpringBootTestclass DocTest &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; @Autowired private HotelService hotelService; /** * 添加文档 * GET /hotel/_doc/61083 */ @Test void addDocTest() throws IOException &#123; Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); IndexResponse index = elasticsearchClient.index( indexRequest -&gt; indexRequest.index(INDEX_NAME).id(hotelDoc.getId().toString()).document(hotelDoc)); log.info(&quot;== response: &#123;&#125;, responseStatus: &#123;&#125;&quot;, index, index.result()); &#125; /** * 获取文档信息 */ @Test public void getDocTest () throws IOException &#123; GetResponse&lt;HotelDoc&gt; getResponse = elasticsearchClient.get(getRequest -&gt; getRequest.index(INDEX_NAME).id(&quot;61083&quot;), HotelDoc.class ); log.info(&quot;== document source: &#123;&#125;, response: &#123;&#125;&quot;, getResponse.source(), getResponse); &#125; /** * 更新文档信息 */ @Test public void updateDocTest () throws IOException &#123; Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); hotelDoc.setName(hotelDoc.getName()+&quot;(更新后)&quot;); UpdateResponse&lt;HotelDoc&gt; updateResponse = elasticsearchClient.update(updateRequest -&gt; updateRequest.index(INDEX_NAME).id(&quot;61083&quot;).doc(hotelDoc), HotelDoc.class ); log.info(&quot;== response: &#123;&#125;, responseStatus: &#123;&#125;&quot;, updateResponse, updateResponse.result()); &#125; /** * 删除文档信息 */ @Test public void deleteDocTest () throws IOException &#123; DeleteResponse deleteResponse = elasticsearchClient.delete(deleteRequest -&gt; deleteRequest.index(INDEX_NAME).id(&quot;1&quot;) ); log.info(&quot;== response: &#123;&#125;, result:&#123;&#125;&quot;, deleteResponse, deleteResponse.result()); &#125; /** * 批量插入文档 * GET /hotel/_doc/36934 * GET /hotel/_doc/38609 */ @Test public void batchInsertTest () throws IOException &#123; List&lt;Hotel&gt; hotels = hotelService.list(); List&lt;BulkOperation&gt; bulkOperationList = new ArrayList&lt;&gt;(); for (Hotel hotel : hotels) &#123; HotelDoc hotelDoc = new HotelDoc(hotel); bulkOperationList.add(new BulkOperation.Builder().create(e -&gt; e.document(hotelDoc).id(hotel.getId().toString())).build()); &#125; BulkResponse bulkResponse = elasticsearchClient.bulk(bulkRequest -&gt; bulkRequest.index(INDEX_NAME).operations(bulkOperationList) ); // 这边插入成功的话显示的是 false log.info(&quot;== errors: &#123;&#125;&quot;, bulkResponse.errors()); &#125;&#125; DSL语法 查询所有:查询出所有数据，一般测试用。例如: match_all 全文检索(full text)查询:利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如:match_query、multi_match_query 精确查询:根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如:ids、range、term 地理(geo)查询:根据经纬度查询。例如:geo_distance、geo_bounding_box 复合(compound)查询:复合查询可以将上述各种查询条件组合起来，合并查询条件。例如:bool、function_score 查询所有match_all 基本查询语法 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;查询类型&quot;:&#123; &quot;查询条件&quot;:&quot;条件值&quot; &#125; &#125;&#125;# 例如GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;&#125; 全文检索查询 全文检索查询会对用户输入内容分词，常用于搜索框查询 matchGET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;FIELD&quot;:&quot;TEXT&quot; &#125; &#125;&#125;# 例如# 这个all字段在前文的copy_to那里GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;all&quot;:&quot;上海五&quot; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 5, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 83, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 4.671594, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1557997004&quot;, &quot;_score&quot;: 4.671594, &quot;_source&quot;: &#123; &quot;id&quot;: 1557997004, &quot;name&quot;: &quot;上海五角场凯悦酒店&quot;, &quot;address&quot;: &quot;国定东路88号&quot;, &quot;price&quot;: 1104, &quot;score&quot;: 46, &quot;brand&quot;: &quot;凯悦&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.300645, &quot;lon&quot;: 121.51918 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3a3Zz9cDgbJEEJ1GcXzKhTh21YqK_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56977&quot;, &quot;_score&quot;: 4.1990623, &quot;_source&quot;: &#123; &quot;id&quot;: 56977, &quot;name&quot;: &quot;上海五角场华美达大酒店&quot;, &quot;address&quot;: &quot;黄兴路1888号&quot;, &quot;price&quot;: 499, &quot;score&quot;: 40, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;三钻&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.292932, &quot;lon&quot;: 121.519759 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/26VREqAQdaGFvJdAJALVtjxcNMpL_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;39141&quot;, &quot;_score&quot;: 3.700049, &quot;_source&quot;: &#123; &quot;id&quot;: 39141, &quot;name&quot;: &quot;7天连锁酒店(上海五角场复旦同济大学店)&quot;, &quot;address&quot;: &quot;杨浦国权路315号&quot;, &quot;price&quot;: 349, &quot;score&quot;: 38, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;江湾、五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.290057, &quot;lon&quot;: 121.508804 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/C7/E3/Cii-T1knFXCIJzNYAAFB8-uFNAEAAKYkQPcw1IAAUIL012_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2048671293&quot;, &quot;_score&quot;: 3.644754, &quot;_source&quot;: &#123; &quot;id&quot;: 2048671293, &quot;name&quot;: &quot;汉庭酒店(深圳观澜五和大道店)&quot;, &quot;address&quot;: &quot;观湖街道五和大道327号&quot;, &quot;price&quot;: 234, &quot;score&quot;: 43, &quot;brand&quot;: &quot;汉庭&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;观澜&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.684459, &quot;lon&quot;: 114.07708 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2JrQi83S9qgDEkXqWpe5iyi44Uh2_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;339777429&quot;, &quot;_score&quot;: 1.1486411, &quot;_source&quot;: &#123; &quot;id&quot;: 339777429, &quot;name&quot;: &quot;上海嘉定喜来登酒店&quot;, &quot;address&quot;: &quot;菊园新区嘉唐公路66号&quot;, &quot;price&quot;: 1286, &quot;score&quot;: 44, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.394595, &quot;lon&quot;: 121.245773 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2022598930&quot;, &quot;_score&quot;: 1.095608, &quot;_source&quot;: &#123; &quot;id&quot;: 2022598930, &quot;name&quot;: &quot;上海宝华喜来登酒店&quot;, &quot;address&quot;: &quot;南奉公路3111弄228号&quot;, &quot;price&quot;: 2899, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.921659, &quot;lon&quot;: 121.575572 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;644417&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 644417, &quot;name&quot;: &quot;上海外高桥喜来登酒店&quot;, &quot;address&quot;: &quot;自由贸易试验区基隆路28号（二号门内）&quot;, &quot;price&quot;: 2419, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;浦东外高桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.350989, &quot;lon&quot;: 121.588751 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1463484295&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1463484295, &quot;name&quot;: &quot;上海和平豪生酒店&quot;, &quot;address&quot;: &quot;沪南公路2653-2号&quot;, &quot;price&quot;: 650, &quot;score&quot;: 41, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;周浦康桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.146478, &quot;lon&quot;: 121.568218 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1880614409&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1880614409, &quot;name&quot;: &quot;上海崇明由由喜来登酒店&quot;, &quot;address&quot;: &quot;揽海路2888号&quot;, &quot;price&quot;: 2198, &quot;score&quot;: 45, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;崇明岛/长兴岛/横沙岛&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.462167, &quot;lon&quot;: 121.823103 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; multi_match multi_match与match查询类似，允许同时查询多个字段 需要注意：参与搜索的字段越多，效率越低，建议使用copy_to将多个字段拷贝到一个字段中，采用match查询 GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;:&quot;TEXT1&quot;, &quot;fields&quot;: [&quot;FIELD1&quot;,&quot;FIELD2&quot;] &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;:&quot;上海酒店&quot;, &quot;fields&quot;: [&quot;city&quot;,&quot;name&quot;] &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 1, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 200, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1.1692147, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;339777429&quot;, &quot;_score&quot;: 1.1692147, &quot;_source&quot;: &#123; &quot;id&quot;: 339777429, &quot;name&quot;: &quot;上海嘉定喜来登酒店&quot;, &quot;address&quot;: &quot;菊园新区嘉唐公路66号&quot;, &quot;price&quot;: 1286, &quot;score&quot;: 44, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.394595, &quot;lon&quot;: 121.245773 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60223&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 60223, &quot;name&quot;: &quot;上海希尔顿酒店&quot;, &quot;address&quot;: &quot;静安华山路250号&quot;, &quot;price&quot;: 2688, &quot;score&quot;: 37, &quot;brand&quot;: &quot;希尔顿&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;静安寺地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.219306, &quot;lon&quot;: 121.445427 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/filebroker/cdn/res/92/10/9210e74442aceceaf6e196d61fc3b6b1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1463484295&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 1463484295, &quot;name&quot;: &quot;上海和平豪生酒店&quot;, &quot;address&quot;: &quot;沪南公路2653-2号&quot;, &quot;price&quot;: 650, &quot;score&quot;: 41, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;周浦康桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.146478, &quot;lon&quot;: 121.568218 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1942992995&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 1942992995, &quot;name&quot;: &quot;上海嘉定凯悦酒店&quot;, &quot;address&quot;: &quot;裕民南路1366号&quot;, &quot;price&quot;: 758, &quot;score&quot;: 46, &quot;brand&quot;: &quot;凯悦&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.352298, &quot;lon&quot;: 121.263314 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1996823660&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 1996823660, &quot;name&quot;: &quot;上海紫竹万怡酒店&quot;, &quot;address&quot;: &quot;紫星路588号3幢&quot;, &quot;price&quot;: 642, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;交大/闵行经济开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.02118, &quot;lon&quot;: 121.465186 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2022598930&quot;, &quot;_score&quot;: 1.1032845, &quot;_source&quot;: &#123; &quot;id&quot;: 2022598930, &quot;name&quot;: &quot;上海宝华喜来登酒店&quot;, &quot;address&quot;: &quot;南奉公路3111弄228号&quot;, &quot;price&quot;: 2899, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.921659, &quot;lon&quot;: 121.575572 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56201&quot;, &quot;_score&quot;: 1.0443928, &quot;_source&quot;: &#123; &quot;id&quot;: 56201, &quot;name&quot;: &quot;上海齐鲁万怡大酒店&quot;, &quot;address&quot;: &quot;东方路838号&quot;, &quot;price&quot;: 873, &quot;score&quot;: 44, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;浦东陆家嘴金融贸易区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.226031, &quot;lon&quot;: 121.525801 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56227&quot;, &quot;_score&quot;: 1.0443928, &quot;_source&quot;: &#123; &quot;id&quot;: 56227, &quot;name&quot;: &quot;上海圣淘沙万怡酒店&quot;, &quot;address&quot;: &quot;南桥镇南桥路1号&quot;, &quot;price&quot;: 899, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.910917, &quot;lon&quot;: 121.456525 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56852&quot;, &quot;_score&quot;: 1.0443928, &quot;_source&quot;: &#123; &quot;id&quot;: 56852, &quot;name&quot;: &quot;上海财大豪生大酒店&quot;, &quot;address&quot;: &quot;武东路188号&quot;, &quot;price&quot;: 592, &quot;score&quot;: 46, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.304182, &quot;lon&quot;: 121.492936 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2jGHezLZvPZqC9cBGesbP5vAhCXi_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; 精确查询 一般是查找keyword、数值、日期、boolean等类型字段，不做分词 termGET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;FIELD&quot;:&#123; &quot;value&quot;:&quot;VALUE&quot; &#125; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;starName&quot;:&#123; &quot;value&quot;:&quot;四钻&quot; &#125; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 0, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 28, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1.9583635, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;45845&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 45845, &quot;name&quot;: &quot;上海西藏大厦万怡酒店&quot;, &quot;address&quot;: &quot;虹桥路100号&quot;, &quot;price&quot;: 589, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;徐家汇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.192714, &quot;lon&quot;: 121.434717 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/48GNb9GZpJDCejVAcQHYWwYyU8T_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;47066&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 47066, &quot;name&quot;: &quot;上海浦东东站华美达酒店&quot;, &quot;address&quot;: &quot;施新路958号&quot;, &quot;price&quot;: 408, &quot;score&quot;: 46, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东机场核心区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.147989, &quot;lon&quot;: 121.759199 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56912&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 56912, &quot;name&quot;: &quot;上海华凯华美达广场酒店&quot;, &quot;address&quot;: &quot;月华路9号&quot;, &quot;price&quot;: 747, &quot;score&quot;: 40, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.814382, &quot;lon&quot;: 121.464521 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/45iaCNCuZavJTxwTLskhVKzwynLD_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60522&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 60522, &quot;name&quot;: &quot;上海嘉豪淮海国际豪生酒店&quot;, &quot;address&quot;: &quot;汾阳路1号&quot;, &quot;price&quot;: 425, &quot;score&quot;: 45, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;淮海路/新天地地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.215497, &quot;lon&quot;: 121.456297 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/38UBi4QYuaF8jN94CxQ7tb7tjtmZ_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60916&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 60916, &quot;name&quot;: &quot;上海绿地万怡酒店&quot;, &quot;address&quot;: &quot;沪宜公路3101号&quot;, &quot;price&quot;: 328, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.368523, &quot;lon&quot;: 121.258567 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;395815&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 395815, &quot;name&quot;: &quot;北京明豪华美达酒店&quot;, &quot;address&quot;: &quot;天竺镇府前一街13号&quot;, &quot;price&quot;: 558, &quot;score&quot;: 46, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;北京&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;首都机场/新国展地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 40.062832, &quot;lon&quot;: 116.580678 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/13/Cii-U13eP2mIKCwvAAODTZXT-fAAAGKVAA9taIAA4Nl245_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;598591&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 598591, &quot;name&quot;: &quot;上海丽昂豪生大酒店&quot;, &quot;address&quot;: &quot;金新路99号&quot;, &quot;price&quot;: 529, &quot;score&quot;: 47, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.252496, &quot;lon&quot;: 121.600085 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;609372&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 609372, &quot;name&quot;: &quot;豪派特华美达广场酒店(深圳北站店)&quot;, &quot;address&quot;: &quot;民治街道梅龙路与民旺路交汇处&quot;, &quot;price&quot;: 498, &quot;score&quot;: 45, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;深圳北站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.620501, &quot;lon&quot;: 114.033874 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3G5TnUCPbjGYHAVWfvuixw8bs69t_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;629023&quot;, &quot;_score&quot;: 1.9583635, &quot;_source&quot;: &#123; &quot;id&quot;: 629023, &quot;name&quot;: &quot;和颐酒店(北京十里河欢乐谷店)&quot;, &quot;address&quot;: &quot;十八里店乡周家庄288号&quot;, &quot;price&quot;: 390, &quot;score&quot;: 47, &quot;brand&quot;: &quot;和颐&quot;, &quot;city&quot;: &quot;北京&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;劲松/潘家园地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 39.853354, &quot;lon&quot;: 116.483437 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/28hnDdqn5uzuzCKYkw2x4pYmunXM_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; range 一般查询某个范围内的值 如下查找&quot;大于等于10&quot;且&quot;小于等于20&quot;的值 gte 大于等于gt 大于lte 小于等于lt 小于 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; &quot;FIELD&quot;:&#123; &quot;gte&quot;:10, &quot;lte&quot;:20 &#125; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; &quot;price&quot;:&#123; &quot;gte&quot;:100, &quot;lte&quot;:200 &#125; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 0, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 17, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;485775&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 485775, &quot;name&quot;: &quot;如家酒店(上海闵行华东师范大学吴泾店)&quot;, &quot;address&quot;: &quot;吴泾镇宝秀路977号&quot;, &quot;price&quot;: 161, &quot;score&quot;: 45, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;交大/闵行经济开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.047135, &quot;lon&quot;: 121.46224 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/V8pz15CkiMX5xYJRmbbp5zkKWJ8_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;517915&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 517915, &quot;name&quot;: &quot;如家酒店·neo(深圳草埔地铁站店)&quot;, &quot;address&quot;: &quot;布吉路1036号&quot;, &quot;price&quot;: 159, &quot;score&quot;: 44, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;田贝/水贝珠宝城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.583191, &quot;lon&quot;: 114.118499 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/228vhBCQmFRFWQBYX1cgoFQb6x58_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;541619&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 541619, &quot;name&quot;: &quot;如家酒店(上海莘庄地铁站龙之梦商业广场店)&quot;, &quot;address&quot;: &quot;莘庄镇莘浜路172号&quot;, &quot;price&quot;: 149, &quot;score&quot;: 44, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;莘庄工业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.105797, &quot;lon&quot;: 121.37755 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3mKs3jETvJDj3dDdkRB9UyLLvPna_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;608374&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 608374, &quot;name&quot;: &quot;如家酒店(上海浦东机场龙东大道合庆店)&quot;, &quot;address&quot;: &quot;东川公路5863号&quot;, &quot;price&quot;: 160, &quot;score&quot;: 45, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;浦东机场核心区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.237662, &quot;lon&quot;: 121.718556 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/LUYxGGV4pzjKeN5a69K4deU8JD8_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;728180&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 728180, &quot;name&quot;: &quot;如家酒店(深圳宝安西乡地铁站店)&quot;, &quot;address&quot;: &quot;西乡大道298-7号（富通城二期公交站旁）&quot;, &quot;price&quot;: 184, &quot;score&quot;: 43, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;宝安体育中心商圈&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.569693, &quot;lon&quot;: 113.860186 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/FHdugqgUgYLPMoC4u4rdTbAPrVF_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;728415&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 728415, &quot;name&quot;: &quot;如家酒店·neo(深圳东门步行街晒布地铁站店)&quot;, &quot;address&quot;: &quot;晒布路67号&quot;, &quot;price&quot;: 152, &quot;score&quot;: 46, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;东门商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.550183, &quot;lon&quot;: 114.120771 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/25/57/Cii-U13PFNWISSnQAAEpTtoilsQAAEVWgEvur8AASlm647_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;728604&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 728604, &quot;name&quot;: &quot;如家酒店·neo(深圳南山地铁站南山市场店)&quot;, &quot;address&quot;: &quot;南新路顺富街18号化州大厦&quot;, &quot;price&quot;: 198, &quot;score&quot;: 43, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;科技园&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.525561, &quot;lon&quot;: 113.920058 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/25/57/Cii-TF3PFLmIDGWiAAPHkaNTuOIAAEVVQBGazAAA8ep611_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2316304&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 2316304, &quot;name&quot;: &quot;如家酒店(深圳双龙地铁站店)&quot;, &quot;address&quot;: &quot;龙岗街道龙岗墟社区龙平东路62号&quot;, &quot;price&quot;: 135, &quot;score&quot;: 45, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;龙岗中心区/大运新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.730828, &quot;lon&quot;: 114.278337 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/4AzEoQ44awd1D2g95a6XDtJf3dkw_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;5873072&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 5873072, &quot;name&quot;: &quot;速8酒店（上海火车站北广场店）&quot;, &quot;address&quot;: &quot;闸北芷江西路796号&quot;, &quot;price&quot;: 190, &quot;score&quot;: 41, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.255579, &quot;lon&quot;: 121.452903 &#125;, &quot;pic&quot;: &quot;https://m2.tuniucdn.com/filebroker/cdn/res/96/6d/966d6596e6cb7b48c9cc1d7da79b57c8_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;197837109&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 197837109, &quot;name&quot;: &quot;如家酒店·neo(深圳龙岗大道布吉地铁站店)&quot;, &quot;address&quot;: &quot;布吉镇深惠路龙珠商城&quot;, &quot;price&quot;: 127, &quot;score&quot;: 43, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;深圳&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;布吉/深圳东站&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 22.602482, &quot;lon&quot;: 114.123284 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/25/58/Cii-TF3PFZOIA7jwAAKInGFN4xgAAEVbAGeP4AAAoi0485_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; 地理查询 lat指纬度、lon指经度 geo_bounding_box 查询geo_point值落在某个矩形范围内的所有文档 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;geo_bounding_box&quot;:&#123; &quot;FIELD&quot;:&#123; &quot;top_left&quot;:&#123; &quot;lat&quot;:31.1, &quot;lon&quot;:121.5 &#125;, &quot;bottom_right&quot;:&#123; &quot;lat&quot;:30.9, &quot;lon&quot;:121.7 &#125; &#125; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;geo_bounding_box&quot;:&#123; &quot;location&quot;:&#123; &quot;top_left&quot;:&#123; &quot;lat&quot;:31.1, &quot;lon&quot;:121.5 &#125;, &quot;bottom_right&quot;:&#123; &quot;lat&quot;:30.9, &quot;lon&quot;:121.7 &#125; &#125; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 7, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 2, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2022598930&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 2022598930, &quot;name&quot;: &quot;上海宝华喜来登酒店&quot;, &quot;address&quot;: &quot;南奉公路3111弄228号&quot;, &quot;price&quot;: 2899, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.921659, &quot;lon&quot;: 121.575572 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2056298828&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 2056298828, &quot;name&quot;: &quot;上海中优城市万豪酒店&quot;, &quot;address&quot;: &quot;沪南公路7688弄1号&quot;, &quot;price&quot;: 1200, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万豪&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;南汇/野生动物园&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.030053, &quot;lon&quot;: 121.662943 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2gBATEyysyQWmw3wZL863HGdqjaq_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; geo_distance 查询到指定中心点小于某个距离值的所有文档 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;geo_distance&quot;:&#123; &quot;distance&quot;:&quot;15km&quot;, &quot;FIELD&quot;:&quot;31.21,121.5&quot; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;geo_distance&quot;:&#123; &quot;distance&quot;:&quot;15km&quot;, &quot;location&quot;:&quot;31.21,121.5&quot; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 31, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 47, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;36934&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 36934, &quot;name&quot;: &quot;7天连锁酒店(上海宝山路地铁站店)&quot;, &quot;address&quot;: &quot;静安交通路40号&quot;, &quot;price&quot;: 336, &quot;score&quot;: 37, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;四川北路商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.251433, &quot;lon&quot;: 121.47522 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G1/M00/3E/40/Cii9EVkyLrKIXo1vAAHgrxo_pUcAALcKQLD688AAeDH564_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;38609&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 38609, &quot;name&quot;: &quot;速8酒店(上海赤峰路店)&quot;, &quot;address&quot;: &quot;广灵二路126号&quot;, &quot;price&quot;: 249, &quot;score&quot;: 35, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;四川北路商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.282444, &quot;lon&quot;: 121.479385 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/DF/96/Cii-TFkx0ImIQZeiAAITil0LM7cAALCYwKXHQ4AAhOi377_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;38665&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 38665, &quot;name&quot;: &quot;速8酒店上海中山北路兰田路店&quot;, &quot;address&quot;: &quot;兰田路38号&quot;, &quot;price&quot;: 226, &quot;score&quot;: 35, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;长风公园地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.244288, &quot;lon&quot;: 121.422419 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/EF/86/Cii-Tlk2mV2IMZ-_AAEucgG3dx4AALaawEjiycAAS6K083_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;38812&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 38812, &quot;name&quot;: &quot;7天连锁酒店(上海漕溪路地铁站店)&quot;, &quot;address&quot;: &quot;徐汇龙华西路315弄58号&quot;, &quot;price&quot;: 298, &quot;score&quot;: 37, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;八万人体育场地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.174377, &quot;lon&quot;: 121.442875 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/E0/0E/Cii-TlkyIr2IEWNoAAHQYv7i5CkAALD-QP2iJwAAdB6245_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;39141&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 39141, &quot;name&quot;: &quot;7天连锁酒店(上海五角场复旦同济大学店)&quot;, &quot;address&quot;: &quot;杨浦国权路315号&quot;, &quot;price&quot;: 349, &quot;score&quot;: 38, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;江湾、五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.290057, &quot;lon&quot;: 121.508804 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/C7/E3/Cii-T1knFXCIJzNYAAFB8-uFNAEAAKYkQPcw1IAAUIL012_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;45845&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 45845, &quot;name&quot;: &quot;上海西藏大厦万怡酒店&quot;, &quot;address&quot;: &quot;虹桥路100号&quot;, &quot;price&quot;: 589, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;徐家汇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.192714, &quot;lon&quot;: 121.434717 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/48GNb9GZpJDCejVAcQHYWwYyU8T_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56201&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 56201, &quot;name&quot;: &quot;上海齐鲁万怡大酒店&quot;, &quot;address&quot;: &quot;东方路838号&quot;, &quot;price&quot;: 873, &quot;score&quot;: 44, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;浦东陆家嘴金融贸易区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.226031, &quot;lon&quot;: 121.525801 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56214&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 56214, &quot;name&quot;: &quot;上海浦东华美达大酒店&quot;, &quot;address&quot;: &quot;新金桥路18号&quot;, &quot;price&quot;: 830, &quot;score&quot;: 45, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.244916, &quot;lon&quot;: 121.590752 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3jtXiuMKZEXJAuKuAkc47yLCjUBt_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56392&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 56392, &quot;name&quot;: &quot;上海银星皇冠假日酒店&quot;, &quot;address&quot;: &quot;番禺路400号&quot;, &quot;price&quot;: 809, &quot;score&quot;: 47, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;徐家汇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.202768, &quot;lon&quot;: 121.429524 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; 复合查询 复合查询:复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑，例如:fuction score:算分函数查询，可以控制文档相关性算分,控制文档排名。 function_score GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;function_score&quot;:&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;all&quot;:&quot;上海&quot; &#125; &#125;, &quot;functions&quot;:[ &#123; &quot;filter&quot;:&#123; &quot;term&quot;:&#123; &quot;city&quot;:&quot;&quot; &#125; &#125;, &quot;weight&quot;:10 &#125; ], &quot;boost_mode&quot;:&quot;sum&quot; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;all&quot;: &quot;上海&quot; &#125; &#125;, &quot;functions&quot;: [ &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;city&quot;: &quot;上海&quot; &#125; &#125;, &quot;weight&quot;: 10 &#125; ], &quot;boost_mode&quot;: &quot;sum&quot; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 5, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 82, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 11.148642, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;339777429&quot;, &quot;_score&quot;: 11.148642, &quot;_source&quot;: &#123; &quot;id&quot;: 339777429, &quot;name&quot;: &quot;上海嘉定喜来登酒店&quot;, &quot;address&quot;: &quot;菊园新区嘉唐公路66号&quot;, &quot;price&quot;: 1286, &quot;score&quot;: 44, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.394595, &quot;lon&quot;: 121.245773 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2022598930&quot;, &quot;_score&quot;: 11.095608, &quot;_source&quot;: &#123; &quot;id&quot;: 2022598930, &quot;name&quot;: &quot;上海宝华喜来登酒店&quot;, &quot;address&quot;: &quot;南奉公路3111弄228号&quot;, &quot;price&quot;: 2899, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.921659, &quot;lon&quot;: 121.575572 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;644417&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 644417, &quot;name&quot;: &quot;上海外高桥喜来登酒店&quot;, &quot;address&quot;: &quot;自由贸易试验区基隆路28号（二号门内）&quot;, &quot;price&quot;: 2419, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;浦东外高桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.350989, &quot;lon&quot;: 121.588751 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1463484295&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 1463484295, &quot;name&quot;: &quot;上海和平豪生酒店&quot;, &quot;address&quot;: &quot;沪南公路2653-2号&quot;, &quot;price&quot;: 650, &quot;score&quot;: 41, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;周浦康桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.146478, &quot;lon&quot;: 121.568218 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1880614409&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 1880614409, &quot;name&quot;: &quot;上海崇明由由喜来登酒店&quot;, &quot;address&quot;: &quot;揽海路2888号&quot;, &quot;price&quot;: 2198, &quot;score&quot;: 45, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;崇明岛/长兴岛/横沙岛&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.462167, &quot;lon&quot;: 121.823103 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1942992995&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 1942992995, &quot;name&quot;: &quot;上海嘉定凯悦酒店&quot;, &quot;address&quot;: &quot;裕民南路1366号&quot;, &quot;price&quot;: 758, &quot;score&quot;: 46, &quot;brand&quot;: &quot;凯悦&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.352298, &quot;lon&quot;: 121.263314 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1996823660&quot;, &quot;_score&quot;: 11.0472555, &quot;_source&quot;: &#123; &quot;id&quot;: 1996823660, &quot;name&quot;: &quot;上海紫竹万怡酒店&quot;, &quot;address&quot;: &quot;紫星路588号3幢&quot;, &quot;price&quot;: 642, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;交大/闵行经济开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.02118, &quot;lon&quot;: 121.465186 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56201&quot;, &quot;_score&quot;: 11.002991, &quot;_source&quot;: &#123; &quot;id&quot;: 56201, &quot;name&quot;: &quot;上海齐鲁万怡大酒店&quot;, &quot;address&quot;: &quot;东方路838号&quot;, &quot;price&quot;: 873, &quot;score&quot;: 44, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;浦东陆家嘴金融贸易区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.226031, &quot;lon&quot;: 121.525801 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56227&quot;, &quot;_score&quot;: 11.002991, &quot;_source&quot;: &#123; &quot;id&quot;: 56227, &quot;name&quot;: &quot;上海圣淘沙万怡酒店&quot;, &quot;address&quot;: &quot;南桥镇南桥路1号&quot;, &quot;price&quot;: 899, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.910917, &quot;lon&quot;: 121.456525 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; bool布尔查询是一个或多个查询子句的组合。子查询的组合方式有: must:必须匹配每个子查询，类似“与” should:选择性匹配子查询，类似“或” must_not:必须不匹配，不参与算分，类似“非” filter:必须匹配，不参与算分GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;term&quot;:&#123; &quot;city&quot;:&quot;上海&quot; &#125; &#125;, &quot;should&quot;:&#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;上海&quot; &#125; &#125;, &quot;must_not&quot;:&#123; &quot;range&quot;:&#123; &quot;price&quot;:&#123; &quot;gt&quot;:500 &#125; &#125; &#125;, &quot;filter&quot;:&#123; &quot;range&quot;:&#123; &quot;price&quot;:&#123; &quot;gte&quot;:100 &#125; &#125; &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 8, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 30, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1.9134885, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60916&quot;, &quot;_score&quot;: 1.9134885, &quot;_source&quot;: &#123; &quot;id&quot;: 60916, &quot;name&quot;: &quot;上海绿地万怡酒店&quot;, &quot;address&quot;: &quot;沪宜公路3101号&quot;, &quot;price&quot;: 328, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.368523, &quot;lon&quot;: 121.258567 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;38609&quot;, &quot;_score&quot;: 1.861291, &quot;_source&quot;: &#123; &quot;id&quot;: 38609, &quot;name&quot;: &quot;速8酒店(上海赤峰路店)&quot;, &quot;address&quot;: &quot;广灵二路126号&quot;, &quot;price&quot;: 249, &quot;score&quot;: 35, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;四川北路商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.282444, &quot;lon&quot;: 121.479385 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G2/M00/DF/96/Cii-TFkx0ImIQZeiAAITil0LM7cAALCYwKXHQ4AAhOi377_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1649956165&quot;, &quot;_score&quot;: 1.861291, &quot;_source&quot;: &#123; &quot;id&quot;: 1649956165, &quot;name&quot;: &quot;上海南青华美达酒店&quot;, &quot;address&quot;: &quot;华夏东路811号&quot;, &quot;price&quot;: 299, &quot;score&quot;: 47, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;迪士尼度假区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.195206, &quot;lon&quot;: 121.664791 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2RHmQgTpte3UVSDJ5KbqobbZGRnE_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;233036941&quot;, &quot;_score&quot;: 1.8141286, &quot;_source&quot;: &#123; &quot;id&quot;: 233036941, &quot;name&quot;: &quot;7天连锁酒店(上海东林寺店)&quot;, &quot;address&quot;: &quot;朱泾镇文商路79号&quot;, &quot;price&quot;: 218, &quot;score&quot;: 37, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;金山枫泾古镇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.895912, &quot;lon&quot;: 121.160238 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G4/M00/35/13/Cii_J1zr5PyIY3acAAFCnHJPxLUAAGX-ABvcIMAAUK0087_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;47066&quot;, &quot;_score&quot;: 1.7713062, &quot;_source&quot;: &#123; &quot;id&quot;: 47066, &quot;name&quot;: &quot;上海浦东东站华美达酒店&quot;, &quot;address&quot;: &quot;施新路958号&quot;, &quot;price&quot;: 408, &quot;score&quot;: 46, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东机场核心区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.147989, &quot;lon&quot;: 121.759199 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60522&quot;, &quot;_score&quot;: 1.7713062, &quot;_source&quot;: &#123; &quot;id&quot;: 60522, &quot;name&quot;: &quot;上海嘉豪淮海国际豪生酒店&quot;, &quot;address&quot;: &quot;汾阳路1号&quot;, &quot;price&quot;: 425, &quot;score&quot;: 45, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;淮海路/新天地地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.215497, &quot;lon&quot;: 121.456297 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/38UBi4QYuaF8jN94CxQ7tb7tjtmZ_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;629729&quot;, &quot;_score&quot;: 1.7713062, &quot;_source&quot;: &#123; &quot;id&quot;: 629729, &quot;name&quot;: &quot;7天连锁酒店(上海张江高科园区店)&quot;, &quot;address&quot;: &quot;浦东新区蔡伦路103号&quot;, &quot;price&quot;: 267, &quot;score&quot;: 36, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;浦东张江地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.196154, &quot;lon&quot;: 121.62071 &#125;, &quot;pic&quot;: &quot;https://m2.tuniucdn.com/filebroker/cdn/res/d9/61/d961508a10865b9b29c033064f31b913_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;47478&quot;, &quot;_score&quot;: 1.732251, &quot;_source&quot;: &#123; &quot;id&quot;: 47478, &quot;name&quot;: &quot;速8酒店(上海松江中心店)&quot;, &quot;address&quot;: &quot;松江荣乐东路677号&quot;, &quot;price&quot;: 428, &quot;score&quot;: 35, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;佘山、松江大学城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.016712, &quot;lon&quot;: 121.261606 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/filebroker/cdn/res/07/36/073662e1718fccefb7130a9da44ddf5c_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;5873072&quot;, &quot;_score&quot;: 1.732251, &quot;_source&quot;: &#123; &quot;id&quot;: 5873072, &quot;name&quot;: &quot;速8酒店（上海火车站北广场店）&quot;, &quot;address&quot;: &quot;闸北芷江西路796号&quot;, &quot;price&quot;: 190, &quot;score&quot;: 41, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.255579, &quot;lon&quot;: 121.452903 &#125;, &quot;pic&quot;: &quot;https://m2.tuniucdn.com/filebroker/cdn/res/96/6d/966d6596e6cb7b48c9cc1d7da79b57c8_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;368343863&quot;, &quot;_score&quot;: 1.732251, &quot;_source&quot;: &#123; &quot;id&quot;: 368343863, &quot;name&quot;: &quot;如家酒店(上海金桥博兴路地铁站店)&quot;, &quot;address&quot;: &quot;博兴路1119号&quot;, &quot;price&quot;: 218, &quot;score&quot;: 45, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.266272, &quot;lon&quot;: 121.593829 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/w5ERtGJEmdgdgy5qtLPatR1xfm4_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; 练习 搜索名字包含“如家”，价格不高于400,在坐标31.21,121.5周围10km范围内的酒店。 GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;如家&quot; &#125; &#125;, &quot;must_not&quot;: &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gt&quot;: 400 &#125; &#125; &#125;, &quot;filter&quot;: &#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;10km&quot;, &quot;location&quot;: &quot;31.21,121.5&quot; &#125; &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 3, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 3, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1.716568, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;433576&quot;, &quot;_score&quot;: 1.716568, &quot;_source&quot;: &#123; &quot;id&quot;: 433576, &quot;name&quot;: &quot;如家酒店(上海南京路步行街店)&quot;, &quot;address&quot;: &quot;南京东路480号保安坊内&quot;, &quot;price&quot;: 379, &quot;score&quot;: 44, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;人民广场地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.236454, &quot;lon&quot;: 121.480948 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/BA/Cii-U13eXVaIQmdaAAWxgzdXXxEAAGRrgNIOkoABbGb143_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;434082&quot;, &quot;_score&quot;: 1.4689932, &quot;_source&quot;: &#123; &quot;id&quot;: 434082, &quot;name&quot;: &quot;如家酒店·neo(上海外滩城隍庙小南门地铁站店)&quot;, &quot;address&quot;: &quot;复兴东路260号&quot;, &quot;price&quot;: 392, &quot;score&quot;: 44, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;豫园地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.220706, &quot;lon&quot;: 121.498769 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-U13eXLGIdHFzAAIG-5cEwDEAAGRfQNNIV0AAgcT627_w200_h200_c1_t0.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1584362548&quot;, &quot;_score&quot;: 1.4178693, &quot;_source&quot;: &#123; &quot;id&quot;: 1584362548, &quot;name&quot;: &quot;如家酒店(上海浦东国际旅游度假区御桥地铁站店)&quot;, &quot;address&quot;: &quot;御青路315-317号&quot;, &quot;price&quot;: 339, &quot;score&quot;: 44, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;周浦康桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.15719, &quot;lon&quot;: 121.572392 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2ybd3wqdoBtBeKcPxmyso9y1hNXa_w200_h200_c1_t0.jpg&quot; &#125; &#125; ] &#125;&#125; 搜索结果处理排序 默认根据相关度算分排序，可以排序字段类型有: keyword类型、数值类型、地理坐标类型(比如 距离最近的酒店)、日期类型等。 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;FIELD&quot;:&quot;desc&quot; &#125;&#125;# 例如# 查询名字里有上海的酒店，按照评分降序、价格升序排列GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;上海&quot; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;score&quot;: &quot;desc&quot; &#125;, &#123; &quot;price&quot;: &quot;asc&quot; &#125; ]&#125; 执行结果 &#123; &quot;took&quot;: 1, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 82, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2056126831&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 2056126831, &quot;name&quot;: &quot;上海虹桥金臣皇冠假日酒店&quot;, &quot;address&quot;: &quot;申长路630弄1-3 号&quot;, &quot;price&quot;: 2488, &quot;score&quot;: 48, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;虹桥机场/国家会展中心&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.19036, &quot;lon&quot;: 121.31535 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 48, 2488 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1649956165&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 1649956165, &quot;name&quot;: &quot;上海南青华美达酒店&quot;, &quot;address&quot;: &quot;华夏东路811号&quot;, &quot;price&quot;: 299, &quot;score&quot;: 47, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;迪士尼度假区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.195206, &quot;lon&quot;: 121.664791 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2RHmQgTpte3UVSDJ5KbqobbZGRnE_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 299 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;598591&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 598591, &quot;name&quot;: &quot;上海丽昂豪生大酒店&quot;, &quot;address&quot;: &quot;金新路99号&quot;, &quot;price&quot;: 529, &quot;score&quot;: 47, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.252496, &quot;lon&quot;: 121.600085 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 529 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56392&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 56392, &quot;name&quot;: &quot;上海银星皇冠假日酒店&quot;, &quot;address&quot;: &quot;番禺路400号&quot;, &quot;price&quot;: 809, &quot;score&quot;: 47, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;徐家汇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.202768, &quot;lon&quot;: 121.429524 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 809 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1913922369&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 1913922369, &quot;name&quot;: &quot;上海中建万怡酒店&quot;, &quot;address&quot;: &quot;蟠文路333号&quot;, &quot;price&quot;: 889, &quot;score&quot;: 47, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;虹桥机场/国家会展中心&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.185504, &quot;lon&quot;: 121.287709 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/39Afm5Bxgd784eMeFB5DrcsPnhT_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 889 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;648219&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 648219, &quot;name&quot;: &quot;上海金桥红枫万豪酒店&quot;, &quot;address&quot;: &quot;新金桥路15号&quot;, &quot;price&quot;: 891, &quot;score&quot;: 47, &quot;brand&quot;: &quot;万豪&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.244061, &quot;lon&quot;: 121.591153 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKuIR_a0AAUx-Xd2JLQAAGRfACSpvUABTIR560_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 891 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;5870456&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 5870456, &quot;name&quot;: &quot;上海宝华万豪酒店&quot;, &quot;address&quot;: &quot;广中西路333号&quot;, &quot;price&quot;: 922, &quot;score&quot;: 47, &quot;brand&quot;: &quot;万豪&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;大宁国际商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.279371, &quot;lon&quot;: 121.446327 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/BA/Cii-U13eXVqIZXDFAAUC_xbrQDAAAGRrwPRyOcABQMX057_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 922 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60398&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 60398, &quot;name&quot;: &quot;上海复旦皇冠假日酒店&quot;, &quot;address&quot;: &quot;邯郸路199号&quot;, &quot;price&quot;: 924, &quot;score&quot;: 47, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.295382, &quot;lon&quot;: 121.502537 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2H1Gk8LHaBWZfYvR6NYYcGTvACmL_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 47, 924 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;47066&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 47066, &quot;name&quot;: &quot;上海浦东东站华美达酒店&quot;, &quot;address&quot;: &quot;施新路958号&quot;, &quot;price&quot;: 408, &quot;score&quot;: 46, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东机场核心区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.147989, &quot;lon&quot;: 121.759199 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2pNujAVaQbXACzkHp8bQMm6zqwhp_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 46, 408 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56852&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 56852, &quot;name&quot;: &quot;上海财大豪生大酒店&quot;, &quot;address&quot;: &quot;武东路188号&quot;, &quot;price&quot;: 592, &quot;score&quot;: 46, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.304182, &quot;lon&quot;: 121.492936 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2jGHezLZvPZqC9cBGesbP5vAhCXi_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 46, 592 ] &#125; ] &#125;&#125; 练习 实现对酒店数据按照到你的位置坐标的距离升序排序 有一些可以在线获取经纬度的网站，如网站1 当前位置为 120.643542,31.258042 GET /hotel/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;_geo_distance&quot;: &#123; &quot;location&quot;: &#123; &quot;lat&quot;: &quot;31.258042&quot;, &quot;lon&quot;: &quot;120.643542&quot; &#125;, &quot;order&quot;: &quot;asc&quot;, &quot;unit&quot;: &quot;km&quot; &#125; &#125; ]&#125; 查询结果，可查看sort字段距离 &#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 201, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;200215226&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 200215226, &quot;name&quot;: &quot;上海颖奕皇冠假日酒店&quot;, &quot;address&quot;: &quot;博园路6555号&quot;, &quot;price&quot;: 907, &quot;score&quot;: 45, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.272533, &quot;lon&quot;: 121.19179 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3Uyfi2aBRETE1K5PChiLVZCwtDLF_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 52.13395383160579 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;339777429&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 339777429, &quot;name&quot;: &quot;上海嘉定喜来登酒店&quot;, &quot;address&quot;: &quot;菊园新区嘉唐公路66号&quot;, &quot;price&quot;: 1286, &quot;score&quot;: 44, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.394595, &quot;lon&quot;: 121.245773 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 59.18378970615253 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2003479905&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 2003479905, &quot;name&quot;: &quot;上海榕港万怡酒店&quot;, &quot;address&quot;: &quot;新松江路1277号&quot;, &quot;price&quot;: 798, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;佘山/松江大学城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.038198, &quot;lon&quot;: 121.210178 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2GM761BYH8k15qkNrJrja3cwfr2D_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 59.205785086643566 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;60916&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 60916, &quot;name&quot;: &quot;上海绿地万怡酒店&quot;, &quot;address&quot;: &quot;沪宜公路3101号&quot;, &quot;price&quot;: 328, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.368523, &quot;lon&quot;: 121.258567 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3VLwG9tTQQnp3M3MTeMTdx9nas9B_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 59.703757750943225 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1942992995&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 1942992995, &quot;name&quot;: &quot;上海嘉定凯悦酒店&quot;, &quot;address&quot;: &quot;裕民南路1366号&quot;, &quot;price&quot;: 758, &quot;score&quot;: 46, &quot;brand&quot;: &quot;凯悦&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.352298, &quot;lon&quot;: 121.263314 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 59.807711496975394 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1725781423&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 1725781423, &quot;name&quot;: &quot;上海三迪华美达酒店&quot;, &quot;address&quot;: &quot;广富林路600弄7号&quot;, &quot;price&quot;: 690, &quot;score&quot;: 43, &quot;brand&quot;: &quot;华美达&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;佘山/松江大学城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.058023, &quot;lon&quot;: 121.246536 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/NoHym6tuKwVazxy33wRNTNuQWd2_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 61.53729226590151 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1913922369&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 1913922369, &quot;name&quot;: &quot;上海中建万怡酒店&quot;, &quot;address&quot;: &quot;蟠文路333号&quot;, &quot;price&quot;: 889, &quot;score&quot;: 47, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;虹桥机场/国家会展中心&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.185504, &quot;lon&quot;: 121.287709 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/39Afm5Bxgd784eMeFB5DrcsPnhT_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 61.78277329609102 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;233036941&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 233036941, &quot;name&quot;: &quot;7天连锁酒店(上海东林寺店)&quot;, &quot;address&quot;: &quot;朱泾镇文商路79号&quot;, &quot;price&quot;: 218, &quot;score&quot;: 37, &quot;brand&quot;: &quot;7天酒店&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;金山枫泾古镇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.895912, &quot;lon&quot;: 121.160238 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G4/M00/35/13/Cii_J1zr5PyIY3acAAFCnHJPxLUAAGX-ABvcIMAAUK0087_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 63.58330395384682 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2056126831&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 2056126831, &quot;name&quot;: &quot;上海虹桥金臣皇冠假日酒店&quot;, &quot;address&quot;: &quot;申长路630弄1-3 号&quot;, &quot;price&quot;: 2488, &quot;score&quot;: 48, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;虹桥机场/国家会展中心&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.19036, &quot;lon&quot;: 121.31535 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 64.32253706416857 ] &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;47478&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;id&quot;: 47478, &quot;name&quot;: &quot;速8酒店(上海松江中心店)&quot;, &quot;address&quot;: &quot;松江荣乐东路677号&quot;, &quot;price&quot;: 428, &quot;score&quot;: 35, &quot;brand&quot;: &quot;速8&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;佘山、松江大学城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.016712, &quot;lon&quot;: 121.261606 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/filebroker/cdn/res/07/36/073662e1718fccefb7130a9da44ddf5c_w200_h200_c1_t0.jpg&quot; &#125;, &quot;sort&quot;: [ 64.65591776725215 ] &#125; ] &#125;&#125; 分页 elasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;, // 分页开始的位置，默认为0 &quot;from&quot;:990, // 期望获取的文档总数 &quot;size&quot;:10, &quot;sort&quot;:&#123; &quot;FIELD&quot;:&quot;desc&quot; &#125;&#125; 需要注意的是：如果配置es集群，此时需要查询前100条数据的情况，应该要去查找每个es分片的前100条，然后聚合这些结果，重新排序选取前100条目前解决方案有两种 search after: 分页时需要排序,原理是从上一次的排序值开始,查询下一页数据。官方推荐使用的方式。适用于手机翻页scroll: 原理将排序数据形成快照，保存在内存。官方已经不推荐使用。from + size: 优点:支持随机翻页 缺点:深度分页问题，默认查询上限(from + size)是10000 场景:百度、京东、谷歌、淘宝这样的随机翻页搜索after search: 优点:没有查询上限(单次查询的size不超过10000) 缺点:只能向后逐页查询，不支持随机翻页 场景:没有随机翻页需求的搜索，例如手机向下滚动翻页.scroll: 优点:没有查询上限(单次查询的size不超过10000) 缺点:会有额外内存消耗，并且搜索结果是非实时的 场景:海量数据的获取和迁移。从ES7.1开始不推荐,建议用aftersearch方案。 高亮 将用户搜索的关键字突出显示 原理是将搜索的关键字用标签标记，通过前端的css标记标签来显示高亮 注意高亮显示的搜索不能使用match_all，因为需要对关键字高亮显示 GET /indexName/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;FIELD&quot;:&quot;TEXT&quot; &#125; &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; // 指定高亮的字段 &quot;FIELD&quot;:&#123; // 高亮字段的前置标签 &quot;pre_tags&quot;:&quot;&lt;em&gt;&quot;, // 高亮字段的后置标签 &quot;post_tags&quot;:&quot;&lt;/ems&gt;&quot; &#125; &#125; &#125;&#125;# 例如GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;all&quot;:&quot;上海&quot; &#125; &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; &quot;name&quot;:&#123; // 默认情况下搜索的字段和高亮的字段需要一样 &quot;require_field_match&quot;: &quot;false&quot;, &quot;pre_tags&quot;:&quot;&lt;em&gt;&quot;, &quot;post_tags&quot;:&quot;&lt;/em&gt;&quot; &#125; &#125; &#125;&#125; 执行结果请查看highlight &#123; &quot;took&quot;: 3, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 82, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1.1486411, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;339777429&quot;, &quot;_score&quot;: 1.1486411, &quot;_source&quot;: &#123; &quot;id&quot;: 339777429, &quot;name&quot;: &quot;上海嘉定喜来登酒店&quot;, &quot;address&quot;: &quot;菊园新区嘉唐公路66号&quot;, &quot;price&quot;: 1286, &quot;score&quot;: 44, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.394595, &quot;lon&quot;: 121.245773 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2v2fKuo5bzhunSBC1n1E42cLTkZV_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;嘉定喜来登酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2022598930&quot;, &quot;_score&quot;: 1.095608, &quot;_source&quot;: &#123; &quot;id&quot;: 2022598930, &quot;name&quot;: &quot;上海宝华喜来登酒店&quot;, &quot;address&quot;: &quot;南奉公路3111弄228号&quot;, &quot;price&quot;: 2899, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.921659, &quot;lon&quot;: 121.575572 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/45/BD/Cii-TF3ZaBmIStrbAASnoOyg7FoAAFpYwEoz9oABKe4992_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;宝华喜来登酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;46829&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 46829, &quot;name&quot;: &quot;上海浦西万怡酒店&quot;, &quot;address&quot;: &quot;恒丰路338号&quot;, &quot;price&quot;: 726, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;上海火车站地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.242977, &quot;lon&quot;: 121.455864 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/x87VCoyaR8cTuYFZmKHe8VC6Wk1_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;浦西万怡酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;644417&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 644417, &quot;name&quot;: &quot;上海外高桥喜来登酒店&quot;, &quot;address&quot;: &quot;自由贸易试验区基隆路28号（二号门内）&quot;, &quot;price&quot;: 2419, &quot;score&quot;: 46, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;浦东外高桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.350989, &quot;lon&quot;: 121.588751 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/1Rrtg9n7PdMEivVDhsehbJBrEre_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;外高桥喜来登酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1463484295&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1463484295, &quot;name&quot;: &quot;上海和平豪生酒店&quot;, &quot;address&quot;: &quot;沪南公路2653-2号&quot;, &quot;price&quot;: 650, &quot;score&quot;: 41, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;周浦康桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.146478, &quot;lon&quot;: 121.568218 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/ZxM9gWHqj657ndRsHw4j4p3CQ5k_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;和平豪生酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1880614409&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1880614409, &quot;name&quot;: &quot;上海崇明由由喜来登酒店&quot;, &quot;address&quot;: &quot;揽海路2888号&quot;, &quot;price&quot;: 2198, &quot;score&quot;: 45, &quot;brand&quot;: &quot;喜来登&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;崇明岛/长兴岛/横沙岛&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.462167, &quot;lon&quot;: 121.823103 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/21gDCGgRT3xFqCd3FxBh633j6Qsu_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;崇明由由喜来登酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1942992995&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1942992995, &quot;name&quot;: &quot;上海嘉定凯悦酒店&quot;, &quot;address&quot;: &quot;裕民南路1366号&quot;, &quot;price&quot;: 758, &quot;score&quot;: 46, &quot;brand&quot;: &quot;凯悦&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;嘉定新城&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.352298, &quot;lon&quot;: 121.263314 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2D/Cii-U13edkqIfZhLAAJEW25WIF4AAGVxQIg38sAAkRz517_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;嘉定凯悦酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;1996823660&quot;, &quot;_score&quot;: 1.0472558, &quot;_source&quot;: &#123; &quot;id&quot;: 1996823660, &quot;name&quot;: &quot;上海紫竹万怡酒店&quot;, &quot;address&quot;: &quot;紫星路588号3幢&quot;, &quot;price&quot;: 642, &quot;score&quot;: 46, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;交大/闵行经济开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.02118, &quot;lon&quot;: 121.465186 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/53/2F/Cii-TF3edraIPzK9AAH_p8vdHKoAAGV3AJgSVEAAf-_019_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;紫竹万怡酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56201&quot;, &quot;_score&quot;: 1.0029912, &quot;_source&quot;: &#123; &quot;id&quot;: 56201, &quot;name&quot;: &quot;上海齐鲁万怡大酒店&quot;, &quot;address&quot;: &quot;东方路838号&quot;, &quot;price&quot;: 873, &quot;score&quot;: 44, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;浦东陆家嘴金融贸易区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.226031, &quot;lon&quot;: 121.525801 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKeIJeN7AASiKHbTtx4AAGRegDSBzMABKJA111_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;齐鲁万怡大酒店&quot; ] &#125; &#125;, &#123; &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;56227&quot;, &quot;_score&quot;: 1.0029912, &quot;_source&quot;: &#123; &quot;id&quot;: 56227, &quot;name&quot;: &quot;上海圣淘沙万怡酒店&quot;, &quot;address&quot;: &quot;南桥镇南桥路1号&quot;, &quot;price&quot;: 899, &quot;score&quot;: 45, &quot;brand&quot;: &quot;万怡&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四星级&quot;, &quot;business&quot;: &quot;奉贤开发区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 30.910917, &quot;lon&quot;: 121.456525 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B9/Cii-U13eXSiIdJjXAARSA6FywFYAAGRnwHvy1AABFIb158_w200_h200_c1_t0.jpg&quot; &#125;, &quot;highlight&quot;: &#123; &quot;name&quot;: [ &quot;&lt;em&gt;上海&lt;/em&gt;圣淘沙万怡酒店&quot; ] &#125; &#125; ] &#125;&#125; ElasticsearchClient查询文档import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionBoostMode;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.json.JsonData;import com.example.domain.doc.HotelDoc;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;/** * 查询语法 * * @Auther: 不是菜狗爱编程 * @Date: 2024/03/27/22:00 * @Description: */@Slf4j@SpringBootTestclass MatchTest &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 根据 city 使用term查询获取相应的文档， search api 才是 elasticsearch-client 的优势，可以看出使用 lambda 大大简化了代码量， * 可以与 restHighLevelClient 形成鲜明的对比，但是也有可读性较差的问题，所以 lambda 的基础要扎实 */ @Test void testRestClient() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.term(t -&gt; t.field(&quot;city&quot;).value(v -&gt; v.stringValue(&quot;上海&quot;)) ) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * match_all */ @Test void matchAllTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.matchAll(matchAll -&gt; matchAll)) , HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * match */ @Test void matchTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.match(matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(&quot;上海&quot;))) , HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * multi_match */ @Test void multiMatchTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.multiMatch(multiMatchQuery -&gt; multiMatchQuery.fields(&quot;city&quot;, &quot;name&quot;).query(&quot;上海&quot;))) , HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * term */ @Test void termTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.term(t -&gt; t.field(&quot;city&quot;).value(v -&gt; v.stringValue(&quot;上海&quot;)) ) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * range * 查找价格大于等于100，小于等于500 */ @Test void rangeTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.range(rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gte(JsonData.of(100)).lte(JsonData.of(500))) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * geo_bounding_box */ @Test void geoBoundingBoxTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.geoBoundingBox(geoBoundingBoxQuery -&gt; geoBoundingBoxQuery.field(&quot;location&quot;) .boundingBox(geoBoundings -&gt; geoBoundings.tlbr(topLeftBottomRightGeoBounds -&gt; topLeftBottomRightGeoBounds // 设置左上角的纬度、经度 .topLeft(geoLocation -&gt; geoLocation.latlon(latLonGeoLocation -&gt; latLonGeoLocation.lat(31.1).lon(121.5))) // 设置右下角的纬度、经度 .bottomRight(geoLocation -&gt; geoLocation.latlon(latLonGeoLocation -&gt; latLonGeoLocation.lat(30.9).lon(121.7))) ) ) ) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * geo_distance */ @Test void geoDistanceTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.geoDistance(geoDistanceQuery -&gt; geoDistanceQuery.distance(&quot;15km&quot;) .field(&quot;location&quot;) .location(geoLocation -&gt; geoLocation .latlon(latLonGeoLocation -&gt; latLonGeoLocation .lat(31.1) .lon(121.5)))) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * function_score */ @Test void functionScoreTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.functionScore(functionScoreQuery -&gt; functionScoreQuery // 匹配all字段中 上海的关键字 .query(query -&gt; query.match(matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(&quot;上海&quot;))) // 给city为上海的数据加分 .functions(functionScore -&gt; functionScore.filter(termQuery -&gt; termQuery.term(t -&gt; t.field(&quot;city&quot;).value(v -&gt; v.stringValue(&quot;上海&quot;)))) // 权重为10，加权方式为求和 .weight(10.0)).boostMode(FunctionBoostMode.Sum) ) ), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * bool */ @Test void boolTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.bool( boolQuery -&gt; boolQuery // city 必须匹配 上海 .must(query -&gt; query.term(termQuery -&gt; termQuery.field(&quot;city&quot;).value(&quot;上海&quot;))) // name 选择性匹配 上海 .should(shouldMatchQuery -&gt; shouldMatchQuery.match(matchQuery -&gt; matchQuery.field(&quot;name&quot;).query(&quot;上海&quot;))) // price 必须不大于500 .mustNot(mustNotRangeQuery -&gt; mustNotRangeQuery.range(rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gt(JsonData.of(500)))) // price 必须大于等于100 .filter(filterRangeQuery -&gt; filterRangeQuery.range(rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gte(JsonData.of(100)))) )), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * 排序 */ @Test void sortTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.match(query -&gt; query.field(&quot;name&quot;).query(&quot;上海&quot;))) .sort(sortOption -&gt; sortOption.field(fieldSort -&gt; fieldSort // 根据score降序 .field(&quot;score&quot;).order(SortOrder.Desc) // 根据price升序 .field(&quot;price&quot;).order(SortOrder.Asc))), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * 分页 */ @Test void pageTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.matchAll(matchAll -&gt; matchAll)) .from(10) .size(10) .sort(sortOption -&gt; sortOption.field(fieldSort -&gt; fieldSort // 根据score降序 .field(&quot;score&quot;).order(SortOrder.Desc))), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125; /** * 高亮 */ @Test void hightLightTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.match(matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(&quot;上海&quot;))) .highlight(highLight -&gt; highLight.fields(&quot;name&quot;, // 默认情况下搜索的字段和高亮的字段需要一样 highLightField -&gt; highLightField.requireFieldMatch(false) .preTags(&quot;em&quot;) .postTags(&quot;em&quot;))), HotelDoc.class); for (Hit&lt;HotelDoc&gt; hit : search.hits().hits()) &#123; log.info(&quot;== hit: source: &#123;&#125;, id: &#123;&#125;&quot;, hit.source(), hit.id()); &#125; &#125;&#125; 黑马旅游案例 前端搭建，下载链接 酒店搜索和分页搜索 这是前端请求的格式key关键字page页码size每页大小sortBy排序字段，比如根据评价、价格排序 POST请求，路径是/hotel/list &#123; &quot;key&quot;: &quot;&quot;, &quot;page&quot;: 1, &quot;size&quot;: 5, &quot;sortBy&quot;: &quot;default&quot;&#125; /** * 搜索参数 * * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:35 * @description: */@Data@AllArgsConstructor@NoArgsConstructorpublic class SearchParams &#123; private String key; private Integer page; private Integer size; private String sortBy;&#125; /** * 分页实体 * * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:48 * @description: */@Data@AllArgsConstructor@NoArgsConstructorpublic class PageEntity &#123; private Long total; private List&lt;HotelDoc&gt; hotels;&#125; @RestController@RequestMapping(&quot;hotel&quot;)public class SearchController &#123; @Autowired private HotelService hotelService; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ @PostMapping(&quot;/list&quot;) public PageEntity search(@RequestBody SearchParams params)&#123; return hotelService.search(params); &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ @Override public PageEntity search(SearchParams params) &#123; // 关键字 String key = params.getKey(); Integer page = params.getPage(); Integer size = params.getSize(); try &#123; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; &#123; // 没有查询条件，查询全部 if (key == null || key.isEmpty()) &#123; return q.matchAll(matchAll -&gt; matchAll); &#125; else &#123; // 有查询条件，查询关键字 return q.match(matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(key)); &#125; &#125;) .from((page - 1) * size) .size(size), HotelDoc.class); return handleResponse(search); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private PageEntity handleResponse(SearchResponse&lt;HotelDoc&gt; response)&#123; // 解析响应 HitsMetadata&lt;HotelDoc&gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List&lt;Hit&lt;HotelDoc&gt;&gt; hotels = hits.hits(); List&lt;HotelDoc&gt; result = new ArrayList&lt;&gt;(); hotels.forEach(hotelDocHit -&gt; &#123; result.add(hotelDocHit.source()); &#125;); return new PageEntity(value,result); &#125;&#125; 当前接口返回的数据 &#123; &quot;total&quot;: 82, &quot;hotels&quot;: [ &#123; &quot;id&quot;: 2056126831, &quot;name&quot;: &quot;上海虹桥金臣皇冠假日酒店&quot;, &quot;address&quot;: &quot;申长路630弄1-3 号&quot;, &quot;price&quot;: 2488, &quot;score&quot;: 48, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;虹桥机场/国家会展中心&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.19036, &quot;lon&quot;: 121.31535 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/PvFh4Vzc84xXhm5N41F6AqdAqyJ_w200_h200_c1_t0.jpg&quot; &#125;, &#123; &quot;id&quot;: 56392, &quot;name&quot;: &quot;上海银星皇冠假日酒店&quot;, &quot;address&quot;: &quot;番禺路400号&quot;, &quot;price&quot;: 809, &quot;score&quot;: 47, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;徐家汇地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.202768, &quot;lon&quot;: 121.429524 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/37ucQ38K3UFdcRqntJ8M5dt884HR_w200_h200_c1_t0.jpg&quot; &#125;, &#123; &quot;id&quot;: 60398, &quot;name&quot;: &quot;上海复旦皇冠假日酒店&quot;, &quot;address&quot;: &quot;邯郸路199号&quot;, &quot;price&quot;: 924, &quot;score&quot;: 47, &quot;brand&quot;: &quot;皇冠假日&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五星级&quot;, &quot;business&quot;: &quot;江湾/五角场商业区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.295382, &quot;lon&quot;: 121.502537 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2H1Gk8LHaBWZfYvR6NYYcGTvACmL_w200_h200_c1_t0.jpg&quot; &#125;, &#123; &quot;id&quot;: 598591, &quot;name&quot;: &quot;上海丽昂豪生大酒店&quot;, &quot;address&quot;: &quot;金新路99号&quot;, &quot;price&quot;: 529, &quot;score&quot;: 47, &quot;brand&quot;: &quot;豪生&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;四钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.252496, &quot;lon&quot;: 121.600085 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2KfPPyPx9rWyVXif2CUuxv61Nryc_w200_h200_c1_t0.jpg&quot; &#125;, &#123; &quot;id&quot;: 648219, &quot;name&quot;: &quot;上海金桥红枫万豪酒店&quot;, &quot;address&quot;: &quot;新金桥路15号&quot;, &quot;price&quot;: 891, &quot;score&quot;: 47, &quot;brand&quot;: &quot;万豪&quot;, &quot;city&quot;: &quot;上海&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;浦东金桥地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.244061, &quot;lon&quot;: 121.591153 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/B6/Cii-TF3eXKuIR_a0AAUx-Xd2JLQAAGRfACSpvUABTIR560_w200_h200_c1_t0.jpg&quot; &#125; ]&#125; 酒店结果过滤 添加参数 @Data@AllArgsConstructor@NoArgsConstructorpublic class SearchParams &#123; private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand ; private String starName ; private Integer minPrice; private Integer maxPrice;&#125; 过滤条件包括 city精确匹配 brand精确匹配 starName精确匹配 price范围过滤 此时有多个条件，应该用bool查询 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ @Override public PageEntity search(SearchParams params) &#123; // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); try &#123; BoolQuery boolQuery = buildBasicQuery(params); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q-&gt;q.bool(boolQuery)) .from((page - 1) * size) .size(size), HotelDoc.class); return handleResponse(search); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private static BoolQuery buildBasicQuery(SearchParams params) &#123; BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) &#123; bool.must( query-&gt;query.matchAll( matchAll -&gt; matchAll) ); &#125; else &#123; // 有查询条件，查询关键字 bool.must( query-&gt;query.match( matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(key) ) ); &#125; // 城市条件 if(city !=null&amp;&amp; !city.isEmpty())&#123; bool.filter( filterQuery-&gt;filterQuery.term( termQuery-&gt;termQuery.field(&quot;city&quot;).value(city) ) ); &#125; // 品牌条件 if(brand !=null&amp;&amp; !brand.isEmpty())&#123; bool.filter( filterQuery-&gt;filterQuery.term( termQuery-&gt;termQuery.field(&quot;brand&quot;).value(brand) ) ); &#125; // 价格条件 if(minPrice !=null&amp;&amp; maxPrice !=null)&#123; bool.filter( filterQuery-&gt;filterQuery.range( rangeQuery-&gt;rangeQuery.field(&quot;price&quot;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); &#125; return bool.build(); &#125; private PageEntity handleResponse(SearchResponse&lt;HotelDoc&gt; response)&#123; // 解析响应 HitsMetadata&lt;HotelDoc&gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List&lt;Hit&lt;HotelDoc&gt;&gt; hotels = hits.hits(); List&lt;HotelDoc&gt; result = new ArrayList&lt;&gt;(); hotels.forEach(hotelDocHit -&gt; &#123; result.add(hotelDocHit.source()); &#125;); return new PageEntity(value,result); &#125;&#125; 我周边的酒店 根据当前定位查找附近的酒店，按照距离升序排序 &#123; &quot;key&quot;: &quot;&quot;, &quot;page&quot;: 1, &quot;size&quot;: 5, &quot;sortBy&quot;: &quot;default&quot;, &quot;city&quot;: &quot;北京&quot;, &quot;brand&quot;: &quot;速8&quot;, &quot;location&quot;: &quot;31.258042,120.643542&quot;&#125; 新增location字段 @Data@AllArgsConstructor@NoArgsConstructorpublic class SearchParams &#123; private String key; private Integer page; private Integer size; private String sortBy; private String city; private String brand ; private String starName ; private Integer minPrice; private Integer maxPrice; private String location;&#125; 新增distance字段 @Data@AllArgsConstructor@NoArgsConstructor@Document(indexName = &quot;hotel&quot;,createIndex = true)public class HotelDoc &#123; @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); &#125;&#125; handleResponse方法添加排序功能 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.DistanceUnit;import co.elastic.clients.elasticsearch._types.FieldValue;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ @Override public PageEntity search(SearchParams params) &#123; // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); String location = params.getLocation(); try &#123; BoolQuery boolQuery = buildBasicQuery(params); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(s -&gt; s.index(INDEX_NAME) .query(q -&gt; q.bool(boolQuery)) .from((page - 1) * size) .size(size) .sort(sortOption -&gt; sortOption.geoDistance( geoDistanceSort -&gt; geoDistanceSort.field(&quot;location&quot;).location( geoLocation -&gt; geoLocation.latlon( latLonGeoLocation -&gt; latLonGeoLocation.lat(31.258042).lon(120.643542) ) ) // 距离升序排序 .order(SortOrder.Asc) // 单位是km .unit(DistanceUnit.Kilometers) )), HotelDoc.class); return handleResponse(search); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private static BoolQuery buildBasicQuery(SearchParams params) &#123; BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) &#123; bool.must( query -&gt; query.matchAll( matchAll -&gt; matchAll) ); &#125; else &#123; // 有查询条件，查询关键字 bool.must( query -&gt; query.match( matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(key) ) ); &#125; // 城市条件 if (city != null &amp;&amp; !city.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;city&quot;).value(city) ) ); &#125; // 品牌条件 if (brand != null &amp;&amp; !brand.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;brand&quot;).value(brand) ) ); &#125; // 价格条件 if (minPrice != null &amp;&amp; maxPrice != null) &#123; bool.filter( filterQuery -&gt; filterQuery.range( rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); &#125; return bool.build(); &#125; private PageEntity handleResponse(SearchResponse&lt;HotelDoc&gt; response) &#123; // 解析响应 HitsMetadata&lt;HotelDoc&gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List&lt;Hit&lt;HotelDoc&gt;&gt; hotels = hits.hits(); List&lt;HotelDoc&gt; result = new ArrayList&lt;&gt;(); hotels.forEach(hotelDocHit -&gt; &#123; HotelDoc source = hotelDocHit.source(); // 获取排序值 List&lt;FieldValue&gt; sort = hotelDocHit.sort(); if(!CollectionUtils.isEmpty(sort))&#123; Double distance = sort.get(0).doubleValue(); assert source != null; source.setDistance(distance); &#125; result.add(source); &#125;); return new PageEntity(value, result); &#125;&#125; 酒店竞价排名 给HotelDoc类添加isAd字段，Boolean类型，表示是否是广告 挑选几个你喜欢的酒店，给它的文档数据添加isAd字段，值为true 修改search方法，添加function score功能,给isAd值为true的酒店增加权重 POST /hotel/_update/46829&#123; &quot;doc&quot;:&#123; &quot;isAd&quot;:true &#125;&#125;POST /hotel/_update/47066&#123; &quot;doc&quot;:&#123; &quot;isAd&quot;:true &#125;&#125; @Data@AllArgsConstructor@NoArgsConstructor@Document(indexName = &quot;hotel&quot;,createIndex = true)public class HotelDoc &#123; @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; /** * 是广告 */ private Boolean isAd; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.DistanceUnit;import co.elastic.clients.elasticsearch._types.FieldValue;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ @Override public PageEntity search(SearchParams params) &#123; // 关键字 Integer page = params.getPage(); Integer size = params.getSize(); String location = params.getLocation(); try &#123; FunctionScoreQuery functionScoreQuery = buildBasicQuery(params); SearchRequest.Builder builder = new SearchRequest.Builder(); builder.index(INDEX_NAME) .query(q -&gt; q.functionScore(functionScoreQuery)) .from((page - 1) * size) .size(size); // 距离排序 if (StringUtils.isNotBlank(location)) &#123; builder.sort(s-&gt;s.geoDistance( geoDistanceSort -&gt; geoDistanceSort.field(&quot;location&quot;).location( geoLocation -&gt; geoLocation.latlon( latLonGeoLocation -&gt; latLonGeoLocation.lat(31.258042).lon(120.643542) ) ) // 距离升序排序 .order(SortOrder.Asc) // 单位是km .unit(DistanceUnit.Kilometers))); &#125; SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(builder.build(), HotelDoc.class); return handleResponse(search); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; private static FunctionScoreQuery buildBasicQuery(SearchParams params) &#123; BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) &#123; bool.must( query -&gt; query.matchAll( matchAll -&gt; matchAll) ); &#125; else &#123; // 有查询条件，查询关键字 bool.must( query -&gt; query.match( matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(key) ) ); &#125; // 城市条件 if (city != null &amp;&amp; !city.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;city&quot;).value(city) ) ); &#125; // 品牌条件 if (brand != null &amp;&amp; !brand.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;brand&quot;).value(brand) ) ); &#125; // 价格条件 if (minPrice != null &amp;&amp; maxPrice != null) &#123; bool.filter( filterQuery -&gt; filterQuery.range( rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); &#125; FunctionScoreQuery.Builder functionScoreBuilder = QueryBuilders.functionScore(); functionScoreBuilder.query( functionScore -&gt; functionScore.functionScore( q -&gt; q.query( boolQuery -&gt; boolQuery.bool(bool.build()) ).functions( f -&gt; f.filter( t -&gt; t.term(termQuery -&gt; termQuery.field(&quot;isAd&quot;).value(true)) ).weight(10.0) ) .scoreMode(FunctionScoreMode.Sum) ) ); return functionScoreBuilder.build(); &#125; private PageEntity handleResponse(SearchResponse&lt;HotelDoc&gt; response) &#123; // 解析响应 HitsMetadata&lt;HotelDoc&gt; hits = response.hits(); assert hits.total() != null; // 总条数 long value = hits.total().value(); List&lt;Hit&lt;HotelDoc&gt;&gt; hotels = hits.hits(); List&lt;HotelDoc&gt; result = new ArrayList&lt;&gt;(); hotels.forEach(hotelDocHit -&gt; &#123; HotelDoc source = hotelDocHit.source(); // 获取排序值 List&lt;FieldValue&gt; sort = hotelDocHit.sort(); if (!CollectionUtils.isEmpty(sort)) &#123; Double distance = sort.get(0).doubleValue(); assert source != null; source.setDistance(distance); &#125; result.add(source); &#125;); return new PageEntity(value, result); &#125;&#125; 数据聚合概念介绍 聚合可以实现对文档数据的统计、分析、运算。聚合常见的有三类: 桶聚合(Bucket)度量聚合(Metric)管道聚合(Pipeline) 桶聚合:用来对文档做分组 TermAggregation:按照文档字段值分组 Date Histogram:按照日期阶梯分组，例如一周为一组，或者一月为一组 度量聚合:用以计算一些值， 比如:最大值、最小值、平均值等 Avg Max Min Stats：同时求max、min、avg、sum等 管道聚合:其它聚合的结果为基础做聚合参与聚合的字段类型必须是: keyword 数值 日期 布尔 桶聚合# 桶聚合GET /hotel/_search&#123; // 设置size为0，结果中不包含文档，只包含聚合结果 &quot;size&quot;:0, // 定义聚合 &quot;aggs&quot;:&#123; // 自己给聚合起个名字 &quot;brandAgg&quot;:&#123; // 聚合的类型，按照品牌值聚合，所以选择term , &quot;terms&quot;: &#123; // 参与聚合的字段 &quot;field&quot;: &quot;brand&quot;, // 希望获取的聚合结果数量 &quot;size&quot;: 10 &#125; &#125; &#125;&#125;# 聚合结果排序GET /hotel/_search&#123; &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;brandAgg&quot;:&#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;order&quot;: &#123; // 升序排序 &quot;_count&quot;: &quot;asc&quot; &#125;, &quot;size&quot;: 10 &#125; &#125; &#125;&#125;# 限定聚合文档的范围，只对某一类文档做聚合GET /hotel/_search&#123; // 对价格小于等于200的文档做聚合 &quot;query&quot;:&#123; &quot;range&quot;:&#123; &quot;price&quot;:&#123; &quot;lte&quot;: 200 &#125; &#125; &#125;, &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;brandAgg&quot;:&#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;size&quot;: 10 &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 21, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 201, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;brandAgg&quot;: &#123; &quot;doc_count_error_upper_bound&quot;: 0, &quot;sum_other_doc_count&quot;: 39, &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;7天酒店&quot;, &quot;doc_count&quot;: 30 &#125;, &#123; &quot;key&quot;: &quot;如家&quot;, &quot;doc_count&quot;: 30 &#125;, &#123; &quot;key&quot;: &quot;皇冠假日&quot;, &quot;doc_count&quot;: 17 &#125;, &#123; &quot;key&quot;: &quot;速8&quot;, &quot;doc_count&quot;: 15 &#125;, &#123; &quot;key&quot;: &quot;万怡&quot;, &quot;doc_count&quot;: 13 &#125;, &#123; &quot;key&quot;: &quot;华美达&quot;, &quot;doc_count&quot;: 13 &#125;, &#123; &quot;key&quot;: &quot;和颐&quot;, &quot;doc_count&quot;: 12 &#125;, &#123; &quot;key&quot;: &quot;万豪&quot;, &quot;doc_count&quot;: 11 &#125;, &#123; &quot;key&quot;: &quot;喜来登&quot;, &quot;doc_count&quot;: 11 &#125;, &#123; &quot;key&quot;: &quot;希尔顿&quot;, &quot;doc_count&quot;: 10 &#125; ] &#125; &#125;&#125; 总结aggs代表聚合，与query同级，此时query的作用是?答：限定聚合的的文档范围聚合必须的三要素: 聚合名称 聚合类型 聚合字段聚合可配置属性有: size:指定聚合结果数量 order:指定聚合结果排序方式 field:指定聚合字段 度量聚合 例如，我们要求获取每个品牌的用户评分的min、max、avg等值 根据上面概念介绍，我们需要获取多个值，单一的Avg、Min、Max查询已经无法满足需求，所以需要使用Stats查询大概思路应该是先对品牌做桶聚合，然后再对该聚合结果继续做度量聚合 GET /hotel/_search&#123; &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;brandAgg&quot;:&#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;size&quot;: 10 &#125;, // brand聚合的子聚合，分组后对每组分别计算 &quot;aggs&quot;:&#123; // 聚合名称 &quot;scoreAgg&quot;:&#123; // 聚合类型，这里的stats可以计算min、max、avg等 &quot;stats&quot;: &#123; // 聚合字段，这里是score &quot;field&quot;: &quot;score&quot; &#125; &#125; &#125; &#125; &#125;&#125;# 结果评分的平均分按照升序排序GET /hotel/_search&#123; &quot;size&quot;:0, &quot;aggs&quot;:&#123; &quot;brandAgg&quot;:&#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;brand&quot;, &quot;size&quot;: 10, &quot;order&quot;: &#123; // 按照平均分升序排序 &quot;scoreAgg.avg&quot;: &quot;asc&quot; &#125; &#125;, &quot;aggs&quot;:&#123; &quot;scoreAgg&quot;:&#123; &quot;stats&quot;: &#123; &quot;field&quot;: &quot;score&quot; &#125; &#125; &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 201, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;aggregations&quot;: &#123; &quot;brandAgg&quot;: &#123; &quot;doc_count_error_upper_bound&quot;: 0, &quot;sum_other_doc_count&quot;: 39, &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;7天酒店&quot;, &quot;doc_count&quot;: 30, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 30, &quot;min&quot;: 35, &quot;max&quot;: 43, &quot;avg&quot;: 37.86666666666667, &quot;sum&quot;: 1136 &#125; &#125;, &#123; &quot;key&quot;: &quot;如家&quot;, &quot;doc_count&quot;: 30, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 30, &quot;min&quot;: 43, &quot;max&quot;: 47, &quot;avg&quot;: 44.833333333333336, &quot;sum&quot;: 1345 &#125; &#125;, &#123; &quot;key&quot;: &quot;皇冠假日&quot;, &quot;doc_count&quot;: 17, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 17, &quot;min&quot;: 44, &quot;max&quot;: 48, &quot;avg&quot;: 46, &quot;sum&quot;: 782 &#125; &#125;, &#123; &quot;key&quot;: &quot;速8&quot;, &quot;doc_count&quot;: 15, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 15, &quot;min&quot;: 35, &quot;max&quot;: 47, &quot;avg&quot;: 38.733333333333334, &quot;sum&quot;: 581 &#125; &#125;, &#123; &quot;key&quot;: &quot;万怡&quot;, &quot;doc_count&quot;: 13, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 13, &quot;min&quot;: 44, &quot;max&quot;: 48, &quot;avg&quot;: 45.69230769230769, &quot;sum&quot;: 594 &#125; &#125;, &#123; &quot;key&quot;: &quot;华美达&quot;, &quot;doc_count&quot;: 13, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 13, &quot;min&quot;: 40, &quot;max&quot;: 47, &quot;avg&quot;: 44, &quot;sum&quot;: 572 &#125; &#125;, &#123; &quot;key&quot;: &quot;和颐&quot;, &quot;doc_count&quot;: 12, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 12, &quot;min&quot;: 44, &quot;max&quot;: 47, &quot;avg&quot;: 46.083333333333336, &quot;sum&quot;: 553 &#125; &#125;, &#123; &quot;key&quot;: &quot;万豪&quot;, &quot;doc_count&quot;: 11, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 11, &quot;min&quot;: 43, &quot;max&quot;: 47, &quot;avg&quot;: 45.81818181818182, &quot;sum&quot;: 504 &#125; &#125;, &#123; &quot;key&quot;: &quot;喜来登&quot;, &quot;doc_count&quot;: 11, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 11, &quot;min&quot;: 44, &quot;max&quot;: 48, &quot;avg&quot;: 46, &quot;sum&quot;: 506 &#125; &#125;, &#123; &quot;key&quot;: &quot;希尔顿&quot;, &quot;doc_count&quot;: 10, &quot;scoreAgg&quot;: &#123; &quot;count&quot;: 10, &quot;min&quot;: 37, &quot;max&quot;: 48, &quot;avg&quot;: 45.4, &quot;sum&quot;: 454 &#125; &#125; ] &#125; &#125;&#125; RestApi实现聚合import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.aggregations.Aggregate;import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.json.JsonData;import co.elastic.clients.util.NamedValue;import com.example.domain.doc.HotelDoc;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.List;import java.util.Map;/** * 聚合测试 * * @author: 不是菜狗爱编程 * @date: 2024/03/31/16:32 * @description: */@SpringBootTestclass AggregationTest &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 桶聚合 * * @throws IOException io异常 */ @Test void bucketTest() throws IOException &#123; SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(&quot;brandAgg&quot;,agg-&gt;agg.terms( termsAggregation-&gt;termsAggregation.field(&quot;brand&quot;).size(10) )); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map&lt;String, Aggregate&gt; map = search.aggregations(); for (Map.Entry&lt;String, Aggregate&gt; entry : map.entrySet()) &#123; System.out.println(&quot;entry.getValue() = &quot; + entry.getValue()); &#125; System.out.println(&quot;============================&quot;); // 或者根据聚合名称来获取聚合结果 Aggregate brandAgg = search.aggregations().get(&quot;brandAgg&quot;); List&lt;StringTermsBucket&gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) &#123; System.out.printf(&quot;酒店品牌:%s 数量%d\\n&quot;,stringTermsBucket.key().stringValue(),stringTermsBucket.docCount()); &#125; &#125; /** * 桶聚合排序 * * @throws IOException io异常 */ @Test void bucketWithSortTest() throws IOException &#123; SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(&quot;brandAgg&quot;,agg-&gt;agg.terms( termsAggregation-&gt;termsAggregation.field(&quot;brand&quot;) .order(NamedValue.of(&quot;_count&quot;, SortOrder.Asc)) .size(10) )); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map&lt;String, Aggregate&gt; map = search.aggregations(); for (Map.Entry&lt;String, Aggregate&gt; entry : map.entrySet()) &#123; System.out.println(&quot;entry.getValue() = &quot; + entry.getValue()); &#125; &#125; /** * 限定聚合文档的范围 * * @throws IOException io异常 */ @Test void bucketWithQualifiedDocument() throws IOException &#123; SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .query(query-&gt;query.range( rangeQuery-&gt;rangeQuery.field(&quot;price&quot;).lte(JsonData.of(200)) )) .size(0) .aggregations(&quot;brandAgg&quot;,agg-&gt;agg.terms( termsAggregation-&gt;termsAggregation.field(&quot;brand&quot;) .size(10) )); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); Map&lt;String, Aggregate&gt; map = search.aggregations(); for (Map.Entry&lt;String, Aggregate&gt; entry : map.entrySet()) &#123; System.out.println(&quot;entry.getValue() = &quot; + entry.getValue()); &#125; &#125;&#125; 黑马旅游实现品牌、城市、星级的聚合基本实现 搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的实现service中的filters方法 public interface HotelService extends IService&lt;Hotel&gt; &#123; /** * 搜索 * * @param params 参数 * @return &#123;@link PageEntity&#125; */ PageEntity search(SearchParams params); /** * 实现品牌、城市、星级的聚合 * * @return &#123;@link Map&#125;&lt;&#123;@link String&#125;, &#123;@link List&#125;&lt;&#123;@link String&#125;&gt;&gt; */ Map&lt;String, List&lt;String&gt;&gt; filters();&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.DistanceUnit;import co.elastic.clients.elasticsearch._types.FieldValue;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.aggregations.Aggregate;import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders;import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; /** * 品牌聚合名称 */ private static final String BRAND_AGGREGATION=&quot;brandAgg&quot;; /** * 城市聚合名称 */ private static final String CITY_AGGREGATION=&quot;cityAgg&quot;; /** * 星级聚合名称 */ private static final String STAR_AGGREGATION=&quot;starAgg&quot;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public Map&lt;String, List&lt;String&gt;&gt; filters() &#123; Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;(); try &#123; SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) .size(0) .aggregations(buildAggregation()); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); // 根据聚合名称来获取聚合结果 Map&lt;String, Aggregate&gt; aggregations = search.aggregations(); List&lt;String&gt; brandList=getAggByName(aggregations,BRAND_AGGREGATION); List&lt;String&gt; cityList=getAggByName(aggregations,CITY_AGGREGATION); List&lt;String&gt; starList=getAggByName(aggregations,STAR_AGGREGATION); result.put(&quot;brand&quot;,brandList); result.put(&quot;city&quot;,cityList); result.put(&quot;star&quot;,starList); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return result; &#125; /** * 按名称获取聚合结果 * * @param aggregations 聚合 * @param aggregationName 聚合名称 * @return &#123;@link List&#125;&lt;&#123;@link String&#125;&gt; */ private List&lt;String&gt; getAggByName(Map&lt;String, Aggregate&gt; aggregations, String aggregationName) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Aggregate brandAgg = aggregations.get(aggregationName); List&lt;StringTermsBucket&gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) &#123; list.add(stringTermsBucket.key().stringValue()); &#125; return list; &#125; public Map&lt;String, Aggregation&gt; buildAggregation()&#123; Map&lt;String, Aggregation&gt; map = new HashMap&lt;&gt;(); // 品牌聚合 Aggregation brandAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;brand&quot;).size(10)); // 城市聚合 Aggregation cityAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;city&quot;).size(10)); // 星级聚合 Aggregation starAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;starName&quot;).size(10)); map.put(BRAND_AGGREGATION,brandAgg); map.put(CITY_AGGREGATION,cityAgg); map.put(STAR_AGGREGATION,starAgg); return map; &#125;&#125; 测试 @SpringBootTestclass HotelServiceImplTest &#123; @Autowired private HotelService hotelService; @Test void filters() &#123; Map&lt;String, List&lt;String&gt;&gt; filters = hotelService.filters(); for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : filters.entrySet()) &#123; System.out.println(entry.getKey() + &quot;= &quot; + entry.getValue()); &#125; &#125;&#125; 日志打印如下 2024-03-31T17:46:47.091+08:00 TRACE 17560 --- [ main] tracer : curl -iX POST &#x27;http://localhost:9200/hotel/_search?typed_keys=true&#x27; -d &#x27;&#123;&quot;aggregations&quot;:&#123;&quot;starAgg&quot;:&#123;&quot;terms&quot;:&#123;&quot;field&quot;:&quot;starName&quot;,&quot;size&quot;:10&#125;&#125;,&quot;brandAgg&quot;:&#123;&quot;terms&quot;:&#123;&quot;field&quot;:&quot;brand&quot;,&quot;size&quot;:10&#125;&#125;,&quot;cityAgg&quot;:&#123;&quot;terms&quot;:&#123;&quot;field&quot;:&quot;city&quot;,&quot;size&quot;:10&#125;&#125;&#125;,&quot;size&quot;:0&#125;&#x27;# HTTP/1.1 200 OK# X-elastic-product: Elasticsearch# content-type: application/vnd.elasticsearch+json;compatible-with=8# content-length: 1072## &#123;&quot;took&quot;:0,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:201,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:null,&quot;hits&quot;:[]&#125;,&quot;aggregations&quot;:&#123;&quot;sterms#starAgg&quot;:&#123;&quot;doc_count_error_upper_bound&quot;:0,&quot;sum_other_doc_count&quot;:0,&quot;buckets&quot;:[&#123;&quot;key&quot;:&quot;二钻&quot;,&quot;doc_count&quot;:84&#125;,&#123;&quot;key&quot;:&quot;五钻&quot;,&quot;doc_count&quot;:49&#125;,&#123;&quot;key&quot;:&quot;四钻&quot;,&quot;doc_count&quot;:28&#125;,&#123;&quot;key&quot;:&quot;五星级&quot;,&quot;doc_count&quot;:20&#125;,&#123;&quot;key&quot;:&quot;三钻&quot;,&quot;doc_count&quot;:13&#125;,&#123;&quot;key&quot;:&quot;四星级&quot;,&quot;doc_count&quot;:7&#125;]&#125;,&quot;sterms#cityAgg&quot;:&#123;&quot;doc_count_error_upper_bound&quot;:0,&quot;sum_other_doc_count&quot;:0,&quot;buckets&quot;:[&#123;&quot;key&quot;:&quot;上海&quot;,&quot;doc_count&quot;:83&#125;,&#123;&quot;key&quot;:&quot;北京&quot;,&quot;doc_count&quot;:62&#125;,&#123;&quot;key&quot;:&quot;深圳&quot;,&quot;doc_count&quot;:56&#125;]&#125;,&quot;sterms#brandAgg&quot;:&#123;&quot;doc_count_error_upper_bound&quot;:0,&quot;sum_other_doc_count&quot;:39,&quot;buckets&quot;:[&#123;&quot;key&quot;:&quot;7天酒店&quot;,&quot;doc_count&quot;:30&#125;,&#123;&quot;key&quot;:&quot;如家&quot;,&quot;doc_count&quot;:30&#125;,&#123;&quot;key&quot;:&quot;皇冠假日&quot;,&quot;doc_count&quot;:17&#125;,&#123;&quot;key&quot;:&quot;速8&quot;,&quot;doc_count&quot;:15&#125;,&#123;&quot;key&quot;:&quot;万怡&quot;,&quot;doc_count&quot;:13&#125;,&#123;&quot;key&quot;:&quot;华美达&quot;,&quot;doc_count&quot;:13&#125;,&#123;&quot;key&quot;:&quot;和颐&quot;,&quot;doc_count&quot;:12&#125;,&#123;&quot;key&quot;:&quot;万豪&quot;,&quot;doc_count&quot;:11&#125;,&#123;&quot;key&quot;:&quot;喜来登&quot;,&quot;doc_count&quot;:11&#125;,&#123;&quot;key&quot;:&quot;希尔顿&quot;,&quot;doc_count&quot;:10&#125;]&#125;&#125;&#125;star= [二钻, 五钻, 四钻, 五星级, 三钻, 四星级]city= [上海, 北京, 深圳]brand= [7天酒店, 如家, 皇冠假日, 速8, 万怡, 华美达, 和颐, 万豪, 喜来登, 希尔顿] 添加过滤条件/** * @author: 不是菜狗爱编程 * @date: 2024/03/30/9:47 * @description: */@RestController@RequestMapping(&quot;hotel&quot;)public class SearchController &#123; @Autowired private HotelService hotelService; @PostMapping(&quot;/filters&quot;) public Map&lt;String, List&lt;String&gt;&gt; filters(@RequestBody SearchParams params)&#123; return hotelService.filters(params); &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.DistanceUnit;import co.elastic.clients.elasticsearch._types.FieldValue;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.aggregations.Aggregate;import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders;import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.Hit;import co.elastic.clients.elasticsearch.core.search.HitsMetadata;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; /** * 品牌聚合名称 */ private static final String BRAND_AGGREGATION=&quot;brandAgg&quot;; /** * 城市聚合名称 */ private static final String CITY_AGGREGATION=&quot;cityAgg&quot;; /** * 星级聚合名称 */ private static final String STAR_AGGREGATION=&quot;starAgg&quot;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public Map&lt;String, List&lt;String&gt;&gt; filters(SearchParams params) &#123; Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;(); try &#123; FunctionScoreQuery functionScoreQuery = buildBasicQuery(params); SearchRequest.Builder searchRequestBuilder = new SearchRequest.Builder(); searchRequestBuilder.index(INDEX_NAME) // 添加过滤条件 .query(q -&gt; q.functionScore(functionScoreQuery)) .size(0) .aggregations(buildAggregation()); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchRequestBuilder.build(), HotelDoc.class); // 根据聚合名称来获取聚合结果 Map&lt;String, Aggregate&gt; aggregations = search.aggregations(); List&lt;String&gt; brandList=getAggByName(aggregations,BRAND_AGGREGATION); List&lt;String&gt; cityList=getAggByName(aggregations,CITY_AGGREGATION); List&lt;String&gt; starList=getAggByName(aggregations,STAR_AGGREGATION); result.put(&quot;brand&quot;,brandList); result.put(&quot;city&quot;,cityList); result.put(&quot;star&quot;,starList); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return result; &#125; /** * 按名称获取聚合结果 * * @param aggregations 聚合 * @param aggregationName 聚合名称 * @return &#123;@link List&#125;&lt;&#123;@link String&#125;&gt; */ private List&lt;String&gt; getAggByName(Map&lt;String, Aggregate&gt; aggregations, String aggregationName) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Aggregate brandAgg = aggregations.get(aggregationName); List&lt;StringTermsBucket&gt; array = brandAgg.sterms().buckets().array(); for (StringTermsBucket stringTermsBucket : array) &#123; list.add(stringTermsBucket.key().stringValue()); &#125; return list; &#125; public Map&lt;String, Aggregation&gt; buildAggregation()&#123; Map&lt;String, Aggregation&gt; map = new HashMap&lt;&gt;(); // 品牌聚合 Aggregation brandAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;brand&quot;).size(10)); // 城市聚合 Aggregation cityAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;city&quot;).size(10)); // 星级聚合 Aggregation starAgg = AggregationBuilders.terms(termsAggregation -&gt; termsAggregation.field(&quot;starName&quot;).size(10)); map.put(BRAND_AGGREGATION,brandAgg); map.put(CITY_AGGREGATION,cityAgg); map.put(STAR_AGGREGATION,starAgg); return map; &#125; private static FunctionScoreQuery buildBasicQuery(SearchParams params) &#123; BoolQuery.Builder bool = QueryBuilders.bool(); String key = params.getKey(); String city = params.getCity(); String brand = params.getBrand(); Integer minPrice = params.getMinPrice(); Integer maxPrice = params.getMaxPrice(); // 没有查询条件，查询全部 if (key == null || key.isEmpty()) &#123; bool.must( query -&gt; query.matchAll( matchAll -&gt; matchAll) ); &#125; else &#123; // 有查询条件，查询关键字 bool.must( query -&gt; query.match( matchQuery -&gt; matchQuery.field(&quot;all&quot;).query(key) ) ); &#125; // 城市条件 if (city != null &amp;&amp; !city.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;city&quot;).value(city) ) ); &#125; // 品牌条件 if (brand != null &amp;&amp; !brand.isEmpty()) &#123; bool.filter( filterQuery -&gt; filterQuery.term( termQuery -&gt; termQuery.field(&quot;brand&quot;).value(brand) ) ); &#125; // 价格条件 if (minPrice != null &amp;&amp; maxPrice != null) &#123; bool.filter( filterQuery -&gt; filterQuery.range( rangeQuery -&gt; rangeQuery.field(&quot;price&quot;).gte(JsonData.of(minPrice)).lte(JsonData.of(maxPrice)) ) ); &#125; FunctionScoreQuery.Builder functionScoreBuilder = QueryBuilders.functionScore(); functionScoreBuilder.query( functionScore -&gt; functionScore.functionScore( q -&gt; q.query( boolQuery -&gt; boolQuery.bool(bool.build()) ).functions( f -&gt; f.filter( t -&gt; t.term(termQuery -&gt; termQuery.field(&quot;isAd&quot;).value(true)) ).weight(10.0) ) .scoreMode(FunctionScoreMode.Sum) ) ); return functionScoreBuilder.build(); &#125;&#125; 自动补全自定义分词器 elasticsearch中分词器(analyzer) 的组成包含三部分: character filters:在tokenizer之 前对文本进行处理。例如删除字符、替换字符 tokenizer:将文本按照-定的规则切割成词条(term) 。例如keyword,就是不分词;还有ik_smart tokenizer filter:将tokenizer输 出的词条做进一步 处理。例如大小写转换、同义词处理、拼音处理等我们可以在创建索引库时，通过settings来配置自定义的analyzer(分词器)这个分词器只对当前索引库有效这里没有 character filters，这里并不需要对特殊字符进行处理PUT /test&#123; &quot;settings&quot;:&#123; &quot;analysis&quot;:&#123; // 自定义分词器 &quot;analyzer&quot;:&#123; // 分词器名称 &quot;my_analyzer&quot;:&#123; &quot;tokenizer&quot;:&quot;ik_max_word&quot;, &quot;filter&quot;:&quot;pinyin&quot; &#125; &#125; &#125; &#125;&#125; 这里的pinyin分词器其实还有些问题，会一个字一个字地转成拼音，而且把中文删除，需要进行进一步的定制 PUT /test&#123; &quot;settings&quot;:&#123; &quot;analysis&quot;:&#123; // 自定义分词器 &quot;analyzer&quot;:&#123; // 分词器名称 &quot;my_analyzer&quot;:&#123; &quot;tokenizer&quot;:&quot;ik_max_word&quot;, &quot;filter&quot;:&quot;py&quot; &#125; &#125;, // 自定义tokenizer filter &quot;filter&quot;:&#123; // 过滤器名称 &quot;py&quot;:&#123; // 过滤器类型，这里是pinyin &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_full_pinyin&quot; : false, &quot;keep_joined_full_pinyin&quot; : true, // 是否要保留中文 &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;remove_duplicated_term&quot; : true, &quot;none_chinese_pinyin_tokenize&quot; : false &#125; &#125; &#125; &#125;&#125;# 例如PUT /test&#123; &quot;settings&quot;:&#123; &quot;analysis&quot;:&#123; // 自定义分词器 &quot;analyzer&quot;:&#123; // 分词器名称 &quot;my_analyzer&quot;:&#123; &quot;tokenizer&quot;:&quot;ik_max_word&quot;, &quot;filter&quot;:&quot;py&quot; &#125; &#125;, // 自定义tokenizer filter &quot;filter&quot;:&#123; // 过滤器名称 &quot;py&quot;:&#123; // 过滤器类型，这里是pinyin &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_full_pinyin&quot; : false, &quot;keep_joined_full_pinyin&quot; : true, // 是否要保留中文 &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;remove_duplicated_term&quot; : true, &quot;none_chinese_pinyin_tokenize&quot; : false &#125; &#125; &#125; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;my_analyzer&quot; &#125; &#125; &#125;&#125; 测试方法1 POST /test/_analyze&#123; &quot;text&quot;:[&quot;建设祖国&quot;], &quot;analyzer&quot;:&quot;my_analyzer&quot;&#125; 执行结果 &#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;今天天气&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;jintiantianqi&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;jttq&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;今天&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;jintian&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;jt&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;天天&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;tiantian&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;tt&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;天气&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;tianqi&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;tq&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125; ]&#125; 测试方法2 # 插入两条测试数据POST /test/_doc/1&#123; &quot;name&quot;:&quot;狮子&quot;&#125;POST /test/_doc/2&#123; &quot;name&quot;:&quot;虱子&quot;&#125;# 查看插入数据GET /test/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125;GET /test/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;name&quot;:&quot;狮子很猛&quot; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 8, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 2, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.33425623, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.33425623, &quot;_source&quot;: &#123; &quot;name&quot;: &quot;狮子&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 0.3085442, &quot;_source&quot;: &#123; &quot;name&quot;: &quot;虱子&quot; &#125; &#125; ] &#125;&#125; 问题 可以看到这里搜的是狮子，但是结果把虱子也搜到了拼音分词器适合在创建倒排索引的时候使用，但不能在搜索的时候使用。用户更希望 输入中文的时候，用中文进行分词搜索，而输入拼音的时候，用拼音来搜索，排除掉输入中文，使用拼音来搜，这样会搜索到同音字因此字段在创建倒排索引时应该用my_analyzer分词器;字段在搜索时应该使用ik_smart分词器为什么这么说呢？可以根据上图多揣摩揣摩在插入文档狮子和虱子的时候，倒排索引中就出现了这四个词条，狮子、shizi、sz、虱子 在搜索的时候，使用ik分词器，输入中文则会对应的中文词条，输入英文则会搜索到对应的英文词条 PUT /test&#123; &quot;settings&quot;:&#123; &quot;analysis&quot;:&#123; &quot;analyzer&quot;:&#123; &quot;my_analyzer&quot;:&#123; &quot;tokenizer&quot;:&quot;ik_max_word&quot;, &quot;filter&quot;:&quot;py&quot; &#125; &#125;, &quot;filter&quot;:&#123; &quot;py&quot;:&#123; &quot;type&quot; : &quot;pinyin&quot;, &quot;keep_full_pinyin&quot; : false, &quot;keep_joined_full_pinyin&quot; : true, &quot;keep_original&quot; : true, &quot;limit_first_letter_length&quot; : 16, &quot;remove_duplicated_term&quot; : true, &quot;none_chinese_pinyin_tokenize&quot; : false &#125; &#125; &#125; &#125;, &quot;mappings&quot;:&#123; &quot;properties&quot;:&#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;text&quot;, &quot;analyzer&quot;:&quot;my_analyzer&quot;, // 指定ik_smart分词器 &quot;search_analyzer&quot;:&quot;ik_smart&quot; &#125; &#125; &#125;&#125; 继续上述测试方法，结果如下 &#123; &quot;took&quot;: 0, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.9530773, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.9530773, &quot;_source&quot;: &#123; &quot;name&quot;: &quot;狮子&quot; &#125; &#125; ] &#125;&#125; completion suggester查询elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束: PUT /test2&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;title&quot;: &#123; &quot;type&quot;: &quot;completion&quot; &#125; &#125; &#125;&#125;// 示例数据POST /test2/_doc&#123; &quot;title&quot;:[&quot;Sony&quot;,&quot;WH-1000XM3&quot;]&#125;POST /test2/_doc&#123; &quot;title&quot;:[&quot;SK-II&quot;,&quot;PITERA&quot;]&#125;POST /test2/_doc&#123; &quot;title&quot;:[&quot;Nintendo&quot;,&quot;Switch&quot;]&#125; 查询语法如下 GET /test2/_search&#123; &quot;suggest&quot;:&#123; // 自定义自动补全的名称 &quot;title_suggest&quot;:&#123; // 关键字 &quot;text&quot;:&quot;s&quot;, &quot;completion&quot;:&#123; // 补全查询的字段 &quot;field&quot;:&quot;title&quot;, // 跳过重复 &quot;skip_duplicates&quot;:true, // 获取前10条结果 &quot;size&quot;:10 &#125; &#125; &#125;&#125; 执行结果 &#123; &quot;took&quot;: 878, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;suggest&quot;: &#123; &quot;title_suggest&quot;: [ &#123; &quot;text&quot;: &quot;s&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 1, &quot;options&quot;: [ &#123; &quot;text&quot;: &quot;SK-II&quot;, &quot;_index&quot;: &quot;test2&quot;, &quot;_id&quot;: &quot;0_HglI4BYJfEHegm4Kw4&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;title&quot;: [ &quot;SK-II&quot;, &quot;PITERA&quot; ] &#125; &#125;, &#123; &quot;text&quot;: &quot;Sony&quot;, &quot;_index&quot;: &quot;test2&quot;, &quot;_id&quot;: &quot;0vHglI4BYJfEHegm2qwt&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;title&quot;: [ &quot;Sony&quot;, &quot;WH-1000XM3&quot; ] &#125; &#125;, &#123; &quot;text&quot;: &quot;Switch&quot;, &quot;_index&quot;: &quot;test2&quot;, &quot;_id&quot;: &quot;1PHglI4BYJfEHegm5qyP&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;title&quot;: [ &quot;Nintendo&quot;, &quot;Switch&quot; ] &#125; &#125; ] &#125; ] &#125;&#125; hotel索引库的自动补全、拼音搜索功能实现思路如下 修改hotel索引库结构，设置自定义拼音分词器 修改索引库的name、all字段，使用自定义分词器 索引库添加一个新字段suggestion,类型为completion类型，使用自定义的分词器 给HotelDoc类添加suggestion字段,内容包含brand、business 重新导入数据到hotel库// 酒店数据索引库PUT /hotel&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;text_anlyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;ik_max_word&quot;, &quot;filter&quot;: &quot;py&quot; &#125;, // 参与自动补全的词条本来是固定的，无需进行分词 &quot;completion_analyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;keyword&quot;, &quot;filter&quot;: &quot;py&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;py&quot;: &#123; &quot;type&quot;: &quot;pinyin&quot;, &quot;keep_full_pinyin&quot;: false, &quot;keep_joined_full_pinyin&quot;: true, &quot;keep_original&quot;: true, &quot;limit_first_letter_length&quot;: 16, &quot;remove_duplicated_term&quot;: true, &quot;none_chinese_pinyin_tokenize&quot;: false &#125; &#125; &#125; &#125;, &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;text_anlyzer&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;address&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;business&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;: &quot;all&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;: &quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;all&quot;:&#123; &quot;type&quot;: &quot;text&quot;, // 创建索引时，使用拼音 &quot;analyzer&quot;: &quot;text_anlyzer&quot;, // 搜索时使用ik_smart，而不需要拼音 &quot;search_analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;suggestion&quot;:&#123; &quot;type&quot;: &quot;completion&quot;, &quot;analyzer&quot;: &quot;completion_analyzer&quot; &#125; &#125; &#125;&#125; @Data@AllArgsConstructor@NoArgsConstructor@Document(indexName = &quot;hotel&quot;,createIndex = true)public class HotelDoc &#123; @Id @Field(type = FieldType.Keyword) private Long id; @Field(type = FieldType.Text) private String name; @Field(type = FieldType.Keyword) private String address; @Field(type = FieldType.Integer) private Integer price; @Field(type = FieldType.Integer) private Integer score; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Keyword) private String city; @Field(type = FieldType.Keyword) private String starName; @Field(type = FieldType.Keyword) private String business; /** * 位置 */ @GeoPointField private GeoPoint location; @Field(type = FieldType.Keyword) private String pic; /** * 距离 */ private Double distance; /** * 是广告 */ private Boolean isAd; /** * 自动补全 */ @Field(type = FieldType.Keyword) private List&lt;String&gt; suggestion; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location=new GeoPoint(Double.parseDouble(hotel.getLatitude()),Double.parseDouble(hotel.getLongitude())); this.pic = hotel.getPic(); // 判断是否有多个值 if(this.business.contains(&quot;/&quot;))&#123; // 商圈是否被&quot;/&quot;分割 String[] arr = this.business.split(&quot;/&quot;); // 添加元素 this.suggestion=new ArrayList&lt;&gt;(); Collections.addAll(this.suggestion,arr); &#125;else &#123; this.suggestion= Arrays.asList(this.brand,this.business); &#125; &#125;&#125; 导入数据 /** * 批量插入文档 * GET /hotel/_doc/36934 * GET /hotel/_doc/38609 */@Testpublic void batchInsertTest () throws IOException &#123; List&lt;Hotel&gt; hotels = hotelService.list(); List&lt;BulkOperation&gt; bulkOperationList = new ArrayList&lt;&gt;(); for (Hotel hotel : hotels) &#123; HotelDoc hotelDoc = new HotelDoc(hotel); bulkOperationList.add(new BulkOperation.Builder().create(e -&gt; e.document(hotelDoc).id(hotel.getId().toString())).build()); &#125; BulkResponse bulkResponse = elasticsearchClient.bulk(bulkRequest -&gt; bulkRequest.index(INDEX_NAME).operations(bulkOperationList) ); // 这边插入成功的话显示的是 false log.info(&quot;== errors: &#123;&#125;&quot;, bulkResponse.errors());&#125; 在kibana中测试一下 GET /hotel/_search&#123; &quot;suggest&quot;:&#123; &quot;suggestions&quot;:&#123; &quot;text&quot;:&quot;sd&quot;, &quot;completion&quot;:&#123; &quot;field&quot;:&quot;suggestion&quot;, &quot;skip_duplicates&quot;:true, &quot;size&quot;:10 &#125; &#125; &#125;&#125; 查询结果 &#123; &quot;took&quot;: 1, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: null, &quot;hits&quot;: [] &#125;, &quot;suggest&quot;: &#123; &quot;suggestions&quot;: [ &#123; &quot;text&quot;: &quot;sd&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 2, &quot;options&quot;: [ &#123; &quot;text&quot;: &quot;上地产业园/西三旗&quot;, &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;2359697&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 2359697, &quot;name&quot;: &quot;如家酒店(北京上地安宁庄东路店)&quot;, &quot;address&quot;: &quot;清河小营安宁庄东路18号20号楼&quot;, &quot;price&quot;: 420, &quot;score&quot;: 46, &quot;brand&quot;: &quot;如家&quot;, &quot;city&quot;: &quot;北京&quot;, &quot;starName&quot;: &quot;二钻&quot;, &quot;business&quot;: &quot;上地产业园/西三旗&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 40.041322, &quot;lon&quot;: 116.333316 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb3/s1/2n9c/2wj2f8mo9WZQCmzm51cwkZ9zvyp8_w200_h200_c1_t0.jpg&quot;, &quot;suggestion&quot;: [ &quot;如家&quot;, &quot;上地产业园/西三旗&quot; ] &#125; &#125;, &#123; &quot;text&quot;: &quot;首都机场/新国展地区&quot;, &quot;_index&quot;: &quot;hotel&quot;, &quot;_id&quot;: &quot;395702&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;id&quot;: 395702, &quot;name&quot;: &quot;北京首都机场希尔顿酒店&quot;, &quot;address&quot;: &quot;首都机场3号航站楼三经路1号&quot;, &quot;price&quot;: 222, &quot;score&quot;: 46, &quot;brand&quot;: &quot;希尔顿&quot;, &quot;city&quot;: &quot;北京&quot;, &quot;starName&quot;: &quot;五钻&quot;, &quot;business&quot;: &quot;首都机场/新国展地区&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 40.048969, &quot;lon&quot;: 116.619566 &#125;, &quot;pic&quot;: &quot;https://m.tuniucdn.com/fb2/t1/G6/M00/52/10/Cii-U13ePtuIMRSjAAFZ58NGQrMAAGKMgADZ1QAAVn_167_w200_h200_c1_t0.jpg&quot;, &quot;suggestion&quot;: [ &quot;希尔顿&quot;, &quot;首都机场/新国展地区&quot; ] &#125; &#125; ] &#125; ] &#125;&#125; RestApi实现import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.CompletionSuggest;import co.elastic.clients.elasticsearch.core.search.CompletionSuggestOption;import co.elastic.clients.elasticsearch.core.search.Suggestion;import com.example.domain.doc.HotelDoc;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.List;/** * 自动补全测试 * * @author: 不是菜狗爱编程 * @date: 2024/04/01/7:13 * @description: */@SpringBootTestclass CompletionTest &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; /** * 自动补全测试 */ @Test void completionTest() throws IOException &#123; SearchRequest.Builder searchBuilder = new SearchRequest.Builder(); // 设置自动补全名称 searchBuilder.index(INDEX_NAME).suggest(suggester -&gt; suggester.suggesters(&quot;suggestions&quot;, // 搜索关键字 suggesters -&gt; suggesters.text(&quot;sh&quot;).completion( // 补全字段 completionSuggester -&gt; completionSuggester.field(&quot;suggestion&quot;) // 跳过重复项 .skipDuplicates(true) // 条数 .size(10) ) )); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchBuilder.build(), HotelDoc.class); // 根据自动补全名称来获取 List&lt;Suggestion&lt;HotelDoc&gt;&gt; suggestions = search.suggest().get(&quot;suggestions&quot;); for (Suggestion&lt;HotelDoc&gt; suggestion : suggestions) &#123; CompletionSuggest&lt;HotelDoc&gt; completion = suggestion.completion(); for (CompletionSuggestOption&lt;HotelDoc&gt; option : completion.options()) &#123; String text = option.text(); System.out.println(&quot;text = &quot; + text); &#125; &#125; &#125;&#125; 黑马旅游实现输入框自动补全 请求url为/hotel/suggestion?key=xxx @RestController@RequestMapping(&quot;hotel&quot;)public class SearchController &#123; @Autowired private HotelService hotelService; @GetMapping(&quot;/suggestion&quot;) public List&lt;String&gt; suggestion(@RequestParam(&quot;key&quot;) String prefix)&#123; return hotelService.getSuggestions(prefix); &#125;&#125; package com.example.service.impl;import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.DistanceUnit;import co.elastic.clients.elasticsearch._types.FieldValue;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.aggregations.Aggregate;import co.elastic.clients.elasticsearch._types.aggregations.Aggregation;import co.elastic.clients.elasticsearch._types.aggregations.AggregationBuilders;import co.elastic.clients.elasticsearch._types.aggregations.StringTermsBucket;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreMode;import co.elastic.clients.elasticsearch._types.query_dsl.FunctionScoreQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.elasticsearch.core.search.*;import co.elastic.clients.json.JsonData;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.domain.Hotel;import com.example.domain.PageEntity;import com.example.domain.SearchParams;import com.example.domain.doc.HotelDoc;import com.example.mapper.HotelMapper;import com.example.service.HotelService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author 不是菜狗爱编程 * @description 针对表【tb_hotel】的数据库操作Service实现 * @createDate 2024-03-27 07:42:58 */@Servicepublic class HotelServiceImpl extends ServiceImpl&lt;HotelMapper, Hotel&gt; implements HotelService &#123; private static final String INDEX_NAME = &quot;hotel&quot;; @Autowired private ElasticsearchClient elasticsearchClient; @Override public List&lt;String&gt; getSuggestions(String prefix) &#123; try &#123; // 返回自动补全结果 List&lt;String&gt; list = new ArrayList&lt;&gt;(); SearchRequest.Builder searchBuilder = new SearchRequest.Builder(); // 设置自动补全名称 searchBuilder.index(INDEX_NAME).suggest(suggester -&gt; suggester.suggesters(&quot;suggestions&quot;, // 搜索关键字 suggesters -&gt; suggesters.text(prefix).completion( // 补全字段 completionSuggester -&gt; completionSuggester.field(&quot;suggestion&quot;) // 跳过重复项 .skipDuplicates(true) // 条数 .size(10) ) )); SearchResponse&lt;HotelDoc&gt; search = elasticsearchClient.search(searchBuilder.build(), HotelDoc.class); // 根据自动补全名称来获取 List&lt;Suggestion&lt;HotelDoc&gt;&gt; suggestions = search.suggest().get(&quot;suggestions&quot;); for (Suggestion&lt;HotelDoc&gt; suggestion : suggestions) &#123; CompletionSuggest&lt;HotelDoc&gt; completion = suggestion.completion(); for (CompletionSuggestOption&lt;HotelDoc&gt; option : completion.options()) &#123; String text = option.text(); list.add(text); &#125; &#125; return list; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 数据同步方案选择 elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变,这个就是elasticsearch与mysql之间的数据同步。 同步调用 存在问题：业务耦合对性能有影响 异步通知 消除耦合，提升了性能 监听binlog 对mysql的压力增加了总结方式一:同步调用优点:实现简单,粗暴缺点:业务耦合度高方式二:异步通知优点:低耦合,实现难度一般缺点:依赖mq的可靠性方式三:监听binlog优点:完全解除服务间耦合缺点:开启binlog增加数据库负担、实现复杂度高 MQ实现数据同步集群","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/categories/elasticsearch/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/tags/elasticsearch/"}]},{"title":"数据结构与算法","slug":"数据结构与算法/数据结构与算法","date":"2024-03-04T00:00:00.000Z","updated":"2024-06-01T14:12:24.882Z","comments":true,"path":"/shu-ju-jie-gou-yu-suan-fa/shu-ju-jie-gou-yu-suan-fa.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-jie-gou-yu-suan-fa/shu-ju-jie-gou-yu-suan-fa.html","excerpt":"","text":"数据结构与算法二分查找import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(0,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 1)); assertEquals(1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 3)); assertEquals(2,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 5)); assertEquals(3,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 7)); assertEquals(4,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 9)); assertEquals(5,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 10)); assertEquals(6,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 13)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 0)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 14)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 8)); &#125; int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 int min = 0, max = arr.length - 1; // 循环条件，需要加等于，否则无法取到边界值 while (min &lt;= max) &#123; // 中间位置 int mid = (min + max) / 2; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; max = mid - 1; // 查找元素在中间元素右边 &#125; else if (arr[mid] &lt; search) &#123; min = mid + 1; &#125; else &#123; // 查找元素就是中间元素 return mid; &#125; &#125; // 没有找到元素 return -1; &#125;&#125; 需要注意的点有循环条件里的等于号不可省略，否则无法取到边界值 同时int mid = (min + max) / 2;这段代码有些问题 如果在数值比较大的情况下，可能导致数值过大，超出int类型能表示的最大数值 正确写法可使用右移运算符int mid = (min + max) &gt;&gt;&gt; 1;平替改动版 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(0, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 1)); assertEquals(1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 3)); assertEquals(2,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 5)); assertEquals(3,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 7)); assertEquals(4,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 9)); assertEquals(5,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 10)); assertEquals(6,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 13)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 0)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 14)); assertEquals(-1,binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 8)); &#125; int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length; // 当min==max时，即可结束 while (min &lt; max) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; // max处的元素肯定不是查找值,(max-1)是可能为查找值的 max = mid; // 查找元素在中间元素右边 &#125; else if (arr[mid] &lt; search) &#123; min = mid + 1; &#125; else &#123; // 查找元素就是中间元素 return mid; &#125; &#125; // 没有找到元素 return -1; &#125;&#125; 上方代码改动了三处 max = arr.length; while (min &lt; max) max = mid; 注意max指向的位置是永远不可能为查找值的 如何衡量算法的好坏时间复杂度用来衡量一个算法的执行，随数据规模增大，而增长的时间成本空间复杂度则是空间成本画图网站 二分查找性能时间复杂度最坏情况: O(logn) 最好情况:如果待查找元素恰好在数组中央，只需要循环一-次0(1) 空间复杂度需要常数个指针i, j, m,因此额外占用的空间是0(1) 当前二分查找的问题如果循环次数为L次，查找元素在最左边if...else查找次数为L次，查找元素在最右边，则次数为2L次继续改动 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(0, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 1)); assertEquals(1, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 3)); assertEquals(2, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 5)); assertEquals(3, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 7)); assertEquals(4, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 9)); assertEquals(5, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 10)); assertEquals(6, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 13)); assertEquals(-1, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 0)); assertEquals(-1, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 14)); assertEquals(-1, binarySearch(new int[]&#123;1, 3, 5, 7, 9, 10, 13&#125;, 8)); &#125; /** * 二分查找 * * @param arr 数组 * @param search 搜索 * @return int */ int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length; // 代表起始和结束位置中间至少有一个待查找元素 while (max - min &gt; 1) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; max = mid; &#125; else &#123; min = mid; &#125; &#125; if(arr[min]== search)&#123; return min; &#125; // 没有找到元素 return -1; &#125; /** * 线性查找 * * @param arr 数组 * @param search 搜索 * @return int */ int linearSearch(int[] arr, int search) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == search) &#123; return i; &#125; &#125; return -1; &#125;&#125; 二分查找Java源码 方法Arrays.binarySearch() private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; long midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found.&#125; 这里在没有找到元素的情况下返回的是-插入点-1 import org.junit.jupiter.api.Test;import java.util.Arrays;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; int[] ints = &#123;1, 3, 5, 7, 9, 10, 13&#125;; int target = 4; int i = Arrays.binarySearch(ints, target); System.out.println(&quot;i = &quot; + i); // 如果查找元素不存在 if (i &lt; 0) &#123; int indexAbs = Math.abs(i + 1); int[] newInts = new int[ints.length + 1]; // 复制数组内容 System.arraycopy(ints, 0, newInts, 0, indexAbs); newInts[indexAbs] = target; System.arraycopy(ints, indexAbs, newInts, indexAbs + 1, ints.length - indexAbs); System.out.println(&quot;indexAbs = &quot; + indexAbs); for (int newInt : newInts) &#123; System.out.printf(&quot;%d\\t&quot;, newInt); &#125; &#125; &#125;&#125; 二分查找如何查找左侧重复元素的索引呢？ 如1,2,2,3,4，查找元素2 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(1, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 3)); assertEquals(-1, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 5)); &#125; /** * 二分查找 * * @param arr 数组 * @param search 搜索 * @return int */ int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length - 1; // 记录重复元素最左侧的索引 int candidate = -1; // 当min==max时，即可结束 while (min &lt;= max) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; // max处的元素肯定不是查找值,(max-1)是可能为查找值的 max = mid - 1; // 查找元素在中间元素右边 &#125; else if (arr[mid] &lt; search) &#123; min = mid + 1; &#125; else &#123; // 查找元素就是中间元素 // 继续向左查找，是否有重复元素 candidate = mid; max = mid - 1; &#125; &#125; // 没有找到元素 return candidate; &#125;&#125; 既然可以查找最左侧，那么最右侧如何实现 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(2, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 3)); assertEquals(-1, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 5)); &#125; /** * 二分查找 * * @param arr 数组 * @param search 搜索 * @return int */ int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length - 1; // 记录重复元素最左侧的索引 int candidate = -1; // 当min==max时，即可结束 while (min &lt;= max) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; // max处的元素肯定不是查找值,(max-1)是可能为查找值的 max = mid - 1; // 查找元素在中间元素右边 &#125; else if (arr[mid] &lt; search) &#123; min = mid + 1; &#125; else &#123; // 查找元素就是中间元素 // 继续向右边查找，是否有重复元素 candidate = mid; min = mid + 1; &#125; &#125; // 没有找到元素 return candidate; &#125;&#125; 当没有找到元素的时候，返回-1 其实这个-1没啥用，可以返回一个&quot;更有用&quot;的值二分查找左侧版 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(1, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 3)); // 如果目标不存在，则查找大于目标且最靠左的值 assertEquals(3, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 5)); &#125; /** * 二分查找 * * @param arr 数组 * @param search 搜索 * @return int */ int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length - 1; // 当min==max时，即可结束 while (min &lt;= max) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt;= search) &#123; // max处的元素肯定不是查找值,(max-1)是可能为查找值的 max = mid - 1; // 查找元素在中间元素右边 &#125; else &#123; min = mid + 1; &#125; &#125; // 没有找到元素 return max + 1; &#125;&#125; 二分查找右侧板 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;/** * 二分查找 * * @Author: 不是菜鸡爱编程 * @Date: 2024/03/02/22:02 * @Description: */class _01BinarySearch &#123; @Test void binarySearchTest() &#123; // 对结果进行断言 assertEquals(2, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 3)); // 如果目标不存在，则查找小于目标且最靠右的值 assertEquals(2, binarySearch(new int[]&#123;1, 3, 3, 7, 9, 10, 13&#125;, 5)); &#125; /** * 二分查找 * * @param arr 数组 * @param search 搜索 * @return int */ int binarySearch(int[] arr, int search) &#123; // 起始位置和结束位置 此时无法取到结束位置,max处的元素并不存在 int min = 0, max = arr.length - 1; // 当min==max时，即可结束 while (min &lt;= max) &#123; // 中间位置 int mid = (min + max) &gt;&gt;&gt; 1; // 查找元素在中间元素左边 if (arr[mid] &gt; search) &#123; // max处的元素肯定不是查找值,(max-1)是可能为查找值的 max = mid - 1; // 查找元素在中间元素右边 &#125; else &#123; min = mid + 1; &#125; &#125; // 没有找到元素 return min - 1; &#125;&#125; 应用场景，在有重复总分的情况下求排名力扣题目 704.二分查找 35.搜索插入位置 34.搜索开始结束位置 数组因为数组内的元素是连续存储的，所以数组中元素的地址，可以通过其索引计算出来知道了数组的数据起始地址BaseAddress,就可以由公式|BaseAddress + i * size计算出索引i元素的地址 i即索引，在Java、C等语言都是从0开始 size是每个元素占用字节，例如int占4, double 占8byte[] array = &#123;1,2,3,4,5&#125; 已知array的数据的起始地址是0x7138f94c8,那么元素3的地址是什么?byte-&gt;每个元素占用1字节0x7138f94c8+2*1=0x7138f94ca 空间占用Java中数组结构为 8字节markword 4字节class指针(压缩class指针的情况) 4字节数组大小(决定了数组最大容量是232) 数组元素+对齐字节(java中所有对象大小都是8字节的整数倍，不足的要用对齐字节补足)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://isunderachiever.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://isunderachiever.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Mockito","slug":"编程语言/Java/学习/框架/Mockito/Mockito","date":"2024-03-01T12:45:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/mockito/mockito.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/mockito/mockito.html","excerpt":"","text":"Mockito基础 当我们mock了某个对象后，调用该方法的时候是并不会去执行实际方法的逻辑的 public class User &#123; private String name = &quot;小张&quot;; private String gender = &quot;男&quot;; private Integer age = 15;&#125;//=================================class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 模拟user对象 User mockUser = mock(User.class); mockUser.setName(&quot;呵呵呵&quot;); mockUser.setGender(&quot;女&quot;); mockUser.setAge(11); System.out.println(&quot;mockUser.getName() = &quot; + mockUser.getName()); System.out.println(&quot;mockUser.getGender() = &quot; + mockUser.getGender()); System.out.println(&quot;mockUser.getAge() = &quot; + mockUser.getAge()); &#125;&#125; 查看覆盖率发现对应的get、set方法没有被调用过 这也就是调用mock对象方法时，不会执行实际逻辑的意思 验证方法被调用的次数import org.junit.jupiter.api.Test;import java.util.List;import static org.mockito.Mockito.*;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest()&#123; // 模拟创建List对象 List mockList = mock(List.class); // add(&quot;星期一&quot;)方法 mockList.add(&quot;星期一&quot;); // 校验add(&quot;星期一&quot;)方法的执行次数是否是1 // times(1)表示该方法执行了一次 verify(mockList,times(1)).add(&quot;星期一&quot;); &#125;&#125; 在Mocktio 4.10.0中还可以使用List mockList = mock();来mock对象，无需传入对应class 模拟方法返回值import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.junit.jupiter.api.Test;import com.example.entity.User;import static org.mockito.Mockito.mock;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 真实user对象 User user = new User(); // 打印为小张 System.out.println(&quot;user.getName() = &quot; + user.getName()); // 模拟user对象 User mockUser = mock(User.class); // 打印为null，因为还没mock方法的返回值 System.out.println(&quot;mockUser.getName() = &quot; + mockUser.getName()); &#125;&#125; mock方法的返回值 when(object.functionName()).thenReturn(result)来mock方法的返回值 import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.junit.jupiter.api.Test;import com.example.entity.User;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 真实user对象 User user = new User(); // 打印为小张 System.out.println(&quot;user.getName() = &quot; + user.getName()); // 模拟user对象 User mockUser = mock(User.class); // mock方法的返回值 when(mockUser.getName()).thenReturn(&quot;小明&quot;); // 打印为小明 System.out.println(&quot;mockUser.getName() = &quot; + mockUser.getName()); &#125;&#125; 当调用mockUser.getName()方法时，会返回小明因为我们mock了该方法的返回值，所以并不会去走实际逻辑，而是直接返回我们mock的返回值小明 模拟异常 mock异常 when(object.functionName()).thenThrow(throwable);来mock异常 import com.example.entity.User;import org.junit.jupiter.api.Test;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 模拟user对象 User mockUser = mock(User.class); when(mockUser.getAge()).thenThrow(new RuntimeException(&quot;年龄保密&quot;)); System.out.println(&quot;mockUser.getAge() = &quot; + mockUser.getAge()); &#125;&#125; 使用doThrow来mock方法体的异常 doThrow(throwable).when(mockObject).functionName(); import com.example.entity.User;import org.junit.jupiter.api.Test;import static org.mockito.Mockito.doThrow;import static org.mockito.Mockito.mock;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 模拟user对象 User mockUser = mock(User.class); doThrow(new RuntimeException(&quot;年龄保密&quot;)).when(mockUser).getAge(); System.out.println(&quot;mockUser.getAge() = &quot; + mockUser.getAge()); &#125;&#125; Mocktio可以配合Junit来使用更加优雅 import com.example.entity.User;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.Mockito.doThrow;import static org.mockito.Mockito.mock;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; // 模拟user对象 User mockUser = mock(User.class); doThrow(new RuntimeException(&quot;年龄保密&quot;)).when(mockUser).getAge(); // 断言异常类型 RuntimeException runtimeException = assertThrows(RuntimeException.class, () -&gt; &#123; // 发生异常的代码块 System.out.println(&quot;mockUser.getAge() = &quot; + mockUser.getAge()); &#125;); // 断言异常信息 assertEquals(&quot;年龄保密&quot;,runtimeException.getMessage()); &#125;&#125; 更多细节class MockitoTest &#123; int generateInt(int num)&#123; return num; &#125;&#125; 希望generateInt方法传入任意值，都返回1 anyInt() import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.ArgumentMatchers.anyInt;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; MockitoTest mockitoTest=mock(MockitoTest.class); when(mockitoTest.generateInt(anyInt())).thenReturn(1); assertEquals(mockitoTest.generateInt(2),1); &#125; int generateInt(int num)&#123; return num; &#125;&#125; atLeast(xxx)、atMost(xxx)mock方法调用的最小、最大次数 verify(mockitoObject,atLeast(num)).functionName(); import org.junit.jupiter.api.Test;import static org.mockito.ArgumentMatchers.anyInt;import static org.mockito.Mockito.*;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; MockitoTest mockitoTest=mock(MockitoTest.class); // 调用三次该方法 mockitoTest.generateInt(1); mockitoTest.generateInt(2); mockitoTest.generateInt(3); verify(mockitoTest,atLeast(3)).generateInt(anyInt()); &#125; int generateInt(int num)&#123; return num; &#125;&#125; when(mockitoTest.generateInt(anyInt())).thenReturn(2).thenReturn(1)支持链式调用 表示第一次调用generateInt返回2，第二次调用返回1 配合Junit断言使用，断言不一致则抛出AssertionFailedError异常 import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.ArgumentMatchers.anyInt;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; MockitoTest mockitoTest = mock(MockitoTest.class); when(mockitoTest.generateInt(anyInt())) // 第一次调用返回2 .thenReturn(2) // 第二次调用返回1 .thenReturn(1); assertEquals(2,mockitoTest.generateInt(1)); assertEquals(1,mockitoTest.generateInt(2)); &#125; int generateInt(int num) &#123; return num; &#125;&#125; 验证执行顺序 将需要排序的对象传入inOrder()方法中 案例中add()方法和verify()的顺序不能反，一定要先执行模拟方法add，然后再verify 校验顺序 import org.junit.jupiter.api.Test;import org.mockito.InOrder;import java.util.List;import static org.mockito.Mockito.inOrder;import static org.mockito.Mockito.mock;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; /** * 函数是否已执行 */ @Test void functionHasExecutedTest() &#123; List mockitoList1 = mock(List.class); List mockitoList2 = mock(List.class); mockitoList1.add(1); mockitoList2.add(1); mockitoList1.add(2); InOrder inOrder = inOrder(mockitoList1, mockitoList2); inOrder.verify(mockitoList1).add(1); inOrder.verify(mockitoList2).add(1); inOrder.verify(mockitoList1).add(2); &#125;&#125; 顺序不一致，则会抛出以下异常信息 org.mockito.exceptions.verification.VerificationInOrderFailure: Verification in order failureWanted but not invoked:list.add(1);-&gt; at com.example.MockitoTest.functionHasExecutedTest(MockitoTest.java:30)Wanted anywhere AFTER following interaction:list.add(2);-&gt; at com.example.MockitoTest.functionHasExecutedTest(MockitoTest.java:26) 注解@Mock @Mock代替Mockito.mock()方法 import org.junit.jupiter.api.Test;import org.mockito.Mock;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */@SpringBootTestclass MockitoTest &#123; @Mock List&lt;Integer&gt; mockitoList; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; when(mockitoList.get(0)).thenReturn(1); System.out.println(&quot;mockitoList.get(0) = &quot; + mockitoList.get(0)); &#125;&#125; 注意@SpringBootTest 或者使用如下写法 import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import java.util.List;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @Mock List&lt;Integer&gt; mockitoList; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; when(mockitoList.get(0)).thenReturn(1); System.out.println(&quot;mockitoList.get(0) = &quot; + mockitoList.get(0)); &#125;&#125; @Spy @Spy用于返回一个真实的对象，@Mock返回的是一个模拟的假对象 除非使用when(xxx).thenReturn(xxx)为其设置返回值，否则将会执行真实的业务逻辑 import com.example.entity.User;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.MockitoAnnotations;import org.mockito.Spy;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @Spy User mockUser; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; System.out.println(&quot;mockUser.getName() = &quot; + mockUser.getName()); &#125;&#125; 可以看到这里执行了getName方法的真实逻辑 @Captor 捕获方法的参数，进行进一步的校验 import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.ArgumentCaptor;import org.mockito.Captor;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import java.util.Map;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @Mock Map&lt;Integer,String&gt; mockMap; @Captor ArgumentCaptor&lt;Integer&gt; key; @Captor ArgumentCaptor&lt;String&gt; value; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; mockMap.put(1,&quot;星期一&quot;); verify(mockMap,times(1)).put(key.capture(),value.capture()); assertEquals(1,key.getValue()); assertEquals(&quot;星期一&quot;,value.getValue()); &#125;&#125; @InjectMocks @InjectMocks注解可以注入指定的Bean，但是和@Autowired有些区别 @Componentpublic class UserMapper &#123; public User selectUserByName(String name)&#123; User user = new User(); user.setName(name); System.out.println(&quot;mapper真实逻辑已执行&quot;); return user; &#125;&#125; @Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User getUserByName(String name)&#123; System.out.println(&quot;service真实逻辑已执行&quot;); return userMapper.selectUserByName(name); &#125;&#125; 这样注入UserService在执行时会报错NullPointerException import com.example.entity.User;import com.example.service.UserService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.MockitoAnnotations;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @InjectMocks UserService userService; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; User userByName = userService.getUserByName(&quot;李四&quot;); System.out.println(&quot;userByName = &quot; + userByName); &#125;&#125; 因为此时只注入了UserService，而UserMapper并没有被注入 请看如下两种写法 使用@Spy来mockUserMapper 使用@Mock来mockUserMapper import com.example.entity.User;import com.example.mapper.UserMapper;import com.example.service.UserService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.MockitoAnnotations;import org.mockito.Spy;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @InjectMocks UserService userService; @Spy UserMapper userMapper; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; User userByName = userService.getUserByName(&quot;李四&quot;); System.out.println(&quot;userByName = &quot; + userByName); &#125;&#125; 以上代码会执行UserMapper的getUserByName方法的真实逻辑 import com.example.entity.User;import com.example.mapper.UserMapper;import com.example.service.UserService;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import static org.mockito.Mockito.when;/** * @Author: 不是菜鸡爱编程 * @Date: 2024/03/03/17:22 * @Description: */class MockitoTest &#123; private AutoCloseable closeable; @InjectMocks UserService userService; @Mock UserMapper userMapper; @BeforeEach void init() &#123; closeable = MockitoAnnotations.openMocks(this); &#125; @AfterEach void destroy() &#123; try &#123; closeable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 函数是否已执行 */ @Test void mockitoTest() &#123; User mockUser = new User(); mockUser.setName(&quot;张三&quot;); // mock方法返回值 when(userMapper.selectUserByName(&quot;李四&quot;)).thenReturn(mockUser); User userByName = userService.getUserByName(&quot;李四&quot;); System.out.println(&quot;userByName = &quot; + userByName); &#125;&#125; 而以上代码并不会去执行真实逻辑 而是返回mock的返回值张三","categories":[{"name":"Mockito","slug":"Mockito","permalink":"https://isunderachiever.github.io/categories/Mockito/"}],"tags":[{"name":"Mockito","slug":"Mockito","permalink":"https://isunderachiever.github.io/tags/Mockito/"}]},{"title":"Nginx","slug":"报错记录/Nginx/Nginx","date":"2024-03-01T10:00:00.000Z","updated":"2024-06-01T14:12:24.846Z","comments":true,"path":"/bao-cuo-ji-lu/nginx/nginx.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/nginx/nginx.html","excerpt":"","text":"Nginx 参考博客前端正常显示，但是请求404比如http://192.168.56.10/api/user/list报404，后端请求http://192.168.56.10:8080/user/list正常显示出现问题的nginx配置如下 events &#123; worker_connections 1024; &#125; http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server &#123; listen 80; server_name localhost; location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; include /etc/nginx/conf.d/*.conf;表示使用的是conf.d下的default.conf文件将/etc/nginx/nginx.conf文件改成 events &#123; worker_connections 1024; &#125; http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; 将/etc/nginx/conf.d/default.conf文件改成 server &#123; listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 主要是在/etc/nginx/conf.d/default.conf文件里添加这一段代码 location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/;&#125; 扩展 location ^~/api/&#123; proxy_pass http://192.168.56.10:8080;&#125; http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/api/user/list location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/;&#125; http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/user/list location ^~/api/&#123; proxy_pass http://192.168.56.10:8080/test;&#125; http://192.168.56.10/api/user/list结果为http://192.168.56.10:8080/test/user/list","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://isunderachiever.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://isunderachiever.github.io/tags/Nginx/"}]},{"title":"Activiti7","slug":"编程语言/Java/学习/框架/Activiti/Activiti7","date":"2024-03-01T10:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/activiti/activiti7.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/activiti/activiti7.html","excerpt":"","text":"全新Activiti7工作流讲解一、Activiti7概述官网地址：https://www.activiti.org/&emsp;&emsp;Activiti由Alfresco软件开发，目前最高版本Activiti 7。是BPMN的一个基于java的软件实现，不过Activiti 不仅仅包括BPMN，还有DMN决策表和CMMN Case管理引擎，并且有自己的用户管理、微服务API等一系列功能，是一个服务平台。 二、Activiti7的入门案例官方手册：http://jeecg.com/activiti5.21/ 1.创建SpringBoot项目&emsp;&emsp;现在开发中或者我们自己学习写案例都是通过SpringBoot脚手架工具来快速构建项目的。那么我们也就直接通过创建SpringBoot项目来给大家讲解相关的案例。创建一个普通的SpringBoot项目。指定版本为2.4.2即可&emsp;&emsp;然后添加对应的依赖：Activiti7的依赖和MySQL的依赖 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.4.2&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.0.0.GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.boge.act.PrepareDemo2Application&lt;/mainClass&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 相关的Activiti依赖加载进来了到这儿基本环境就OK了 2.获取ProcessEngine2.1 默认的方式&emsp;&emsp;在工作流引擎框架中，ProcessEngine是一个非常核心的对象，我们需要首先解决这个对象的获取。获取方式很多。先来看最简单的一个基于activiti.cfg.xml的XML文件的配置方式。 @Testpublic void test1()&#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); System.out.println(processEngine);&#125; &emsp;&emsp;通过getDefaultProcessEngine方法加载会默认的从classpath路径下加载activiti.cfg.xml配置文件。我们添加该文件。内容如下： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/activiti7&quot; /&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;123456&quot; /&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;asyncExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;mailServerHost&quot; value=&quot;mail.my-corp.com&quot; /&gt; &lt;property name=&quot;mailServerPort&quot; value=&quot;5025&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 然后我们就可以启动，但是出现了如下错误：&emsp;&emsp;出现这种情况只需要在mysql的连接字符串中添加上nullCatalogMeansCurrent&#x3D;true，设置为只查当前连接的schema库即可。 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/activiti7?nullCatalogMeansCurrent=true&quot; /&gt; &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;jdbcPassword&quot; value=&quot;123456&quot; /&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;asyncExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;mailServerHost&quot; value=&quot;mail.my-corp.com&quot; /&gt; &lt;property name=&quot;mailServerPort&quot; value=&quot;5025&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 然后执行程序正确。搞定。同时在数据库中创建了相关的表结构 2.2 编程方式获取&emsp;&emsp;上面的配置文件的方式中的配置文件其实是一个Spring的配置文件，但是这并不意味着Activiti只能用于Spring环境。我们也可以通过编程的方式来使用配置文件，从而来构建ProcessEngineConfiguration对象，具体的实现如下： @Testpublic void test2()&#123; ProcessEngine engine = ProcessEngineConfiguration .createStandaloneInMemProcessEngineConfiguration() .setJdbcUrl(&quot;jdbc:mysql://localhost:3306/activiti7?nullCatalogMeansCurrent=true&quot;) .setJdbcDriver(&quot;com.mysql.cj.jdbc.Driver&quot;) .setJdbcPassword(&quot;123456&quot;) .setJdbcUsername(&quot;root&quot;) .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE) .buildProcessEngine(); System.out.println(engine);&#125; 上面讲解中的相关属性说明：databaseSchemaUpdate：用于设置流程引擎启动关闭时使用的数据库表结构控制策略 false (默认): 当引擎启动时，检查数据库表结构的版本是否匹配库文件版本。版本不匹配时抛出异常。 true: 构建引擎时，检查并在需要时更新表结构。表结构不存在则会创建。 create-drop: 引擎创建时创建表结构，并在引擎关闭时删除表结构。 2.3 表结构介绍&emsp;&emsp;在Activiti7中。我们启动服务会自动维护Activiti7需要使用到的相关的表结构。在这块我们需要有个大概的了解。首先是支持的数据库有： Activiti数据库类型 示例JDBC URL 备注 h2 jdbc:h2:tcp:&#x2F;&#x2F;localhost&#x2F;activiti 默认配置的数据库 mysql jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activiti?autoReconnect&#x3D;true 已使用mysql-connector-java数据库驱动测试 oracle jdbc:oracle:thin:@localhost:1521:xe postgres jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;activiti db2 jdbc:db2:&#x2F;&#x2F;localhost:50000&#x2F;activiti mssql jdbc:sqlserver:&#x2F;&#x2F;localhost:1433;databaseName&#x3D;activiti (jdbc.driver&#x3D;com.microsoft.sqlserver.jdbc.SQLServerDriver) OR jdbc:jtds:sqlserver:&#x2F;&#x2F;localhost:1433&#x2F;activiti (jdbc.driver&#x3D;net.sourceforge.jtds.jdbc.Driver) 已使用Microsoft JDBC Driver 4.0 (sqljdb &emsp;&emsp;Activiti的所有数据库表都以**ACT_**开头。第二部分是说明表用途的两字符标示符。服务API的命名也大略符合这个规则。 ACT_RE_*: RE代表repository。带有这个前缀的表包含“静态”信息，例如流程定义与流程资源（图片、规则等）。 ACT_RU_*: RU代表runtime。这些表存储运行时信息，例如流程实例（process instance）、用户任务（user task）、变量（variable）、作业（job）等。Activiti只在流程实例运行中保存运行时数据，并在流程实例结束时删除记录。这样保证运行时表小和快。 ACT_ID_*: ID代表identity。这些表包含身份信息，例如用户、组等。 ACT_HI_*: HI代表history。这些表存储历史数据，例如已完成的流程实例、变量、任务等。 ACT_GE_*: 通用数据。用于不同场景下 注意：MySQL数据库最好使用5.7及以上的版本 3.在线流程设计器&emsp;&emsp;接下来我们通过官方提供的流程设计器来实现一个简单流程的设计。然后完成相关的部署和流程整体操作。官网下载地址：https://www.activiti.org/get-started 下载下来后解压缩进入到wars中。提供的有Activiti-app.war把这war包拷贝到Tomcat服务器中即可。注意Tomcat的版本不要高于8.5，然后Tomcat服务。访问 http://localhost:8080/activiti-app 即可。登录的账号密码是 admin test点击create process 弹出窗口。录入相关的流程定义信息绘制好流程图后。保存并下载对应的xml文件得到的流程图的xml内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:activiti=&quot;http://activiti.org/bpmn&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.activiti.org/processdef&quot;&gt; &lt;process id=&quot;test1&quot; name=&quot;test1&quot; isExecutable=&quot;true&quot;&gt; &lt;documentation&gt;test1&lt;/documentation&gt; &lt;startEvent id=&quot;startEvent1&quot;&gt;&lt;/startEvent&gt; &lt;userTask id=&quot;sid-470631FF-51BA-4954-96BB-346B99CA0A2C&quot; name=&quot;人事审批&quot; activiti:assignee=&quot;zhangsan&quot;&gt; &lt;extensionElements&gt; &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://activiti.com/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id=&quot;sid-B53369E8-E698-4F53-AE40-97E7654BFA78&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-470631FF-51BA-4954-96BB-346B99CA0A2C&quot;&gt;&lt;/sequenceFlow&gt; &lt;userTask id=&quot;sid-34454522-B109-41C9-8519-59D29B621099&quot; name=&quot;经理审批&quot; activiti:assignee=&quot;lisi&quot;&gt; &lt;extensionElements&gt; &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://activiti.com/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id=&quot;sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB&quot; sourceRef=&quot;sid-470631FF-51BA-4954-96BB-346B99CA0A2C&quot; targetRef=&quot;sid-34454522-B109-41C9-8519-59D29B621099&quot;&gt;&lt;/sequenceFlow&gt; &lt;endEvent id=&quot;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C&quot;&gt;&lt;/endEvent&gt; &lt;sequenceFlow id=&quot;sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5&quot; sourceRef=&quot;sid-34454522-B109-41C9-8519-59D29B621099&quot; targetRef=&quot;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C&quot;&gt;&lt;/sequenceFlow&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram id=&quot;BPMNDiagram_test1&quot;&gt; &lt;bpmndi:BPMNPlane bpmnElement=&quot;test1&quot; id=&quot;BPMNPlane_test1&quot;&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;startEvent1&quot; id=&quot;BPMNShape_startEvent1&quot;&gt; &lt;omgdc:Bounds height=&quot;30.0&quot; width=&quot;30.0&quot; x=&quot;100.0&quot; y=&quot;163.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;sid-470631FF-51BA-4954-96BB-346B99CA0A2C&quot; id=&quot;BPMNShape_sid-470631FF-51BA-4954-96BB-346B99CA0A2C&quot;&gt; &lt;omgdc:Bounds height=&quot;80.0&quot; width=&quot;100.0&quot; x=&quot;175.0&quot; y=&quot;138.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;sid-34454522-B109-41C9-8519-59D29B621099&quot; id=&quot;BPMNShape_sid-34454522-B109-41C9-8519-59D29B621099&quot;&gt; &lt;omgdc:Bounds height=&quot;80.0&quot; width=&quot;100.0&quot; x=&quot;320.0&quot; y=&quot;138.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNShape bpmnElement=&quot;sid-EA0332FA-59B0-45C0-9D24-47C78051D52C&quot; id=&quot;BPMNShape_sid-EA0332FA-59B0-45C0-9D24-47C78051D52C&quot;&gt; &lt;omgdc:Bounds height=&quot;28.0&quot; width=&quot;28.0&quot; x=&quot;465.0&quot; y=&quot;164.0&quot;&gt;&lt;/omgdc:Bounds&gt; &lt;/bpmndi:BPMNShape&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB&quot; id=&quot;BPMNEdge_sid-5AE88ADE-9FD3-48F2-81EF-528DA0C068CB&quot;&gt; &lt;omgdi:waypoint x=&quot;275.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;320.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5&quot; id=&quot;BPMNEdge_sid-F6C0657A-C92F-4DEA-AAB1-93750FFBD7E5&quot;&gt; &lt;omgdi:waypoint x=&quot;420.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;465.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;bpmndi:BPMNEdge bpmnElement=&quot;sid-B53369E8-E698-4F53-AE40-97E7654BFA78&quot; id=&quot;BPMNEdge_sid-B53369E8-E698-4F53-AE40-97E7654BFA78&quot;&gt; &lt;omgdi:waypoint x=&quot;130.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;omgdi:waypoint x=&quot;175.0&quot; y=&quot;178.0&quot;&gt;&lt;/omgdi:waypoint&gt; &lt;/bpmndi:BPMNEdge&gt; &lt;/bpmndi:BPMNPlane&gt; &lt;/bpmndi:BPMNDiagram&gt;&lt;/definitions&gt; 然后我们就可以做流程的部署操作了 4.流程操作4.1 流程部署&emsp;&emsp;设计好了流程图我们就可以通过如下的代码完成流程的部署。 /** * 流程部署操作 */ @Test public void test3()&#123; // 1.获取ProcessEngine对象 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 2.完成流程的部署操作 需要通过RepositoryService来完成 RepositoryService repositoryService = processEngine.getRepositoryService(); // 3.完成部署操作 Deployment deploy = repositoryService.createDeployment() .addClasspathResource(&quot;flow/test1.bpmn20.xml&quot;) .name(&quot;第一个流程&quot;) .deploy(); System.out.println(deploy.getId()); System.out.println(deploy.getName()); &#125; 流程部署的行为会涉及到数据库中的这两张表然后我们可以通过Activiti提供的相关的API来获取流程部署和流程定义的相关信息 /** * 查询当前部署的流程有哪些 */@Testpublic void test4()&#123; ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); RepositoryService repositoryService = engine.getRepositoryService(); // 查询有哪些部署的流程--》查询相关的流程定义信息 // repositoryService.createDeploymentQuery() 查询流程部署的相关信息 // repositoryService.createProcessDefinitionQuery() 查询部署的流程的相关的定义 List&lt;Deployment&gt; list = repositoryService.createDeploymentQuery().list(); // 查询所有的部署信息 for (Deployment deployment : list) &#123; System.out.println(deployment.getId()); System.out.println(deployment.getName()); &#125; List&lt;ProcessDefinition&gt; list1 = repositoryService.createProcessDefinitionQuery().list(); for (ProcessDefinition processDefinition : list1) &#123; System.out.println(processDefinition.getId()); System.out.println(processDefinition.getName()); System.out.println(processDefinition.getDescription()); &#125;&#125; 4.2 发起流程&emsp;&emsp;部署流程成功后。我们就可以发起一个流程。发起流程需要通过RuntimeService来实现。 /** * 发起一个流程 */@Testpublic void test5()&#123; ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 发起流程 需要通过 runtimeService来实现 RuntimeService runtimeService = engine.getRuntimeService(); // 通过流程定义ID来启动流程 返回的是流程实例对象 ProcessInstance processInstance = runtimeService .startProcessInstanceById(&quot;test1:1:3&quot;); System.out.println(&quot;processInstance.getId() = &quot; + processInstance.getId()); System.out.println(&quot;processInstance.getDeploymentId() = &quot; + processInstance.getDeploymentId()); System.out.println(&quot;processInstance.getDescription() = &quot; + processInstance.getDescription());&#125; 发起流程成功后。在对应的act_ru_task中就有一条对应的待办记录。对应的流程状态如下： 4.3 查询流程&emsp;&emsp;用户登录后要查看待办的任务信息。我们需要通过TaskService来实现查询操作。具体代码如下： /** * 待办查询 */@Testpublic void test6()&#123; ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 待办查询 执行中的任务处理通过 TaskService来实现 TaskService taskService = engine.getTaskService(); // Task 对象对应的其实就是 act_ru_task 这张表的记录 List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;lisi&quot;).list(); if(list != null &amp;&amp; !list.isEmpty())&#123; for (Task task : list) &#123; System.out.println(&quot;task.getId() = &quot; + task.getId()); System.out.println(&quot;task.getName() = &quot; + task.getName()); System.out.println(&quot;task.getAssignee() = &quot; + task.getAssignee()); &#125; &#125;else&#123; System.out.println(&quot;当前没有待办任务&quot;); &#125;&#125; 4.4 审批流程&emsp;&emsp;当前登录用户查看到相关的待办信息后。可以做流程的审批处理。 /** * 任务审批 */@Testpublic void test7()&#123; ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 做任务申请 也需要通过 TaskService 来实现 TaskService taskService = engine.getTaskService(); // 根据当前登录用户查询出对应的待办信息 List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;lisi&quot;).list(); if(list != null &amp;&amp; list.size() &gt; 0)&#123; for (Task task : list) &#123; // 做对应的任务审批处理 taskService.complete(task.getId()); &#125; &#125; // 完成任务 // taskService.complete(&quot;2505&quot;);&#125; 5.涉及表结构&emsp;&emsp;上面一个审批涉及到的表结构的介绍 表名 说明 act_re_deployment 部署流程的记录表：一次部署行为会产生一张表 act_re_procdef 流程定义表：一张流程图对应的表 act_hi_procinst 流程实例表：发起一个流程。就会创建对应的一张表 act_ru_task 流程待办表：当前需要审批的记录表，节点审批后就会被删除 act_hi_actinst 历史记录：流程审批节点的记录信息 三、表达式值表达式 $&#123;&#125; 方法表达式方法表达式Method expression:调用一个方法， 可以带或不带参数。当调不带参数的方法时，要确保在方法名后添加空括号(以避免与值表达式混淆)。传递的参数可以是字面值,也可以是表达式，它们会被自动解析。例如: $&#123;printer.print()&#125;$&#123;myBean.getAssignee()&#125;$&#123;myBean.addNewOrder(&#x27;orderName&#x27;)&#125;$&#123;myBean.doSomething(myVar,execution)&#125; 监听器","categories":[{"name":"Activiti7","slug":"Activiti7","permalink":"https://isunderachiever.github.io/categories/Activiti7/"}],"tags":[{"name":"Activiti7","slug":"Activiti7","permalink":"https://isunderachiever.github.io/tags/Activiti7/"}]},{"title":"Junit测试","slug":"编程语言/Java/学习/框架/Junit/Junit","date":"2024-02-16T02:22:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/junit/junit.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/junit/junit.html","excerpt":"","text":"Junit测试 这里使用junit5进行演示 正常的情况/** * @Author: 不是菜鸡爱编程 * @Date: 2023/11/29/21:30 * @Description: */public class Calculate &#123; /** * 加 * * @param i 我 * @param j j * @return int */ public static int add(int i,int j)&#123; return i+j; &#125; /** * 减 * * @param i 我 * @param j j * @return int */ public static int sub(int i,int j)&#123; return i-j; &#125; /** * 乘 * * @param i 我 * @param j j * @return int */ public static int multi(int i,int j)&#123; return i*j; &#125; /** * 除 * * @param i 我 * @param j j * @return int */ public static int div(int i,int j)&#123; return i/j; &#125;&#125; 有以上类，我们需要进行测试 在idea中按住Ctrl+Shift+T勾选方法会生成以下模板 class CalculateTest &#123; @Test void add() &#123; &#125; @Test void sub() &#123; &#125; @Test void multi() &#123; &#125; @Test void div() &#123; &#125;&#125; 我们将使用断言Assert来完成测试我们将预期值与实际值进行比较可以看到100%测试覆盖率注释掉一个测试方法后，导致测试覆盖率不足100%，因为有部分代码未被测试到修改预期值后导致测试方法不通过 异常的情况 在Calculate中添加一个方法throwException public class Calculate &#123; // ... public static void throwException()&#123; throw new IllegalStateException(); &#125;&#125; 可能抛出异常的方法该如何测试？测试方法1设置一个标志位 捕获到异常后，更改标志位 断言标志位为True @Testvoid throwException() &#123; boolean flag=false; try &#123; Calculate.throwException(); &#125; catch (IllegalStateException e) &#123; flag=true; &#125; assertTrue(flag);&#125; 测试方法2&gt; 后面是lambda表达式@Testvoid throwException() &#123; assertThrows(IllegalStateException.class, Calculate::throwException);&#125; junit4可使用如下写法 @Test(expected=IndexOutOfBoundsException.class)public void testIndexOutOfBoundsException() &#123; ArrayList emptyList = new ArrayList(); Object o = emptyList.get(0);&#125;","categories":[{"name":"Junit","slug":"Junit","permalink":"https://isunderachiever.github.io/categories/Junit/"}],"tags":[{"name":"Junit","slug":"Junit","permalink":"https://isunderachiever.github.io/tags/Junit/"}]},{"title":"全局组件、局部组件、递归组件","slug":"编程语言/Vue/Vue3/Vue3学习/10.全局组件、局部组件、递归组件","date":"2024-02-16T02:21:00.000Z","updated":"2024-06-01T14:12:25.043Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/10.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/10.html","excerpt":"","text":"配置全局组件 这里封装一个全局组件Global.vue &lt;template&gt; &lt;div id=&quot;global-component&quot; align=&quot;center&quot;&gt; 全局组件 &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;#global-component&#123; border: 1px solid black; margin: 10px 10px; line-height: 25px; width: 80px; height: 25px;&#125;&lt;/style&gt; 在main.ts引入注册，类似element注册 // main.ts// 如果您正在使用CDN引入，请删除下面一行。import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125; import &#123;createApp&#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Global from &quot;@/view/Global.vue&quot;;const app = createApp(App)app.component(&#x27;Global&#x27;,Global)app.mount(&#x27;#app&#x27;) 在其他vue页面 立即使用即可 无需引入&lt;template&gt; &lt;Global/&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;# 批量注册全局组件可以参考element ui 其实就是遍历一下然后通过 app.component 注册# 配置局部组件&lt;template&gt; &lt;div class=&quot;wraps&quot;&gt; &lt;layout-menu :flag=&quot;flag&quot; @on-click=&quot;getMenu&quot; @on-toogle=&quot;getMenuItem&quot; :data=&quot;menuList&quot; class=&quot;wraps-left&quot;&gt;&lt;/layout-menu&gt; &lt;div class=&quot;wraps-right&quot;&gt; &lt;layout-header&gt; &lt;/layout-header&gt; &lt;layout-main class=&quot;wraps-right-main&quot;&gt;&lt;/layout-main&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; reactive,ref &#125; from &quot;vue&quot;;import layoutHeader from &quot;./Header.vue&quot;;import layoutMenu from &quot;./Menu.vue&quot;;import layoutMain from &quot;./Content.vue&quot;;就是在一个组件内（A） 通过import 去引入别的组件(B) 称之为局部组件应为B组件只能在A组件内使用 所以是局部组件如果C组件想用B组件 就需要C组件也手动import 引入 B 组件# 配置递归组件原理跟我们写js递归是一样的 自己调用自己 通过一个条件来结束递归 否则导致内存泄漏案例递归树在父组件配置数据结构 数组对象格式 传给子组件&lt;template&gt; &lt;TreeCom :data=&quot;data&quot;/&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive&#125; from &quot;vue&quot;;import TreeCom from &quot;@/view/TreeCom.vue&quot;;type TreeProps = &#123; name: string, icon?: string, children?: TreeProps[] | []&#125;const data = reactive&lt;TreeProps[]&gt;([ &#123; name: &quot;no.1&quot;, children: [ &#123; name: &quot;no.1-1&quot;, children: [ &#123; name: &quot;no.1-1-1&quot;, &#125;, ], &#125;, ], &#125;, &#123; name: &quot;no.2&quot;, children: [ &#123; name: &quot;no.2-1&quot;, &#125;, ], &#125;, &#123; name: &quot;no.3&quot;, &#125;,])&lt;/script&gt;子组件接收值 第一个scripttype TreeProps = &#123; name: string, icon?: string, children?: TreeProps[] | []&#125;let props=defineProps&lt;&#123; data:TreeProps[]&#125;&gt;();子组件增加一个script 定义组件名称为了 递归用给我们的组件定义名称有好几种方式1.在增加一个script 通过 export 添加name&lt;script lang=&quot;ts&quot;&gt;export default &#123; name:&quot;TreeItem&quot;&#125;&lt;/script&gt; 2.直接使用文件名当组件名3.使用插件unplugin-vue-macros&#x2F;README-zh-CN.md at 722a80795a6c7558debf7c62fd5f57de70e0d0bf · sxzz&#x2F;unplugin-vue-macros · GitHub unplugin-vue-define-options import DefineOptions from &#x27;unplugin-vue-define-options/vite&#x27;import Vue from &#x27;@vitejs/plugin-vue&#x27;export default defineConfig(&#123; plugins: [Vue(), DefineOptions()],&#125;) ts支持 &quot;types&quot;: [&quot;unplugin-vue-define-options/macros-global&quot;], templateTreeItem 其实就是当前组件 通过import 把自身又引入了一遍 如果他没有children 了就结束 &lt;div style=&quot;margin-left:10px;&quot; class=&quot;tree&quot;&gt; &lt;div :key=&quot;index&quot; v-for=&quot;(item,index) in data&quot;&gt; &lt;div @click=&#x27;clickItem(item)&#x27;&gt;&#123;&#123;item.name&#125;&#125; &lt;/div&gt; &lt;TreeItem @on-click=&#x27;clickItem&#x27; v-if=&#x27;item?.children?.length&#x27; :data=&quot;item.children&quot;&gt;&lt;/TreeItem&gt;&lt;/div&gt;&lt;/div&gt; &lt;template&gt; &lt;div v-for=&quot;(item,index) in data&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;TreeCom v-if=&quot;item?.children?.length&quot; :data=&quot;item.children&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;type TreeProps = &#123; name: string, icon?: string, children?: TreeProps[] | []&#125;let props=defineProps&lt;&#123; data:TreeProps[]&#125;&gt;();&lt;/script&gt;&lt;style scoped&gt;div&#123; margin-left: 10px;&#125;&lt;/style&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"Oracle安装配置","slug":"系统配置/编程配置/环境配置/Oracle配置/Oracle安装配置","date":"2024-02-16T02:20:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/oracle-pei-zhi/oracle-an-zhuang-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/oracle-pei-zhi/oracle-an-zhuang-pei-zhi.html","excerpt":"","text":"测试环境概述服务器端操作系统：Windows Server 2008 企业版 64位Oracle软件：Oracle 11g 64位客户端操作系统： Windows 7 64位图形界面工具：PL&#x2F;SQL Developer14.0.5 64位Oracle客户端：Oracle Win64_11gR2_client第一步：**下载**服务端**Oracle 11g安装包**。下载地址：链接：https://pan.baidu.com/s/1ewWtg-hQnB38C27sofA2jA提取码：qwer官方网站下载地址：http://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_client.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_1of2.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_2of2.zip注意：下载OTN上的这些软件，你需要一个OTN免费帐号，不过如果通过迅雷进行下载，就不用登陆OTN了。也可自行在官方网站内下载其他Oracle客户端或图形界面工具版本：https://www.oracle.com/database/technologies/instant-client/downloads.html第二步：Oracle 11g服务端****安装1、解压已经下载的文件，将两个压缩文件包同时解压到同一个目录下，点击“确定”。如下图所示：2、打开安装包路径，找到【setup.exe】双击安装。如下图所示：3、安装前请确保电脑或服务器已经安装好microsoft .net framework 3.5。如不知如何进行安装，可参考（点击后边文字即刻跳转）：如何在内网环境下离线安装.NET Framework3.5。双击安装等待。弹出安装窗口，配置安全更新，如图所示，点“下一步”，提示未提供邮件地址，点“是”跳过。4、安装选项配置，如图所示，点击“下一步”5、系统类配置，可根据自己需求进行选择。这里选择“桌面类”安装。6、典型安装配置，可按实际情况修改安装路径，输入管理口令后点“下一点”。因为是学习环境，所以口令输入比较简单，会提示密码复杂度校验提醒，安装会有如下提示，点“是”跳过即可。7、先决条件检查，物理环境检查无问题，进度条100%，安装自动跳转到下个安装界面。8、概要配置界面预览，如下图所示，点“完成”开始安装产品，等待，大概20分钟左右。安装过程中弹出“创建克隆数据库正在进行”，继续等待即可。弹框，可查看“口令管理”，建议点点看看就可以了，不必要纠结，点击口令管理下的“确定”。9、数据库创建完成，如图所示，点击“关闭”。到此Oracle就安装完成了。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Linux命令","slug":"编程语言/Shell/linux命令","date":"2024-02-15T15:00:00.000Z","updated":"2024-06-01T14:12:25.022Z","comments":true,"path":"/bian-cheng-yu-yan/shell/linux-ming-ling.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/shell/linux-ming-ling.html","excerpt":"","text":"tar包tar -zxvf XXX.tar.gz nacoscd /usr/local/nacos/bin# 启动命令sudo sh startup.sh -m standalone zookeeper 启动失败，可参考博客 博客1、博客2、博客3 cd /usr/local/zookeeper/bin# 启动zookeeper./zkServer.sh start# 停止zookeeper./zkServer.sh stop# 查看状态./zkServer.sh status# 连接zookeeper./zkCli.sh -server 192.168.56.10:2181# 查看ls /ls /dubbo","categories":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://isunderachiever.github.io/categories/Linux%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://isunderachiever.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Vue媒介查询","slug":"实用小技巧/编程/媒介查询/媒介查询","date":"2024-02-15T15:00:00.000Z","updated":"2024-06-01T14:12:24.843Z","comments":true,"path":"/shi-yong-xiao-ji-qiao/bian-cheng/mei-jie-cha-xun/mei-jie-cha-xun.html","link":"","permalink":"https://isunderachiever.github.io/shi-yong-xiao-ji-qiao/bian-cheng/mei-jie-cha-xun/mei-jie-cha-xun.html","excerpt":"","text":"&lt;template&gt; &lt;div class=&quot;header-div&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;$breakPoints: ( &#x27;phone&#x27;:( 320px, 480px ), &#x27;pad&#x27;:( 481px, 768px ), &#x27;notebook&#x27;:( 769px, 1024px ), &#x27;desktop&#x27;:( 1025px, 1200px ), &#x27;tv&#x27;:( 1201px ),);// 混合@mixin respond-to($breakName) &#123; $bp: map-get($breakPoints, $breakName); @if type-of($bp)== &#x27;list&#x27; &#123; $min: nth($bp, 1); $max: nth($bp, 2); @media (min-width: $min) and (max-width: $max) &#123; @content; &#125; &#125; @else &#123; @media (min-width: $bp) &#123; @content; &#125; &#125;&#125;.header-div &#123; width: 100%; @include respond-to(&#x27;phone&#x27;) &#123; background-color: red; height: 40px; &#125; @include respond-to(&#x27;pad&#x27;) &#123; height: 60px; &#125; @include respond-to(&#x27;notebook&#x27;) &#123; background-color: green; height: 80px; &#125;&#125;&lt;/style&gt;","categories":[{"name":"Vue媒介查询","slug":"Vue媒介查询","permalink":"https://isunderachiever.github.io/categories/Vue%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"Vue媒介查询","slug":"Vue媒介查询","permalink":"https://isunderachiever.github.io/tags/Vue%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/"}]},{"title":"Flowable","slug":"编程语言/Java/学习/框架/Flowable/Flowable","date":"2024-02-15T15:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/flowable/flowable.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/flowable/flowable.html","excerpt":"","text":"Flowable 一般数据对应表 act_ge_bytearray 通用的流程定义和流程资源 act_ge_property 系统相关属性 流程历史记录表 ——————- —————————- act_hi_actinst 历史的流程实例 act_hi_attachment 历史的流程附件 act_hi_comment 历史的说明性信息 act_hi_detail 历史的流程运行中的细节信息 act_hi_entitylink 任务参与者数据表 act_hi_identitylink 历史的流程运行过程中用户关系 act_hi_procinst 历史的流程实例 act_hi_taskinst 历史的任务实例 act_hi_tsk_log 每一次执行可能会带上的数据 act_hi_varinst 历史的流程运行中的变量信息 用户用户组表 ——————- —————— act_id_bytearray 二进制数据表 act_id_group 用户组信息表 act_id_info 用户信息详情表 act_id_membership 人与组关系表 act_id_priv 权限表 act_id_priv_mapping 用户或组权限关系表 act_id_property 属性表 act_id_token 系统登录日志表 act_id_user 用户表 流程定义表 —————– —————- act_re_deployment 部署单元信息 act_re_model 模型信息 act_re_procdef 已部署的流程定义 运行实例表 ——————— —————————————— act_ru_actinst 流程实例每一个活动对应的状态表 act_ru_deadletter_job 作业失败表，失败次数&gt;重试次数 act_ru_entitylink 实例的父子关系表 act_ru_event_subscr 运行时事件 act_ru_execution 运行时流程执行实例 act_ru_external_job 使用作业表来实现异步逻辑、计时器或历史处理 act_ru_history_job 历史作业表 act_ru_identitylink 用户或组的数据及其与流程实例相关的角色表 act_ru_job 运行时作业表 act_ru_suspended_job 运行时挂起的定时作业表 act_ru_task 正在运行的实例的每个未完成用户任务的条目 act_ru_timer_job 运行时定时器表 act_ru_variable 实例相关的变量 其他表 —————- ———— act_evt_log 事件日志表 act_procdef_info 流程定义信息","categories":[{"name":"Flowable","slug":"Flowable","permalink":"https://isunderachiever.github.io/categories/Flowable/"}],"tags":[{"name":"Flowable","slug":"Flowable","permalink":"https://isunderachiever.github.io/tags/Flowable/"}]},{"title":"TSX","slug":"编程语言/Vue/Vue3/Vue3学习/20.TSX","date":"2023-07-27T14:40:00.000Z","updated":"2024-06-01T14:12:25.056Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/20.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/20.html","excerpt":"","text":"TSX 安装、配置 npm install @vitejs/plugin-vue-jsx -D vite.config.ts import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;plugins: [ vueJsx()] 写法1export default function ()&#123; return ( &lt;div&gt;测试tsx&lt;/div&gt; )&#125; &lt;template&gt; &lt;Test/&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import Test from &quot;@/view/Test.tsx&quot;;&lt;/script&gt; 写法2import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; data()&#123; let age=23 return&#123; age &#125; &#125;, render()&#123; return( &lt;div&gt;age:&#123;this.age&#125;&lt;/div&gt; ) &#125;&#125;) methods import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; data()&#123; let age=23 return&#123; age &#125; &#125;, methods:&#123; test()&#123; console.log(&#x27;测试方法运行&#x27;); &#125; &#125;, render()&#123; return( &lt;div onClick=&#123;()=&gt;this.test()&#125;&gt;age:&#123;this.age&#125;&lt;/div&gt; ) &#125;&#125;) 写法3import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup()&#123; let age=23; let test=()=&gt;&#123; console.log(&#x27;测试方法已运行&#x27;); &#125; return ()=&gt;( &lt;div onClick=&#123;test&#125;&gt;age:&#123;age&#125;&lt;/div&gt; ) &#125;&#125;) v-show 支持 import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup()&#123; let flag:boolean=false; return ()=&gt;( &lt;div v-show=&#123;flag&#125;&gt;hhh&lt;/div&gt; ) &#125;&#125;) ref 在html标签中，需要使用.value来获取 import &#123;defineComponent, ref&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup()&#123; let flag=ref&lt;boolean&gt;(false); return ()=&gt;( &lt;div v-show=&#123;flag.value&#125;&gt;hhh&lt;/div&gt; ) &#125;&#125;) v-if 不支持 三元表达式写法 import &#123;defineComponent, ref&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup()&#123; let flag=ref&lt;boolean&gt;(false); return ()=&gt;( &lt;div&gt;&#123;flag.value?&#x27;显示&#x27;:&#x27;隐藏&#x27;&#125;&lt;/div&gt; ) &#125;&#125;) v-for 不支持 数组.map遍历写法 import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup()&#123; let data=[ &#123; name:&#x27;aaa&#x27;, age:12 &#125;, &#123; name:&#x27;bbb&#x27;, age:22 &#125; ] return ()=&gt;( &lt;div&gt;&#123;data.map(item=&gt;&#123; return &lt;div&gt;name:&#123;item.name&#125;--age:&#123;item.age&#125;&lt;/div&gt; &#125;)&#125;&lt;/div&gt; ) &#125;&#125;) v-bindimport &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup() &#123; let data = [ &#123; name: &#x27;aaa&#x27;, age: 12 &#125;, &#123; name: &#x27;bbb&#x27;, age: 22 &#125; ] return () =&gt; ( &lt;div&gt;&#123;data.map(item =&gt; &#123; return &lt;div name=&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;/div&gt; &#125;)&#125;&lt;/div&gt; ) &#125;&#125;) props&#x2F;emit Test.tsx import &#123;defineComponent&#125; from &quot;vue&quot;;interface Props &#123; name?: string&#125;export default defineComponent(&#123; props: &#123; name: String &#125;, emits: [&#x27;on-click&#x27;], setup(props: Props, &#123;emit&#125;) &#123; let emitFun = (content: string) =&gt; &#123; console.log(&#x27;触发了emit&#x27;); emit(&#x27;on-click&#x27;, content) &#125;; return () =&gt; ( &lt;&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; emitFun(&#x27;测试内容&#x27;)&#125;&gt;点击&lt;/button&gt; &lt;/&gt; ) &#125;&#125;) Home.vue &lt;template&gt; &lt;Test name=&quot;马小跳&quot; @on-click=&quot;getEmit&quot;/&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import Test from &quot;@/view/Test.tsx&quot;;let getEmit=(item:string)=&gt;&#123; console.log(&#x27;item:&#x27;,item);&#125;&lt;/script&gt; 插槽import &#123;defineComponent&#125; from &quot;vue&quot;;export default defineComponent(&#123; setup() &#123; const A = (_, &#123;slots&#125;) =&gt; ( &lt;&gt; &lt;div&gt;&#123;slots.default ? slots.default() : &#x27;默认值&#x27;&#125;&lt;/div&gt; &lt;/&gt; ) const slot = &#123; default: () =&gt; (&lt;div&gt;default slots&lt;/div&gt;) &#125; return () =&gt; ( &lt;&gt; &lt;A v-slots=&#123;slot&#125;/&gt; &lt;/&gt; ) &#125;&#125;)","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"兄弟组件传参和Bus","slug":"编程语言/Vue/Vue3/Vue3学习/19.兄弟组件传参和Bus","date":"2023-07-26T13:16:00.000Z","updated":"2024-06-01T14:12:25.055Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/19.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/19.html","excerpt":"","text":"兄弟组件传参和Bus Home &lt;template&gt; &lt;A @on-click=&quot;getFlag&quot;/&gt; &lt;B :flag=&quot;flag&quot;/&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;provide, reactive, readonly, ref&#125; from &#x27;vue&#x27;import A from &#x27;./A.vue&#x27;import B from &#x27;./B.vue&#x27;const flag=ref&lt;boolean&gt;(false)const getFlag=(props:boolean)=&gt;&#123; flag.value=props&#125;&lt;/script&gt; A &lt;template&gt;&lt;button @click=&quot;emitB&quot;&gt;传递flag&lt;/button&gt;当前flag值为&#123;&#123;flag&#125;&#125;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;inject, reactive, ref&#125; from &#x27;vue&#x27;;import type &#123;Ref&#125; from &quot;vue&quot;;let flag=ref&lt;boolean&gt;(true)const emit=defineEmits([&#x27;on-click&#x27;])const emitB=()=&gt;&#123; flag.value=!flag.value emit(&#x27;on-click&#x27;,flag.value)&#125;&lt;/script&gt;&lt;style scoped&gt;button&#123; width: 80px; height: 30px;&#125;&lt;/style&gt; B &lt;template&gt; &lt;div&gt;B接收到值了:&#123;&#123;flag&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;inject, reactive, ref&#125; from &#x27;vue&#x27;;import type &#123;Ref&#125; from &quot;vue&quot;;type Props=&#123; flag:boolean&#125;defineProps&lt;Props&gt;();&lt;/script&gt; Event Bus 安装mitt库 npm install mitt -S import &#123;createApp&#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import mitt from &quot;mitt&quot;;const Mit = mitt()//TypeScript注册// 由于必须要拓展ComponentCustomProperties类型才能获得类型提示declare module &quot;vue&quot; &#123; export interface ComponentCustomProperties &#123; $Bus: typeof Mit &#125;&#125;const app = createApp(App)//Vue3挂载全局APIapp.config.globalProperties.$Bus = Mit 使用方法通过emit派发， on 方法添加事件，off 方法移除，clear 清空所有A组件派发（emit） &lt;template&gt; &lt;div&gt; &lt;h1&gt;我是A&lt;/h1&gt; &lt;button @click=&quot;emit1&quot;&gt;emit1&lt;/button&gt; &lt;button @click=&quot;emit2&quot;&gt;emit2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;const instance = getCurrentInstance();const emit1 = () =&gt; &#123; instance?.proxy?.$Bus.emit(&#x27;on-num&#x27;, 100)&#125;const emit2 = () =&gt; &#123; instance?.proxy?.$Bus.emit(&#x27;*****&#x27;, 500)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; B组件监听（on） &lt;template&gt; &lt;div&gt; &lt;h1&gt;我是B&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;const instance = getCurrentInstance()instance?.proxy?.$Bus.on(&#x27;on-num&#x27;, (num) =&gt; &#123; console.log(num,&#x27;===========&gt;B&#x27;)&#125;)&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 监听所有事件（ on(“*”) ） instance?.proxy?.$Bus.on(&#x27;*&#x27;,(type,num)=&gt;&#123; console.log(type,num,&#x27;===========&gt;B&#x27;)&#125;) 移除监听事件（off） const Fn = (num: any) =&gt; &#123; console.log(num, &#x27;===========&gt;B&#x27;)&#125;instance?.proxy?.$Bus.on(&#x27;on-num&#x27;,Fn)//listeninstance?.proxy?.$Bus.off(&#x27;on-num&#x27;,Fn)//unListen 清空所有监听（clear） instance?.proxy?.$Bus.all.clear()","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"transitiongroup过度列表","slug":"编程语言/Vue/Vue3/Vue3学习/17.transitiongroup过度列表","date":"2023-07-24T14:00:00.000Z","updated":"2024-06-01T14:12:25.052Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/17.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/17.html","excerpt":"","text":"transitiongroup过度列表 单个节点 多个节点，每次只渲染一个那么怎么同时渲染整个列表，比如使用 v-for？在这种场景下，我们会使用 &lt;transition-group&gt; 组件。在我们深入例子之前，先了解关于这个组件的几个特点： 默认情况下，它不会渲染一个包裹元素，但是你可以通过 tag attribute 指定渲染一个元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素总是需要提供唯一的 key attribute 值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组&#x2F;容器本身。&lt;transition-group&gt; &lt;div style=&quot;margin: 10px;&quot; :key=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&lt;/div&gt;&lt;/transition-group&gt;const list = reactive&lt;number[]&gt;([1, 2, 4, 5, 6, 7, 8, 9])const Push = () =&gt; &#123; list.push(123)&#125;const Pop = () =&gt; &#123; list.pop()&#125; &lt;template&gt; &lt;button @click=&quot;Push&quot;&gt;插入&lt;/button&gt; &lt;button @click=&quot;Pop&quot;&gt;删除&lt;/button&gt; &lt;div class=&quot;box&quot;&gt; &lt;transition-group&gt; &lt;div style=&quot;margin: 10px;&quot; :key=&quot;item&quot; v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineAsyncComponent, reactive, ref&#125; from &quot;vue&quot;;import &#x27;animate.css&#x27;const list = reactive&lt;number[]&gt;([1, 2, 3])const Push = () =&gt; &#123; list.push(list.length+1)&#125;const Pop = () =&gt; &#123; list.pop()&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.box&#123; display: flex; flex-wrap: wrap;&#125;&lt;/style&gt; 2.列表的移动过渡lodash npm install lodash -Snpm install @types/lodash -D &lt;transition-group&gt; 组件还有一个特殊之处。除了进入和离开，它还可以为定位的改变添加动画。只需了解新增的 v-move 类就可以使用这个新功能，它会应用在元素改变定位的过程中。像之前的类名一样，它的前缀可以通过 name attribute 来自定义，也可以通过 move-class attribute 手动设置下面代码很酷炫 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt; &lt;transition-group class=&quot;wraps&quot; name=&quot;mmm&quot; tag=&quot;ul&quot;&gt; &lt;li class=&quot;cell&quot; v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.number &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import _ from &#x27;lodash&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let items = ref(Array.apply(null, &#123; length: 81 &#125; as number[]).map((_, index) =&gt; &#123; return &#123; id: index, number: (index % 9) + 1 &#125;&#125;))const shuffle = () =&gt; &#123; items.value = _.shuffle(items.value)&#125;&lt;/script&gt; &lt;style scoped lang=&quot;less&quot;&gt;.wraps &#123; display: flex; flex-wrap: wrap; width: calc(25px * 10 + 9px); .cell &#123; width: 25px; height: 25px; border: 1px solid #ccc; list-style-type: none; display: flex; justify-content: center; align-items: center; &#125;&#125;.mmm-move &#123; transition: transform 0.8s ease;&#125;&lt;/style&gt; 3.状态过度&lt;template&gt; &lt;div&gt; &lt;input step=&quot;20&quot; v-model=&quot;num.current&quot; type=&quot;number&quot;/&gt; &lt;div&gt;&#123;&#123; num.tweenedNumber.toFixed(0) &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;reactive, watch&#125; from &#x27;vue&#x27;import gsap from &#x27;gsap&#x27;const num = reactive(&#123; tweenedNumber: 0, current: 0&#125;)watch(() =&gt; num.current, (newVal) =&gt; &#123; gsap.to(num, &#123; duration: 1, tweenedNumber: newVal &#125;)&#125;)&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"transition动画组件","slug":"编程语言/Vue/Vue3/Vue3学习/16.transition动画组件","date":"2023-07-24T12:00:00.000Z","updated":"2024-06-01T14:12:25.051Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/16.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/16.html","excerpt":"","text":"transition动画组件自定义过渡 class 类名trasnsition props enter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class自定义过度时间 单位毫秒你也可以分别指定进入和离开的持续时间：&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; &lt;template&gt; &lt;button @click=&quot;flag=!flag&quot;&gt;点击&#123;&#123; flag ? &#x27;隐藏&#x27; : &#x27;显示&#x27; &#125;&#125;&lt;/button&gt; &lt;transition leave-from-class=&quot;leaveFrom&quot; leave-active-class=&quot;leaveActive&quot; leave-to-class=&quot;leaveTo&quot; enter-from-class=&quot;enterFrom&quot; enter-active-class=&quot;enterActive&quot; enter-to-class=&quot;enterTo&quot;&gt; &lt;div id=&quot;att&quot; v-if=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineAsyncComponent, reactive, ref&#125; from &quot;vue&quot;;import A from &#x27;./A.vue&#x27;const flag = ref&lt;boolean&gt;(true)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;#att &#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.leaveFrom&#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.leaveActive&#123; transition: all 1.5s ease;&#125;.leaveTo&#123; margin: 10px 10px; width: 0; height: 0; background: red;&#125;.enterTo&#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.enterActive&#123; transition: all 1s linear;&#125;.enterFrom&#123; margin: 10px 10px; width: 0; height: 0; background: red;&#125;&lt;/style&gt; 通过自定义class 结合css动画库animate cssnpm install animate.css 官网引入 import &#x27;animate.css&#x27; 使用方法官方文档 Animate.css | A cross-browser library of CSS animations.&lt;transition leave-active-class=&quot;animate__animated animate__bounceInLeft&quot; enter-active-class=&quot;animate__animated animate__bounceInRight&quot;&gt; &lt;div v-if=&quot;flag&quot; class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/transition&gt; &lt;template&gt; &lt;button @click=&quot;flag=!flag&quot;&gt;点击&#123;&#123; flag ? &#x27;隐藏&#x27; : &#x27;显示&#x27; &#125;&#125;&lt;/button&gt; &lt;transition leave-active-class=&quot;animate__animated animate__bounceInLeft&quot; enter-active-class=&quot;animate__animated animate__bounceInRight&quot;&gt; &lt;div id=&quot;att&quot; v-if=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineAsyncComponent, reactive, ref&#125; from &quot;vue&quot;;import A from &#x27;./A.vue&#x27;import &#x27;animate.css&#x27;const flag = ref&lt;boolean&gt;(true)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;#att &#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.leaveFrom&#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.leaveActive&#123; transition: all 1.5s ease;&#125;.leaveTo&#123; margin: 10px 10px; width: 0; height: 0; background: red;&#125;.enterTo&#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;.enterActive&#123; transition: all 1s linear;&#125;.enterFrom&#123; margin: 10px 10px; width: 0; height: 0; background: red;&#125;&lt;/style&gt; 3.transition 生命周期8个@before-enter=&quot;beforeEnter&quot; //对应enter-from@enter=&quot;enter&quot;//对应enter-active@after-enter=&quot;afterEnter&quot;//对应enter-to@enter-cancelled=&quot;enterCancelled&quot;//显示过度打断@before-leave=&quot;beforeLeave&quot;//对应leave-from@leave=&quot;leave&quot;//对应enter-active@after-leave=&quot;afterLeave&quot;//对应leave-to@leave-cancelled=&quot;leaveCancelled&quot;//离开过度打断 当只用 JavaScript 过渡的时候，在 enter 和 leave 钩子中必须使用 done 进行回调结合gsap 动画库使用 GreenSock npm install gsap -S 引入 import gsap from &#x27;gsap&#x27; const beforeEnter = (el: Element) =&gt; &#123; console.log(&#x27;进入之前from&#x27;, el);&#125;const Enter = (el: Element,done:Function) =&gt; &#123; console.log(&#x27;过度曲线&#x27;); setTimeout(()=&gt;&#123; done() &#125;,3000)&#125;const AfterEnter = (el: Element) =&gt; &#123; console.log(&#x27;to&#x27;);&#125; &lt;template&gt; &lt;button @click=&quot;flag=!flag&quot;&gt;点击&#123;&#123; flag ? &#x27;隐藏&#x27; : &#x27;显示&#x27; &#125;&#125;&lt;/button&gt; &lt;transition @beforeEnter=&quot;enterFrom&quot; @enter=&quot;enterActive&quot;&gt; &lt;div id=&quot;att&quot; v-if=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineAsyncComponent, reactive, ref&#125; from &quot;vue&quot;;import A from &#x27;./A.vue&#x27;import &#x27;animate.css&#x27;import gsap from &#x27;gsap&#x27;const flag = ref&lt;boolean&gt;(true)let enterFrom=(el:Element)=&gt;&#123; gsap.set(el,&#123; width:0, height:0 &#125;);&#125;let enterActive=(el:Element,done:gsap.Callback)=&gt;&#123; gsap.to(el,&#123; width:300, height:300 &#125;);&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;#att &#123; margin: 10px 10px; width: 300px; height: 300px; background: red;&#125;&lt;/style&gt; 4.appear通过这个属性可以设置初始节点过度 就是页面加载完成就开始动画 对应三个状态 appear-active-class=&quot;&quot;appear-from-class=&quot;&quot;appear-to-class=&quot;&quot;appear","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"watchEffect高级侦听器","slug":"编程语言/Vue/Vue3/Vue3学习/07.watchEffect高级侦听器","date":"2023-07-17T15:00:00.000Z","updated":"2024-06-01T14:12:25.039Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/07.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/07.html","excerpt":"","text":"watchEffect高级侦听器 原博客执行传入的函数，同时响应式追踪其依赖，当依赖改变时重新运行该函数 import &#123;ref, watchEffect&#125; from &#x27;vue&#x27;;let message = ref&lt;number&gt;(0)watchEffect(() =&gt; &#123; console.log(&#x27;message&#x27;, message.value);&#125;) 清除副作用 在触发监听之前会调用一个函数来处理逻辑，如防抖 &lt;script setup lang=&quot;ts&quot;&gt;import &#123; watchEffect, ref &#125; from &#x27;vue&#x27;let message = ref&lt;number&gt;(0)watchEffect((beforeTest) =&gt; &#123; beforeTest(()=&gt;&#123; console.log(&#x27;测试前&#x27;); &#125;) console.log(&#x27;message&#x27;, message.value);&#125;)&lt;/script&gt; 停止跟踪 watchEffect 返回一个函数 调用之后将停止更新 &lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;message++&quot;&gt;测试&lt;/button&gt; &lt;button @click=&quot;stopWatch&quot;&gt;停止监听&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; watchEffect, ref &#125; from &#x27;vue&#x27;let message = ref&lt;number&gt;(0)let stopWatch=watchEffect((beforeTest) =&gt; &#123; beforeTest(()=&gt;&#123; console.log(&#x27;测试前&#x27;); &#125;) console.log(&#x27;message&#x27;, message.value);&#125;)&lt;/script&gt; 刷新时机 pre sync post 更新时机 组件更新前执行 同步执行 组件更新后执行 &lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;message++&quot;&gt;测试&lt;/button&gt; &lt;button @click=&quot;stopWatch&quot;&gt;停止监听&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;watchEffect, ref&#125; from &#x27;vue&#x27;let message = ref&lt;number&gt;(0)let stopWatch = watchEffect((beforeTest) =&gt; &#123; beforeTest(() =&gt; &#123; console.log(&#x27;测试前&#x27;); &#125;) console.log(&#x27;message&#x27;, message.value);&#125;, &#123; flush: &#x27;post&#x27;, onTrigger() &#123; console.log(&#x27;更新前&#x27;); &#125;&#125;)&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"sass学习","slug":"编程语言/Vue/Vue3/Vue3学习/08.sass学习","date":"2023-07-17T15:00:00.000Z","updated":"2024-06-01T14:12:25.040Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/08.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/08.html","excerpt":"","text":"sass学习 sass官方文档 less官方文档 原博客bem架构BEM实际上是block、element、modifier的缩写，分别为块层、元素层、修饰符层BEM 命名约定的模式是： .block &#123;&#125; .block__element &#123;&#125; .block--modifier &#123;&#125; 嵌套规则 Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器 #main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125; 父选择器 &amp;a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; 变量 $$width: 5em;#main &#123; width: $width;&#125; 插值语句 #&#123;&#125;$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; @at-root@media print &#123; .page &#123; width: 8in; @at-root (without: media) &#123; color: red; &#125; &#125;&#125; 编译后 @media print &#123; .page &#123; width: 8in; &#125;&#125;.page &#123; color: red;&#125; 定义混合指令 @mixin 混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： @mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 引用混合样式 @include@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 编译后 .page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px;&#125; 练习:实现layout布局$block-sel: &quot;-&quot; !default;$element-sel: &quot;__&quot; !default;$modifier-sel: &quot;--&quot; !default;$namespace:&#x27;xm&#x27; !default;@mixin bfc &#123; height: 100%; overflow: hidden;&#125; //混入@mixin b($block) &#123; $B: $namespace + $block-sel + $block; //变量 .#&#123;$B&#125;&#123; //插值语法#&#123;&#125; @content; //内容替换 &#125;&#125; @mixin flex &#123; display: flex;&#125; @mixin e($element) &#123; $selector:&amp;; @at-root &#123; #&#123;$selector + $element-sel + $element&#125; &#123; @content; &#125; &#125;&#125; @mixin m($modifier) &#123; $selector:&amp;; @at-root &#123; #&#123;$selector + $modifier-sel + $modifier&#125; &#123; @content; &#125; &#125;&#125; 全局扩充sass import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27; // https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], css: &#123; preprocessorOptions: &#123; scss: &#123; additionalData: &quot;@import &#x27;./src/bem.scss&#x27;;&quot; &#125; &#125; &#125;&#125;) Vue 组件用法 &lt;template&gt; &lt;div class=&quot;xm-wraps&quot;&gt; &lt;div&gt; &lt;Menu&gt;&lt;/Menu&gt; &lt;/div&gt; &lt;div class=&quot;xm-wraps__right&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;Content&gt;&lt;/Content&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, reactive &#125; from &quot;vue&quot;import Menu from &#x27;./Menu/index.vue&#x27;import Content from &#x27;./Content/index.vue&#x27;import Header from &#x27;./Header/index.vue&#x27;&lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt;@include b(&#x27;wraps&#x27;)&#123; @include bfc; @include flex; @include e(right)&#123; flex:1; display: flex; flex-direction: column; &#125;&#125;&lt;/style&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"计算属性","slug":"编程语言/Vue/Vue3/Vue3学习/05.计算属性","date":"2023-07-16T11:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/05.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/05.html","excerpt":"","text":"计算属性 computed 购物车案例 &lt;template&gt; &lt;a-input v-model:value=&quot;searchContent&quot; type=&quot;text&quot; style=&quot;width: 500px&quot; placeholder=&quot;请输入关键词搜索&quot;/&gt; &lt;table&gt; &lt;tr&gt; &lt;th v-for=&quot;title in dataList.title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;(item,index) in searchDataList&quot;&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.key &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.money &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;a-button type=&quot;default&quot; @click=&quot;item.num&gt;1?item.num--:item.num&quot;&gt;-&lt;/a-button&gt; &#123;&#123; item.num &#125;&#125; &lt;a-button type=&quot;default&quot; @click=&quot;item.num&lt;99?item.num++:item.num&quot;&gt;+&lt;/a-button&gt; &lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.money * item.num &#125;&#125;￥&lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;a-button danger type=&quot;default&quot; @click=&quot;deleteItem(index)&quot;&gt;删除&lt;/a-button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot; align=&quot;right&quot;&gt;总价:&#123;&#123; total &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref, computed&#125; from &#x27;vue&#x27;;interface Data &#123; key: string, name: string, money: number, num: number,&#125;const searchContent = ref&lt;string&gt;(&#x27;&#x27;);const dataList = reactive(&#123; title: [ &#x27;编号&#x27;, &#x27;商品&#x27;, &#x27;单价&#x27;, &#x27;数量&#x27;, &#x27;金额&#x27;, &#x27;操作&#x27; ], arr: [ &#123; key: &#x27;1&#x27;, name: &#x27;昂贵的辣条&#x27;, money: 100, num: 1, &#125;, &#123; key: &#x27;2&#x27;, name: &#x27;便宜的面包&#x27;, money: 50, num: 1, &#125;, &#123; key: &#x27;3&#x27;, name: &#x27;稀有的牛奶&#x27;, money: 200, num: 1, &#125;, ]&#125;);let data = dataList.arr;let total = computed(() =&gt; &#123; return data.reduce((pre: number, now: Data) =&gt; &#123; return pre + now.num * now.money &#125;, 0)&#125;);let deleteItem = (index: number) =&gt; &#123; data.splice(index, 1)&#125;const searchDataList = computed(() =&gt; &#123; return data.filter((item: Data) =&gt; &#123; return item.name.includes(searchContent.value); &#125;);&#125;);&lt;/script&gt;&lt;style scoped&gt;th &#123; width: 100px;&#125;&lt;/style&gt; reduce函数接受两个值，一个是之前的值，一个是改变后的值 第一次没有之前的值，所以赋值为0小满zs-&gt;购物车案例 &lt;template&gt; &lt;div&gt; &lt;input placeholder=&quot;请输入名称&quot; v-model=&quot;keyWord&quot; type=&quot;text&quot;&gt; &lt;table style=&quot;margin-top:10px;&quot; width=&quot;500&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;物品&lt;/th&gt; &lt;th&gt;单价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;总价&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item, index) in searchData&quot;&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.price &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;button @click=&quot;item.num &gt; 1 ? item.num-- : null&quot;&gt;-&lt;/button&gt; &lt;input v-model=&quot;item.num&quot; type=&quot;number&quot;&gt; &lt;button @click=&quot;item.num &lt; 99 ? item.num++ : null&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; item.price * item.num &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;button @click=&quot;del(index)&quot;&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot; align=&quot;right&quot;&gt; &lt;span&gt;总价：&#123;&#123; total &#125;&#125;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; reactive, ref,computed &#125; from &#x27;vue&#x27;let keyWord = ref&lt;string&gt;(&#x27;&#x27;)interface Data &#123; name: string, price: number, num: number&#125;const data = reactive&lt;Data[]&gt;([ &#123; name: &quot;小满的绿帽子&quot;, price: 100, num: 1, &#125;, &#123; name: &quot;小满的红衣服&quot;, price: 200, num: 1, &#125;, &#123; name: &quot;小满的黑袜子&quot;, price: 300, num: 1, &#125;]) let searchData = computed(()=&gt;&#123; return data.filter(item =&gt; item.name.includes(keyWord.value))&#125;) let total = computed(() =&gt; &#123; return data.reduce((prev: number, next: Data) =&gt; &#123; return prev + next.num * next.price &#125;, 0)&#125;) const del = (index: number) =&gt; &#123; data.splice(index, 1)&#125; &lt;/script&gt; &lt;style scoped lang=&#x27;less&#x27;&gt;&lt;/style&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"Ref全家桶","slug":"编程语言/Vue/Vue3/Vue3学习/01.Ref全家桶","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:12:25.031Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/01.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/01.html","excerpt":"","text":"01.Ref全家桶Ref&lt;template&gt; &lt;p&gt;message1:&#123;&#123; message1 &#125;&#125;&lt;/p&gt; &lt;a-button @click=&quot;refTest&quot;&gt;Ref测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let message1 = ref&lt;string&gt;(&quot;信息&quot;) /** * 测试ref * 接受一个内部值并返回一个响应式且可变的 ref 对象 */ let refTest = () =&gt; &#123; message1.value += &quot;=&quot; notification[&#x27;success&#x27;](&#123; message: &#x27;测试ref&#x27;, description: &#x27;测试成功&#x27;, &#125;); &#125; return &#123; message1, refTest, &#125; &#125;&#125;)&lt;/script&gt; isRef&lt;template&gt; &lt;p&gt;message1:&#123;&#123; message1 &#125;&#125;&lt;/p&gt; &lt;p&gt;message2:&#123;&#123; message2 &#125;&#125;&lt;/p&gt; &lt;a-button @click=&quot;isRefTest&quot;&gt;isRef测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let message1 = ref&lt;string&gt;(&quot;信息&quot;) let message2 = &quot;信息&quot; /** * 测试isRef * 判断是不是一个ref对象 */ let isRefTest = () =&gt; &#123; notification[&#x27;success&#x27;](&#123; message: &#x27;测试isRef&#x27;, description: &#x27;message1&#x27; + (isRef(message1) ? &#x27;是&#x27; : &#x27;不是&#x27;) + &#x27;ref//&#x27; + &#x27;message2&#x27; + (isRef(message2) ? &#x27;是&#x27; : &#x27;不是&#x27;) + &#x27;ref&#x27;, &#125;); &#125; return &#123; message1, message2, isRefTest &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; shallowRef&lt;template&gt; &lt;p&gt;message3:&#123;&#123; message3 &#125;&#125;&lt;/p&gt; &lt;a-button @click=&quot;shallowRefTest(true)&quot;&gt;shallowRef测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let message3 = shallowRef(&#123; name: &#x27;马小跳&#x27; &#125;) /** * 测试shallowRef */ let shallowRefTest = (flag: boolean) =&gt; &#123; // 有以下两种方法 // 只有直接直接针对value来进行修改才会触发响应式 if (!flag) &#123; // 不会变成响应式的情况 message3.value.name = &#x27;aaa&#x27;; notification[&#x27;error&#x27;](&#123; message: &#x27;测试shallowRef&#x27;, description: &#x27;没有响应式变化&#x27; &#125;); &#125; else &#123; // 会变成响应式的情况 message3.value = &#123;name: &#x27;aaa&#x27;&#125;; notification[&#x27;success&#x27;](&#123; message: &#x27;测试shallowRef&#x27;, description: &#x27;发生响应式变化&#x27; &#125;); &#125; &#125; return &#123; message3, shallowRefTest &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; triggerRef&lt;template&gt; &lt;p&gt;message3:&#123;&#123; message3 &#125;&#125;&lt;/p&gt; &lt;a-button @click=&quot;triggerRefTest&quot;&gt;triggerRef测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let message3 = shallowRef(&#123; name: &#x27;马小跳&#x27; &#125;) /** * 强制更新页面DOM */ let triggerRefTest = () =&gt; &#123; message3.value.name = &#x27;bbb&#x27;; triggerRef(message3); notification[&#x27;success&#x27;](&#123; message: &#x27;测试triggerRef&#x27;, description: &#x27;已经强制更新页面DOM&#x27; &#125;); &#125; return &#123; message3, triggerRefTest &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; customRef&lt;template&gt; &lt;p&gt;message4:&#123;&#123; message4 &#125;&#125;&lt;/p&gt; &lt;a-button @click=&quot;customRefTest&quot;&gt;customRef测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let message4=myCustomRef(&#x27;哈哈哈&#x27;); /** * 自定义ref * customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set * 适合去做防抖之类的 */ function myCustomRef(value) &#123; let timer: any; return customRef((track, trigger) =&gt; &#123; return &#123; get() &#123; track(); return value; &#125;, set(newVal) &#123; // 制作防抖 clearTimeout(timer) timer = setTimeout(() =&gt; &#123; console.log(&#x27;触发了set&#x27;) value = newVal timer = null; notification[&#x27;success&#x27;](&#123; message: &#x27;测试customRef&#x27;, description: &#x27;已经调用customRefTest方法&#x27; &#125;); trigger(); &#125;, 500) &#125; &#125; &#125;) &#125; let customRefTest=()=&gt;&#123; message4.value+=&#x27;==&#x27; &#125; return &#123; message4, customRefTest &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 标签中的ref属性&lt;template&gt; &lt;div ref=&quot;dom&quot;&gt;aaa&lt;/div&gt; &lt;a-button @click=&quot;buttonTest&quot;&gt;ref属性测试&lt;/a-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;customRef, defineComponent, isRef, onMounted, reactive, ref, shallowRef, triggerRef&#125; from &#x27;vue&#x27;;import &#123;notification&#125; from &quot;ant-design-vue&quot;;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; const dom=ref&lt;HTMLDivElement&gt;() /** * 获取到元素节点 * 要求:ref的值相同 * 如:ref=&quot;dom&quot;、const dom=ref&lt;&gt;(); */ let buttonTest=()=&gt;&#123; console.log(&quot;dom:&quot;,dom.value); &#125; return &#123; // 需要return出来才能获取到节点 dom, buttonTest &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"to全家桶","slug":"编程语言/Vue/Vue3/Vue3学习/03.to全家桶","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/03.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/03.html","excerpt":"","text":"03.to全家桶toRef 修改响应式对象的值 对于非响应式数据，只会改变数据，视图依然不会发生变化 toRef(A,B) A&#x3D;&gt;对象 B&#x3D;&gt;key值 &lt;template&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive,toRef, toRefs, toRaw&#125; from &#x27;vue&#x27;;let user=reactive(&#123; name:&#x27;马小跳&#x27;, gender:&#x27;男&#x27;, like:&#x27;篮球&#x27;&#125;)let refName=toRef(user,&#x27;name&#x27;);let test1=()=&gt;&#123; console.log(refName); console.log(refName.value); // 对值进行修改 refName.value=&#x27;洛洛&#x27;;&#125;&lt;/script&gt; 应用场景有某函数需要接受指定参数，可使用toRef解构出对象的属性给指定函数 &lt;template&gt; &#123;&#123;user.name&#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive,toRef, toRefs, toRaw&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let user=reactive(&#123; name:&#x27;马小跳&#x27;, gender:&#x27;男&#x27;, like:&#x27;篮球&#x27;&#125;)let test1=()=&gt;&#123; let refName=toRef(user,&#x27;name&#x27;); sendMessage(refName.value);&#125;let sendMessage=(name:string)=&gt;&#123; message.success(&#x27;你好,&#x27;+name);&#125;&lt;/script&gt; toRefs&lt;template&gt; &#123;&#123;user.name&#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive,toRef, toRaw&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let user=reactive(&#123; name:&#x27;马小跳&#x27;, gender:&#x27;男&#x27;, like:&#x27;篮球&#x27;&#125;)// 类似实现原理const toRefs=&lt;T extends object&gt;(object:T)=&gt;&#123; const map:any=&#123;&#125;; for (let key in object) &#123; map[key]=toRef(object,key) &#125; return map;&#125;let test1=()=&gt;&#123; let &#123;name,gender&#125;=toRefs(user); console.log(name.value); console.log(gender.value);&#125;&lt;/script&gt; 否则失去响应式 &lt;template&gt; &#123;&#123; user.name &#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, toRef, toRefs, toRaw&#125; from &#x27;vue&#x27;;let user = reactive(&#123; name: &#x27;马小跳&#x27;, gender: &#x27;男&#x27;, like: &#x27;篮球&#x27;&#125;)let test1 = () =&gt; &#123; // let &#123;name,gender&#125;=toRefs(user); // 会失去响应式 let &#123;name, gender&#125; = user; console.log(name); console.log(gender);&#125;&lt;/script&gt; toRaw 获取代理前的对象 &lt;template&gt; &#123;&#123; user.name &#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, toRef, toRefs, toRaw&#125; from &#x27;vue&#x27;;let user = reactive(&#123; name: &#x27;马小跳&#x27;, gender: &#x27;男&#x27;, like: &#x27;篮球&#x27;&#125;)let test1 = () =&gt; &#123; console.log(user); console.log(toRaw(user));&#125;&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"Reactive全家桶","slug":"编程语言/Vue/Vue3/Vue3学习/02.Reactive全家桶","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/02.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/02.html","excerpt":"","text":"02.Reactive全家桶reactive reactive(‘’)不支持string类型 查看源码可知，只支持引用类型，object、map、set 而ref都支持reactive在赋值时无需使用.value 而ref需要 &lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.gender&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;import &#123;Button&#125; from &quot;ant-design-vue&quot;;let user=reactive(&#123; name:&#x27;马小跳&#x27;, gender:&#x27;男&#x27;&#125;);let test1=()=&gt;&#123; user.name=&#x27;洛洛&#x27;; console.log(user);&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 阻止默认事件 @click.prevent &lt;form&gt; &lt;button @click.prevent=&quot;test1&quot;&gt;test2&lt;/button&gt;&lt;/form&gt; reactive是经过proxy代理的对象，直接赋值会失去响应式 &lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;let users=reactive&lt;string[]&gt;([]);let test1=()=&gt;&#123; // 假设res为获取到的数据 let res=[&#x27;小满&#x27;,&#x27;辣辣&#x27;,&#x27;路西&#x27;]; // 失去响应式 users=res; console.log(users);&#125;&lt;/script&gt; 正确方法如下方法1 &lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;let users=reactive&lt;string[]&gt;([]);let test1=()=&gt;&#123; // 假设res为获取到的数据 let res=[&#x27;小满&#x27;,&#x27;辣辣&#x27;,&#x27;路西&#x27;]; // 正确方法1 // 结构后赋值 users.push(...res); console.log(users);&#125;&lt;/script&gt; 方法2 &lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;user in users.arr&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;let users=reactive&lt;&#123;arr:string[]&#125;&gt;(&#123;arr:[]&#125;);let test1=()=&gt;&#123; // 假设res为获取到的数据 let res=[&#x27;小满&#x27;,&#x27;辣辣&#x27;,&#x27;路西&#x27;]; // 正确方法2 users.arr=res; console.log(users);&#125;&lt;/script&gt; readonly 无法修改readonly修饰的值，报错Attempt to assign to const or readonly variable 但是会受reactive影响 &lt;template&gt; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, readonly, ref&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let user=reactive(&#123;name:&#x27;小荷&#x27;&#125;);const readUser=readonly(user);let test1=()=&gt;&#123; user.name=&#x27;小满&#x27;; message.success(readUser.name)&#125;&lt;/script&gt; shallowReactive 与shallowRef类似 只能对浅层的数据 如果是深层的数据只会改变值 不会改变视图 &lt;template&gt; &#123;&#123; user.name.firstName &#125;&#125;&#123;&#123; user.name.lastName &#125;&#125;--&#123;&#123;user.gender&#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, readonly, ref, shallowReactive&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let user = shallowReactive(&#123; name: &#123; firstName: &#x27;赵&#x27;, lastName: &#x27;子龙&#x27; &#125;, gender: &#x27;男&#x27;&#125;);let test1 = () =&gt; &#123; user.name.firstName = &#x27;貂&#x27; user.name.lastName = &#x27;蝉&#x27; user.gender = &#x27;女&#x27;&#125;&lt;/script&gt; 不是说好不改变视图的吗？ 和shallowRef一样，shallowReactive也会受reactive影响 当gender属性改变时，触发了强制更新 所以如下代码即可 &lt;template&gt; &#123;&#123; user.name.firstName &#125;&#125;&#123;&#123; user.name.lastName &#125;&#125;--&#123;&#123;user.gender&#125;&#125; &lt;a-button danger @click=&quot;test1&quot;&gt;test1&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, readonly, ref, shallowReactive&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let user = shallowReactive(&#123; name: &#123; firstName: &#x27;赵&#x27;, lastName: &#x27;子龙&#x27; &#125;, gender: &#x27;男&#x27;&#125;);let test1 = () =&gt; &#123; user.name.firstName = &#x27;貂&#x27; user.name.lastName = &#x27;蝉&#x27; // user.gender = &#x27;女&#x27;&#125;&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"","slug":"编程语言/Vue/Vue3/Vue3学习/04.响应式原理","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:12:25.035Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/04.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/04.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"监听器","slug":"编程语言/Vue/Vue3/Vue3学习/06.监听器","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:12:25.038Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/06.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/06.html","excerpt":"","text":"监听器 watch第一个参数监听源 watch第二个参数回调函数cb（newVal,oldVal） watch第三个参数一个options配置项是一个对象(immediate是否立即调用一次、deep:true 是否开启深度监听) 原博客 &lt;template&gt; &lt;a-button danger @click=&quot;change&quot;&gt;测试&lt;/a-button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref, computed, watch&#125; from &#x27;vue&#x27;;import &#123;message&#125; from &quot;ant-design-vue&quot;;let keywords = ref&lt;number&gt;(0)watch(keywords, (newVal, oldVal) =&gt; &#123; message.success(&#x27;新的值:&#x27; + newVal+&#x27; 旧的值:&#x27;+oldVal);&#125;, &#123; deep: true&#125;)let change = () =&gt; &#123; keywords.value += 1;&#125;&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"父子组件传参","slug":"编程语言/Vue/Vue3/Vue3学习/09.父子组件传参","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:12:25.041Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/09.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/09.html","excerpt":"","text":"父子组件传参父传子 父组件通过v-bind绑定一个数据，然后子组件通过defineProps接受传过来的值父组件 &lt;template&gt; &lt;children title=&quot;标题1&quot;/&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import Children from &#x27;@/view/Children.vue&#x27;&lt;/script&gt; 子组件 &lt;template&gt;这里是children，父组件传递的title为&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;defineProps(&#123; title:&#123; type:String, default:&#x27;默认标题&#x27; &#125;&#125;)&lt;/script&gt; 如果使用typescript，则可以采用如下写法 &lt;template&gt;这里是children，父组件传递的title为&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;const props=defineProps&lt;&#123; title:string&#125;&gt;()console.log(&#x27;父组件传递的title为:&#x27;,props.title);&lt;/script&gt; 若需要设置默认值 &lt;template&gt;这里是children，父组件传递的title为&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;type Props=&#123; title:string arr:number[]&#125;withDefaults(defineProps&lt;Props&gt;(),&#123; title:&#x27;默认标题&#x27;, arr:()=&gt;[1,2,3,4,5,6]&#125;)&lt;/script&gt; 子传父子组件 &lt;template&gt; &lt;button @click=&quot;send&quot;&gt;sendToFather&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;const emit=defineEmits([&#x27;on-click&#x27;])const send=()=&gt;&#123; emit(&#x27;on-click&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)&#125;&lt;/script&gt; 父组件 &lt;template&gt; &lt;children @on-click=&quot;getProps&quot;/&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import Children from &#x27;@/view/Children.vue&#x27;let getProps=(...name:string[])=&gt;&#123; console.log(name);&#125;&lt;/script&gt; ts写法 &lt;template&gt; &lt;button @click=&quot;send&quot;&gt;sendToFather&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;interface Props &#123; (e: &#x27;on-click&#x27;, ...name: string[]): void&#125;const emit = defineEmits&lt;Props&gt;()const send = () =&gt; &#123; emit(&#x27;on-click&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)&#125;&lt;/script&gt; 给父组件传递方法子组件 &lt;template&gt; 这是子组件&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;reactive, ref&#125; from &#x27;vue&#x27;;let time=ref&lt;string&gt;(&#x27;2023/7/17 22:00&#x27;)const open=()=&gt;&#123; console.log(&#x27;这是open方法,当前时间为:&#x27;,time.value)&#125;defineExpose(&#123; name:&#x27;马小跳&#x27;, open&#125;)&lt;/script&gt; 父组件 &lt;template&gt; &lt;children ref=&quot;childProps&quot;/&gt; &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import Children from &#x27;@/view/Children.vue&#x27;import &#123;ref&#125; from &quot;vue&quot;;const childProps=ref(null);let test=()=&gt;&#123; console.log(&#x27;name:&#x27;,childProps.value.name); childProps.value.open()&#125;&lt;/script&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"依赖注入Provide、Inject","slug":"编程语言/Vue/Vue3/Vue3学习/18.依赖注入Provide、Inject","date":"2023-07-13T15:00:00.000Z","updated":"2024-06-01T14:12:25.053Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/18.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi/18.html","excerpt":"","text":"依赖注入Provide、Inject Home.vue &lt;template&gt; &lt;div v-for=&quot;item in colorList&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;color&quot; v-model=&quot;colorVal&quot; :value=&quot;item.value&quot;&gt;&#123;&#123;item.showName&#125;&#125; &lt;/div&gt; &lt;A/&gt; &lt;B/&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt;import &#123;provide, reactive, ref&#125; from &#x27;vue&#x27;import A from &#x27;./A.vue&#x27;import B from &#x27;./B.vue&#x27;type Color=&#123; value:string, showName:string&#125;let colorList=reactive&lt;Array&lt;Color&gt;&gt;([&#123; value:&#x27;yellow&#x27;, showName:&#x27;黄色&#x27;&#125;,&#123; value:&#x27;red&#x27;, showName:&#x27;红色&#x27;&#125;,&#123; value:&#x27;purple&#x27;, showName:&#x27;紫色&#x27;&#125;])let colorVal=ref&lt;string&gt;(&#x27;&#x27;)provide(&#x27;color&#x27;,colorVal);&lt;/script&gt; A.vue 在css中也可以使用v-bind来绑定参数 &lt;template&gt; &lt;div&gt;这是A组件&lt;/div&gt; &lt;div id=&quot;attA&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;inject, reactive, ref&#125; from &#x27;vue&#x27;;import type &#123;Ref&#125; from &quot;vue&quot;;let color=inject&lt;Ref&lt;string&gt;&gt;(&#x27;color&#x27;);&lt;/script&gt;&lt;style scoped&gt;#attA&#123; width: 30px; height: 30px; background: v-bind(color);&#125;&lt;/style&gt; B.vue &lt;template&gt; &lt;div&gt;这是B组件&lt;/div&gt; &lt;div id=&quot;attB&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;inject, reactive, ref&#125; from &#x27;vue&#x27;;import type &#123;Ref&#125; from &quot;vue&quot;;let color=inject&lt;Ref&lt;string&gt;&gt;(&#x27;color&#x27;);&lt;/script&gt;&lt;style scoped&gt;#attB&#123; width: 30px; height: 30px; background: v-bind(color);&#125;&lt;/style&gt; 注意，此时的参数可以在子组件中修改 此时会导致父组件以及其他子组件的该参数都会发生改变 &lt;template&gt; &lt;div&gt;这是A组件&lt;/div&gt; &lt;button @click=&quot;changeColor&quot;&gt;修改颜色&lt;/button&gt; &lt;div id=&quot;attA&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;inject, reactive, ref&#125; from &#x27;vue&#x27;;import type &#123;Ref&#125; from &quot;vue&quot;;let color=inject&lt;Ref&lt;string&gt;&gt;(&#x27;color&#x27;);let changeColor=()=&gt;&#123; color.value=&#x27;black&#x27;&#125;&lt;/script&gt;&lt;style scoped&gt;#attA&#123; width: 30px; height: 30px; background: v-bind(color);&#125;&lt;/style&gt; 若不希望子组件进行修改，可设置为readonly let colorVal=ref&lt;string&gt;(&#x27;&#x27;)provide(&#x27;color&#x27;,readonly(colorVal)); 子组件无法使用xxx.?value来进行修改，可采用以下两种方法1.默认值 let color=inject&lt;Ref&lt;string&gt;&gt;(&#x27;color&#x27;,ref(&#x27;red&#x27;)); 2.非空断言 color!.value=&#x27;xxx&#x27;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"activiti踩坑","slug":"报错记录/Activiti/Activiti踩坑","date":"2023-07-10T15:00:00.000Z","updated":"2024-06-01T14:47:56.171Z","comments":true,"path":"/bao-cuo-ji-lu/activiti/activiti-cai-keng.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/activiti/activiti-cai-keng.html","excerpt":"","text":"遭遇问题404http://localhost:8080/activiti-app访问报404在activiti官网上下的文件，官网链接，网盘链接看了一下tomcat，是因为activiti-app.war没有被解压怀疑是war包有问题，又去github下载了（实际可能不是），链接后来没办法，试过直接用zip解压，但是启动tomcat时候报错了，即便删掉重新启动还是会报错最后清了一下tomcat缓存就成功了以下是清理Tomcat的步骤： 1. 停止Tomcat服务器：在命令行中输入“shutdown.bat”（Windows）或“shutdown.sh”（Linux）。2. 删除Tomcat工作目录：在Tomcat安装目录下找到“work”文件夹并删除。3. 删除Tomcat日志文件：在Tomcat安装目录下找到“logs”文件夹并删除其中的日志文件。4. 删除Tomcat临时文件：在Tomcat安装目录下找到“temp”文件夹并删除其中的临时文件。5. 清理Tomcat缓存：在Tomcat安装目录下找到“catalina”文件夹并删除其中的缓存文件。6. 清理Tomcat应用程序：在Tomcat安装目录下找到“webapps”文件夹并删除其中的应用程序。7. 清理Tomcat配置文件：在Tomcat安装目录下找到“conf”文件夹并删除其中的配置文件。8. 清理Tomcat插件：在Tomcat安装目录下找到“lib”文件夹并删除其中的插件。9. 重新启动Tomcat服务器：在命令行中输入“startup.bat”（Windows）或“startup.sh”（Linux）。注意：在清理Tomcat之前，请备份重要的文件和配置。 配置MySQL 查看博客 启动依然还有报错，需要将mysql连接包复制到lib文件夹下 不确定对mysql连接包的版本有没有要求，我刚开始用的是8.0.30版本，依然存在报错，改为8.0.17后即可，记得删除原本5.xx版本的jar包再次启动，报错如下 ### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Table &#x27;activit.ACT_GE_PROPERTY&#x27; doesn&#x27;t exist### The error may exist in org/activiti/db/mapping/entity/Property.xml### The error may involve org.activiti.engine.impl.persistence.entity.PropertyEntityImpl.selectProperty-Inline### The error occurred while setting parameters### SQL: select * from ACT_GE_PROPERTY where NAME_ = ?### Cause: java.sql.SQLSyntaxErrorException: Table &#x27;activit.ACT_GE_PROPERTY&#x27; doesn&#x27;t exist 修改配置文件 添加nullCatalogMeansCurrent=true即可datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;activiti6ui?nullCatalogMeansCurrent=true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC&amp;allowPublicKeyRetrieval&#x3D;true junit报错 导入activiti依赖后，junit报错 java.lang.IllegalStateException: Failed to load ApplicationContext 更换junit依赖即可 package com.example.demo;import org.junit.Test;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class ActivitiDemoApplicationTests &#123; @Test public void contextLoads() &#123; System.out.println(&quot;aaa&quot;); &#125;&#125; 注意 activiti和mybatis版本问题，可能会导致版本冲突 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;activiti-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;activiti-demo&lt;/name&gt; &lt;description&gt;activiti-demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.12.RELEASE&lt;/spring-boot.version&gt; &lt;mybatis-plus.version&gt;3.5.2&lt;/mybatis-plus.version&gt; &lt;activiti.version&gt;7.0.0.GA&lt;/activiti.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activiti --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.demo.ActivitiDemoApplication&lt;/mainClass&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 获取ProcessEngine对象报错 jdk从8更换为11即可 流程部署后查询不到 那是因为没有部署成功这两个xml文件，图标都不一样，是文件的命名有问题将文件名改为xxx.bpmn20即可","categories":[{"name":"activiti","slug":"activiti","permalink":"https://isunderachiever.github.io/categories/activiti/"}],"tags":[{"name":"activiti","slug":"activiti","permalink":"https://isunderachiever.github.io/tags/activiti/"}]},{"title":"搭建Gitee图床","slug":"系统配置/编程配置/环境配置/图床/搭建Gitee图床","date":"2023-07-09T15:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tu-chuang/da-jian-gitee-tu-chuang.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tu-chuang/da-jian-gitee-tu-chuang.html","excerpt":"","text":"搭建Gitee图床我个人常用的markdown应用有typora、vscode和息流三款 typora收费，网络上有不少破解教程 vscode可以安装插件来写markdown文档，需要知道markdown的语法格式 息流使用起来相对更加简单，有免费空间限制，如果只是编写文档也足够了在使用typora编写文档时，图片存储是个问题，虽然可以调整为相对路径存储，但是还需要保存好对应的本地图片，不然不知道图片被删掉了的话…相对路径存储这个时候可以搭建一个图床，需要先下载名为【PicGo】的工具github下载地址 https://github.com/Molunerfinn/PicGo123网盘下载地址 https://www.123pan.com/s/tMU0Vv-31zUd.html安装好PicGo默认即可，之后需要创建一个Gitee仓库新建仓库创建私有仓库个人主页个人设置私人令牌生成新令牌提交信息复制令牌这里很重要了，最好是保存一下生成的这串令牌，后续无法再查看到了接下来开始配置PicGo安装插件安装一下【gitee】插件配置Gitee信息上方的repo填写如下图片的地址仓库地址token则填写生成的【私人令牌】接下来别忘了开源仓库进入私有仓库找到仓库后进入管理设置仓库添加readme文件再次进入管理开源Gitee仓库最后配置一下Typora的文件上传配置Typora为了避免上传的图片重名，可以打开PicGo的【时间戳重命名】配置配置时间戳typora上传图片结果最后提一嘴，我使用过阿里云OSS和Github的图床，阿里云OSS倒是没什么问题，可能会有少许收费，Github懂得都懂，连接不太好毕竟是在国外，可能会造成图片传不上去，或者传上去了显示不出来","categories":[{"name":"图床","slug":"图床","permalink":"https://isunderachiever.github.io/categories/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://isunderachiever.github.io/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"idea快捷键","slug":"系统配置/编程配置/环境配置/Idea配置/idea快捷键","date":"2023-06-11T04:00:00.000Z","updated":"2024-06-01T14:12:24.892Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-kuai-jie-jian.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-kuai-jie-jian.html","excerpt":"","text":"idea快捷键同时编辑多处 按住alt+shift，点击多处即可 方法提取 方法提取(Extract method)alt+shift+m","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"05.Zustand","slug":"编程语言/React/05.Zustand","date":"2023-06-04T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/react/05.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/react/05.html","excerpt":"","text":"一个简单的，快速的状态管理解决方案，api设计基于函数式和hooks 1. 基础使用让我们实现一个非常简单的计数器案例完成我们的第一个store1- 创建一个counterStore import create from &#x27;zustand&#x27;const useCounterStore = create((set) =&gt; (&#123; // 数据 count: 0, // 修改数据的方法 increase: () =&gt; set(state =&gt; (&#123; count: state.count + 1 &#125;)), decrease: () =&gt; set(state =&gt; (&#123; count: state.count - 1 &#125;))&#125;))export default useCounterStore 2- 绑定到组件 import useCounterStore from &#x27;./store&#x27;const App = () =&gt; &#123; const count = useCounterStore((state) =&gt; state.count) const decrease = useCounterStore((state) =&gt; state.increase) const increase = useCounterStore((state) =&gt; state.decrease) return ( &lt;div&gt; &lt;button onClick=&#123;decrease&#125;&gt;+&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;increase&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;export default App 2. 异步支持1- 创建异步action import create from &#x27;zustand&#x27;const fetchApi = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve([&#x27;vue&#x27;, &#x27;react&#x27;]) &#125;, 2000) &#125;)&#125;const useListStore = create((set) =&gt; (&#123; // 数据 list: [], // 修改数据的方法 fetchList: async () =&gt; &#123; const res = await fetchApi() set(&#123; list: res &#125;) &#125;&#125;))export default useListStore 2- 绑定组件 import &#123; useEffect &#125; from &#x27;react&#x27;import useListStore from &#x27;./store&#x27;const App = () =&gt; &#123; const list = useListStore((state) =&gt; state.list) const fetchList = useListStore((state) =&gt; state.fetchList) useEffect(() =&gt; &#123; fetchList() &#125;, []) return ( &lt;div&gt; &#123;JSON.stringify(list)&#125; &lt;/div&gt; )&#125;export default App 3. 增加调试简单的调试我们可以安装一个 名称为 simple-zustand-devtools 的调试工具1- 安装调试包 $ yarn add simple-zustand-devtools 2- 配置调试工具 import create from &#x27;zustand&#x27;// 导入核心方法import &#123; mountStoreDevtool &#125; from &#x27;simple-zustand-devtools&#x27;const useStore = create((set) =&gt; (&#123;&#125;))// 开发环境开启调试if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; // 第一个参数为调试的store标识 mountStoreDevtool(&#x27;counterStore&#x27;, useStore)&#125;export default useStore 3- 打开 React调试工具","categories":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"}]},{"title":"04.Redux","slug":"编程语言/React/04.Redux","date":"2023-06-03T16:00:00.000Z","updated":"2024-06-01T14:12:25.020Z","comments":true,"path":"/bian-cheng-yu-yan/react/04.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/react/04.html","excerpt":"","text":"Redux介绍Redux是React中使用广泛的集中状态管理工具 类比vuex之于vue 同类的工具还有mobx等为什么要使用Redux？ 独立于组件，无视组件之间的层级关系，简化通信问题 单项数据流清晰，易于定位bug 调试工具配套良好，方便调试 Redux快速体验1. Redux数据流架构Redux的难点是理解它对于数据修改的规则, 下图动态展示了在整个数据的修改中，数据的流向为了职责清晰，Redux代码被分为三个核心的概念，我们学redux，其实就是学这三个核心概念之间的配合，三个概念分别是: state: 一个对象 存放着我们管理的数据 action: 一个对象 用来描述你想怎么改数据 reducer: 一个函数 根据action的描述更新state 2. 纯Redux实现计数器核心步骤 创建reducer函数 在内部定义好action和state的定义关系 调用Redux的createStore方法传入定义好的reducer函数生成store实例 通过store实例身上的subscribe方法监控数据是否变化 点击按钮 通过专门的dispatch函数 提交action对象 实现数据更新&lt;button id=&quot;decrement&quot;&gt;-&lt;/button&gt;&lt;span id=&quot;count&quot;&gt;0&lt;/span&gt;&lt;button id=&quot;increment&quot;&gt;+&lt;/button&gt;&lt;script src=&quot;https://unpkg.com/redux@latest/dist/redux.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 定义reducer函数 // 内部主要的工作是根据不同的action 返回不同的state function counterReducer (state = &#123; count: 0 &#125;, action) &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return &#123; count: state.count + 1 &#125; case &#x27;DECREMENT&#x27;: return &#123; count: state.count - 1 &#125; default: return state &#125; &#125; // 使用reducer函数生成store实例 const store = Redux.createStore(counterReducer) // 订阅数据变化 store.subscribe(() =&gt; &#123; console.log(store.getState()) document.getElementById(&#x27;count&#x27;).innerText = store.getState().count &#125;) // 增 const inBtn = document.getElementById(&#x27;increment&#x27;) inBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; store.dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;) &#125;) // 减 const dBtn = document.getElementById(&#x27;decrement&#x27;) dBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; store.dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;) &#125;)&lt;/script&gt; Redux与ReactRedux虽然是一个框架无关可以独立运行的插件，但是社区通常还是把它与React绑定在一起使用，以一个计数器案例体验一下Redux + React 的基础使用 1. 开发环境准备使用create-react-app创建react基础项目，并安装Redux相关工具 # 创建项目$ yarn create vite react-redux --template react# 安装redux配套工具$ yarn add @reduxjs/toolkit react-redux# 启动项目$ yarn dev 目录核心结构 src - store - modules // 模块store - index.js // 组合模块的入口文件 - App.js 2. 创建counterStore创建store的的核心步骤分为两步 使用toolkit的createSlice方法创建一个独立的子模块 使用configureStore语法组合子模块1- 创建子模块import &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;const counter = createSlice(&#123; // 模块名称独一无二 name: &#x27;counter&#x27;, // 初始数据 initialState: &#123; count: 1 &#125;, // 修改数据的同步方法 reducers: &#123; add (state) &#123; state.count++ &#125; &#125;&#125;)const &#123; add &#125; = counter.actionsconst counterReducer = counter.reducer// 导出修改数据的函数export &#123; add &#125;// 导出reducerexport default counterReducer 2- 组合子模块import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27;import counterReducer from &#x27;./counterStore&#x27;export default configureStore(&#123; reducer: &#123; // 注册子模块 counter: counterReducer &#125;&#125;) 3. 为React提供Redux store要想让所有的组件都有资格访问store中的数据，需要我们在入口文件中，渲染根组件的位置通过Provider提供store数据 import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;./App&#x27;// 导入storeimport store from &#x27;./store&#x27;// 导入store提供组件Providerimport &#123; Provider &#125; from &#x27;react-redux&#x27;ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( // 提供store数据 &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;) 4. 组件使用store中的数据组件使用store中的数据需要借助一个hook方法，叫做useSelectoruseSelector(state &#x3D;&gt; state.模块名) 方法的返回值为一个对象，对象中包含store子模块中的所有数据 import &#123; useSelector &#125; from &#x27;react-redux&#x27;function App () &#123; // 使用数据 const &#123; count &#125; = useSelector(state =&gt; state.counter) return ( &lt;div className=&quot;App&quot;&gt; &#123;count&#125; &lt;button onClick=&#123;clickHandler&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;export default App 5. 组件修改store中的数据修改store中的数据有俩个核心步骤 使用counterStore模块中导出的add方法创建action对象 通过dispatch函数以action作为参数传入完成数据更新import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;import &#123; add &#125; from &#x27;./store/counterStore&#x27;function App () &#123; // 使用数据 const &#123; count &#125; = useSelector(state =&gt; state.counter) // 修改数据 const dispatch = useDispatch() const clickHandler = () =&gt; &#123; // 1. 生成action对象 const action = add() // 2. 提交action进行数据更新 dispatch(action) &#125; return ( &lt;div className=&quot;App&quot;&gt; &#123;count&#125; &lt;button onClick=&#123;clickHandler&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;export default App 6. 组件修改数据并传参上一小节通过dispatch函数提交action修改了数据，如果在提交的时候需要传参怎么做呢1- 修改数据的方法中补充第二个参数action import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;const counterStore = createSlice(&#123; name: &#x27;counter&#x27;, // 独一无二不重复的名字语义化 // 定义初始化的数据 initialState: &#123; taskList: [&#x27;react&#x27;] &#125;, reducers: &#123; // action为一个对象 对象中有一个固定的属性叫做payload 为传递过来的参数 addTaskList (state, action) &#123; state.taskList.push(action.payload) &#125; &#125;&#125;)// 生成修改数据的方法导出const &#123; addTaskList &#125; = counterStore.actionsexport &#123; addTaskList &#125;// 生成reducer 导出 供index.js做组合模块const counterReducer = counterStore.reducerexport default counterReducer 2- dispatch的时候传入实参 &lt;button onClick=&#123;() =&gt; dispatch(addTaskList(&#x27;vue&#x27;))&#125;&gt;addList&lt;/button&gt; 7. Redux异步处理测试接口地址： http://geek.itheima.net/v1_0&#x2F;channels import &#123; createSlice &#125; from &#x27;@reduxjs/toolkit&#x27;import axios from &#x27;axios&#x27;const channelStore = createSlice(&#123; name: &#x27;channel&#x27;, initialState: &#123; channelList: [] &#125;, reducers: &#123; setChannelList (state, action) &#123; state.channelList = action.payload &#125; &#125;&#125;)// 创建异步const &#123; setChannelList &#125; = channelStore.actionsconst url = &#x27;http://geek.itheima.net/v1_0/channels&#x27;// 封装一个函数 在函数中return一个新函数 在新函数中封装异步// 得到数据之后通过dispatch函数 触发修改const fetchChannelList = () =&gt; &#123; return async (dispatch) =&gt; &#123; const res = await axios.get(url) dispatch(setChannelList(res.data.data.channels)) &#125;&#125;export &#123; fetchChannelList &#125;const channelReducer = channelStore.reducerexport default channelReducerimport &#123; useEffect &#125; from &#x27;react&#x27;import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;import &#123; fetchChannelList &#125; from &#x27;./store/channelStore&#x27;function App () &#123; // 使用数据 const &#123; channelList &#125; = useSelector(state =&gt; state.channel) useEffect(() =&gt; &#123; dispatch(fetchChannelList()) &#125;, [dispatch]) return ( &lt;div className=&quot;App&quot;&gt; &lt;ul&gt; &#123;channelList.map(task =&gt; &lt;li key=&#123;task.id&#125;&gt;&#123;task.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; )&#125;export default App Todos综合案例 1. 准备开发环境# 克隆项目到本地$ git clone https://gitee.com/react-course-series/react-redux.git# 安装所有依赖$ yarn # or $ npm i 2. 渲染列表 在组件中通过核心方法 useSelector方法使用数据 使用map方法进行列表遍历// 导入useSelector方法import &#123; useSelector &#125; from &#x27;react-redux&#x27;// 从store中获取list数据const &#123; list &#125; = useSelector(state =&gt; state.taskStore)// 渲染列表&lt;ul className=&quot;todo-list&quot;&gt; &#123;list.map((task) =&gt; ( &lt;li key=&#123;task.id&#125; className=&#123;task.done ? &#x27;completed todo&#x27; : &#x27;todo&#x27;&#125;&gt; &lt;div className=&quot;view&quot;&gt; &lt;input className=&quot;toggle&quot; type=&quot;checkbox&quot; checked=&#123;task.done&#125; onChange=&#123;(e) =&gt; singleCheck(task.id, e)&#125; /&gt; &lt;label&gt; &#123;task.title&#125; &lt;/label&gt; &lt;button className=&quot;destroy&quot; onClick=&#123;() =&gt; delTask(task.id)&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ))&#125;&lt;/ul&gt; 3. 实现删除实现步骤： 在store的reducers选项中定义修改数据的方法 然后导出 在组件中通过dispatch函数触发方法的执行并传入id参数reducers:&#123; // 删除的方法 delTask (state, action) &#123; state.list = state.list.filter(task =&gt; task.id !== action.payload) &#125;&#125;// 导出删除action函数// 导出action函数const &#123; delTask &#125; = taskStore.actionsexport &#123; delTask &#125;// 导入生成dispatch方法的hookimport &#123; useDispatch &#125; from &#x27;react-redux&#x27;// 得到dispatch方法const dispatch = useDispatch()// 通过dispatch函数调用action并传入id&lt;button className=&quot;destroy&quot; onClick=&#123;() =&gt; dispatch(delTask(task.id))&#125;&gt;&lt;/button&gt; 4. 切换单选状态实现步骤： 在reducers选项中创建切换状态的函数，内部通过传入的id找到要修改的项 进行取反 组件中通过dispatch函数触发并传入idreducers:&#123; toggleTask (state, action) &#123; const item = state.list.find(task =&gt; task.id === action.payload) item.done = !item.done &#125;&#125;// 解构导出const &#123; toggleTask &#125; = taskStore.actions// 导出action函数export &#123; toggleTask &#125;&lt;input className=&quot;toggle&quot; type=&quot;checkbox&quot; checked=&#123;task.done&#125; onChange=&#123;() =&gt; dispatch(toggleTask(task.id))&#125;/&gt; 5. 切换全选状态实现思路： 全选其实就是遍历数组中的所有项把每一项的done字段都改成true 反选其实就是遍历数组中的所有项把每一项的done字段都改成false 总之，done字段的值始终和当前全选框的状态决定实现步骤： 在store中的reducers函数中定义修改数据的action函数控制done字段的变化 导出相应的action函数 供组件使用 组件中通过 checked属性控制是否全选的UI显示，在change事件中触发actionreducers:&#123; // 全选 allCheck(state, action)&#123; state.list.forEach(item=&gt;item.done = action.payload) &#125;&#125;// 导出action函数const &#123; allCheck &#125; = taskStore.actionsexport &#123; allCheck &#125; &lt;input id=&quot;toggle-all&quot; className=&quot;toggle-all&quot; type=&quot;checkbox&quot; checked=&#123;list.every((task) =&gt; task.done)&#125; onChange=&#123;(e) =&gt; dispatch(allCheck(e.target.checked))&#125;/&gt; 6. 新增实现要求: 输入框中输入内容，用户在回车时可以实现添加功能实现思路和步骤 在redux中定义新增的方法 addTask 在组件中通过受控的方式 记录输入框中的数据 keyUp事件中判断当前是否点击的是enter[keyCode为13] 如果是通过dispatch执行修改// 新增: 按照list中item的对象结构 传入一个新的对象 push到数组中reducer:&#123; addTask (state, action) &#123; state.taskList.push(action.payload) &#125;&#125;// 1. 受控的方式存入用户输入数据 // 2.keyUp 判断点击的是enter dispatch触发修改数据的函数const [keyword, setKeyword] = useState(&#x27;&#x27;)const onChange = (e) =&gt; &#123; setKeyword(e.target.value)&#125;const onKeyUp = (e) =&gt; &#123; if (e.keyCode === 13) &#123; dispatch( addTask(&#123; id: 3, name: keyword, isDone: false, &#125;) ) setKeyword(&#x27;&#x27;) &#125;&#125;&lt;input className=&quot;new-todo&quot; autoFocus autoComplete=&quot;off&quot; placeholder=&quot;What needs to be done?&quot; value=&#123;keyword&#125; onChange=&#123;onChange&#125; onKeyUp=&#123;onKeyUp&#125;/&gt; 美团小案例1. 准备环境# 克隆项目到本地git clone http://git.itcast.cn/heimaqianduan/redux-meituan.git# 安装所有依赖npm i# 启动mock服务npm run serve# 启动前端服务npm run start","categories":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"}]},{"title":"03.Mobx","slug":"编程语言/React/03.Mobx","date":"2023-06-02T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/react/03.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/react/03.html","excerpt":"","text":"1. Mobx介绍 一个可以和React良好配合的集中状态管理工具，和Redux解决的问题相似，都可以独立组件进行集中状态管理 优势 简单 编写无模板的极简代码精准描述你的意图 轻松实现最优渲染 依赖自动追踪，实现最小渲染优化 架构自由 可移植, 可测试 无特殊心智负担 社区评价 2. 配置开发环境 Mobx是一个独立的响应式的库，可以独立于任何UI框架存在，但是通常大家习惯把它和React进行绑定使用，用Mobx来做响应式数据建模，React作为UI视图框架渲染内容，我们环境的配置需要三个部分 一个create-react-app创建好的React项目环境 mobx框架本身 一个用来链接mobx和React的中间件 # 创建项目$ yarn create vite react-mobx --template react# 安装mobx和中间件工具 mobx-react-lite 只能函数组件中使用$ yarn add mobx mobx-react-lite 3. 基础使用 需求: 使用mobx实现一个计数器的案例 1. 初始化mobx 初始化步骤 定义数据状态state 在构造器中实现数据响应式处理 makeAutoObservble 定义修改数据的函数action 实例化store并导出 import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; count = 0 // 定义数据 constructor() &#123; makeAutoObservable(this) // 响应式处理 &#125; // 定义修改数据的方法 addCount = () =&gt; &#123; this.count++ &#125;&#125;const counter = new CounterStore()export default counter 2. React使用store 实现步骤 在组件中导入counterStore实例对象 在组件中使用storeStore实例对象中的数据 通过事件调用修改数据的方法修改store中的数据 让组件响应数据变化 // 导入counterStoreimport counterStore from &#x27;./store&#x27;// 导入observer方法import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; counterStore.addCount()&#125;&gt; &#123;counterStore.count&#125; &lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 4. 计算属性（衍生状态） 概念: 有一些状态根据现有的状态计算（衍生）得到，我们把这种状态叫做计算属性, 看下面的例子 实现步骤 生命一个存在的数据 通过get关键词 定义计算属性 在 makeAutoObservable 方法中标记计算属性 import &#123; computed, makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; list = [1, 2, 3, 4, 5, 6] constructor() &#123; makeAutoObservable(this, &#123; filterList: computed &#125;) &#125; // 修改原数组 changeList = () =&gt; &#123; this.list.push(7, 8, 9) &#125; // 定义计算属性 get filterList () &#123; return this.list.filter(item =&gt; item &gt; 4) &#125;&#125;const counter = new CounterStore()export default counter// 导入counterStoreimport counterStore from &#x27;./store&#x27;// 导入observer方法import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 原数组 */&#125; &#123;JSON.stringify(counterStore.list)&#125; &#123;/* 计算属性 */&#125; &#123;JSON.stringify(counterStore.filterList)&#125; &lt;button onClick=&#123;() =&gt; counterStore.changeList()&#125;&gt;change list&lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 5. 异步数据处理 测试接口: http://geek.itheima.net/v1_0&#x2F;channels 实现步骤: 在mobx中编写异步请求方法 获取数据 存入state中 组件中通过 useEffect + 空依赖 触发action函数的执行 // 异步的获取import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;import axios from &#x27;axios&#x27;class ChannelStore &#123; channelList = [] constructor() &#123; makeAutoObservable(this) &#125; // 只要调用这个方法 就可以从后端拿到数据并且存入channelList setChannelList = async () =&gt; &#123; const res = await axios.get(&#x27;http://geek.itheima.net/v1_0/channels&#x27;) this.channelList = res.data.data.channels &#125;&#125;const channlStore = new ChannelStore()export default channlStoreimport &#123; useEffect &#125; from &#x27;react&#x27;import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; const &#123; channlStore &#125; = useStore() // 1. 使用数据渲染组件 // 2. 触发action函数发送异步请求 useEffect(() =&gt; &#123; channlStore.setChannelList() &#125;, []) return ( &lt;ul&gt; &#123;channlStore.channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;// 让组件可以响应数据的变化[也就是数据一变组件重新渲染]export default observer(App) 6. 模块化 场景: 一个项目有很多的业务模块，我们不能把所有的代码都写到一起，这样不好维护，提了提供可维护性，需要引入模块化机制 实现步骤 拆分模块js文件，每个模块中定义自己独立的state&#x2F;action 在store&#x2F;index.js中导入拆分之后的模块，进行模块组合 利用React的context的机制导出统一的useStore方法，给业务组件使用 1- 定义task模块 import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class TaskStore &#123; taskList = [] constructor() &#123; makeAutoObservable(this) &#125; addTask () &#123; this.taskList.push(&#x27;vue&#x27;, &#x27;react&#x27;) &#125;&#125;const task = new TaskStore()export default task 2- 定义counterStore import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; count = 0 list = [1, 2, 3, 4, 5, 6] constructor() &#123; makeAutoObservable(this) &#125; addCount = () =&gt; &#123; this.count++ &#125; changeList = () =&gt; &#123; this.list.push(7, 8, 9) &#125; get filterList () &#123; return this.list.filter(item =&gt; item &gt; 4) &#125;&#125;const counter = new CounterStore()export default counter 3- 组合模块导出统一方法 import React from &#x27;react&#x27;import counter from &#x27;./counterStore&#x27;import task from &#x27;./taskStore&#x27;class RootStore &#123; constructor() &#123; this.counterStore = counter this.taskStore = task &#125;&#125;const rootStore = new RootStore()// context机制的数据查找链 Provider如果找不到 就找createContext方法执行时传入的参数const context = React.createContext(rootStore)const useStore = () =&gt; React.useContext(context)// useStore() =&gt; rootStore &#123; counterStore, taskStore &#125;export &#123; useStore &#125; 4- 组件使用模块中的数据 import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;// 导入方法import &#123; useStore &#125; from &#x27;./store&#x27;function App() &#123; // 得到store const store = useStore() return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; store.counterStore.addCount()&#125;&gt; &#123;store.counterStore.count&#125; &lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 7. 多组件共享数据 目标：当数据发生变化 所有用到数据的组件都会得到同步的组件的更新 实现步骤：在Foo组件和Bar组件中分别使用store中的数据，然后在app组件中进行数据修改，查看Foo组件和Bar组件是否得到更新 // 用taskStore中的taskList数据import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;const Bar = () =&gt; &#123; const &#123; taskStore &#125; = useStore() return ( &lt;ul&gt; &#123;taskStore.taskList.map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default observer(Son)// 用taskStore中的taskList数据import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;const Bar = () =&gt; &#123; const &#123; taskStore &#125; = useStore() return ( &lt;ul&gt; &#123;taskStore.taskList.map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default observer(Son)import Bar from &#x27;./Bar&#x27;import Foo from &#x27;./Foo&#x27;import &#123; useStore &#125; from &#x27;./store&#x27;function App() &#123; const &#123; taskStore &#125; = useStore() return ( &lt;div className=&quot;App&quot;&gt; &lt;Bar /&gt; &lt;button onClick=&#123;() =&gt; taskStore.setTaskList(&#x27;angular&#x27;)&#125;&gt; 修改taskStore &lt;/button&gt; &lt;/div&gt; )&#125;export default App 8. Todos综合案例 1. 开发环境搭建 # 克隆模块到本地$ git clone https://gitee.com/react-course-series/mobx_react.git# 安装所有依赖$ yarn # master分支是一个静态的模板 在这个里面进行开发# finished-mvc分支是一个写完的版本 供参考 2. Mobx和React的职责划分 3. 列表渲染 import &#x27;./index.css&#x27;import &#123; useStore &#125; from &#x27;../store&#x27;function Task () &#123; const &#123; taskStore &#125; = useStore() return ( &lt;section className=&quot;todoapp&quot;&gt; &lt;section className=&quot;main&quot;&gt; &#123;/* 省略 */&#125; &lt;ul className=&quot;todo-list&quot;&gt; &#123;/* 列表区域 */&#125; &#123;taskStore.list.map(item =&gt; ( &lt;li className=&quot;todo&quot; key=&#123;item.id&#125; &gt; &lt;div className=&quot;view&quot;&gt; &lt;input className=&quot;toggle&quot; type=&quot;checkbox&quot; /&gt; &lt;label &gt;&#123;item.name&#125;&lt;/label&gt; &lt;button className=&quot;destroy&quot;&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ))&#125; &#123;/* &lt;li className=&quot;todo completed&quot; &gt; &lt;div className=&quot;view&quot;&gt; &lt;input className=&quot;toggle&quot; type=&quot;checkbox&quot; defaultChecked=&#123;true&#125; /&gt; &lt;label &gt;learn react&lt;/label&gt; &lt;button className=&quot;destroy&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; */&#125; &lt;/ul&gt; &lt;/section&gt; &lt;footer className=&quot;footer&quot;&gt; &lt;span className=&quot;todo-count&quot;&gt; 任务总数: &#123;10&#125; 已完成: &#123;1&#125; &lt;/span&gt; &lt;/footer&gt; &lt;/section&gt; )&#125;export default observer(Task) 4. 单选实现 实现思路和步骤: 本质上是在实现双向绑定 通过store中的数据状态 isDone字段 绑定到input元素的 checked属性上 监听事件 调用mobx的对应方法 传入id 找到要修改的项 把isDone字段取反操作 import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class TaskStore &#123; list = [ &#123; id: 1, name: &#x27;学习react&#x27;, isDone: true &#125;, &#123; id: 2, name: &#x27;搞定mobx&#x27;, isDone: false &#125; ] constructor() &#123; makeAutoObservable(this) &#125; // 进行单选修改数据的方法 checkItem = (id) =&gt; &#123; const item = this.list.find(item =&gt; item.id === id) item.isDone = !item.isDone &#125;&#125;export default TaskStoreconst onChange = (id) =&gt; taskStore.checkItem(id)&lt;input className=&quot;toggle&quot; type=&quot;checkbox&quot; checked=&#123;item.isDone&#125; onChange=&#123;() =&gt; onChange(item.id)&#125;/&gt; 5. 删除功能 实现思路和步骤： 在mobx中定义好删除数据的方法\\2. 点击删除 调用mobx提供的删除方法 传出id 进行删除 // 删除的方法delItem = (id) =&gt; &#123; this.list = this.list.filter(item =&gt; item.id !== id)&#125;// 删除操作const onDel = (id) =&gt; taskStore.delItem(id)&lt;button className=&quot;destroy&quot; onClick=&#123;() =&gt; onDel(item.id)&#125;&gt;&lt;/button&gt; 6. 全选功能 实现思路和步骤: 实现数据驱动权限UI显示 通过计算属性 + every方法 实现点击权限 控制所有子项 change事件拿到e.target.checked 遍历list进行isDone赋值 // 是否全选的计算属性get isAll () &#123; return this.list.every(item =&gt; item.isDone)&#125;// 遍历修改所有itemallCheckItem = (checked) =&gt; &#123; this.list.forEach(item =&gt; &#123; item.isDone = checked &#125;)&#125;// 全选操作回调const allChange = (e) =&gt; &#123; // 通过事件对象e拿到当前是否选中的状态 taskStore.allCheckItem(e.target.checked)&#125;&#123;/* 全选框 */&#125;&lt;input id=&quot;toggle-all&quot; className=&quot;toggle-all&quot; type=&quot;checkbox&quot; checked=&#123;taskStore.isAll&#125; onChange=&#123;allChange&#125;/&gt; \\7. 新增功能 实现思路和步骤: 在mobx中编写新增方法的逻辑 在组件中通过受控方式维护输入框中的数据 在组件中监听keyUp方法 判断当前是否点击的是回车键 如果是 调用mobx的方法进行新增 addItem = (item) =&gt; &#123; this.list.push(item) &#125;// 受控方式维护输入框数据const [keyword, setKeyword] = useState(&#x27;&#x27;)const keywordChange = (e) =&gt; &#123; setKeyword(e.target.value)&#125;// 键盘抬起事件中 判断code码进行新增const onKeyUp = (e) =&gt; &#123; console.log(e) if (e.keyCode === 13) &#123; taskStore.addItem(&#123; id: 3, name: keyword, isDone: false &#125;) // 新增完毕置空 setKeyword(&#x27;&#x27;) &#125;&#125;&lt;input className=&quot;new-todo&quot; autoFocus autoComplete=&quot;off&quot; placeholder=&quot;What needs to be done?&quot; value=&#123;keyword&#125; onChange=&#123;keywordChange&#125; onKeyUp=&#123;onKeyUp&#125;/&gt;","categories":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"}]},{"title":"02.ReactRouter","slug":"编程语言/React/02.ReactRouter","date":"2023-06-02T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/react/02.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/react/02.html","excerpt":"","text":"前置知识1. 单页应用只有一个html文件 主流的开发模式变成了通过路由进行页面切换 优势: 避免整体页面刷新 用户体验变好前端负责事情变多了 开发的难度变大 2. 路由的本质概念来源于后端 : 一个路径表示匹配一个服务器资源 &#x2F;a.html -&gt; a对应的文件资源 &#x2F;b.html -&gt; b对应的文件资源共同的思想: 一对一的关系前端的路由: 一个路径path对应唯一的一个组件comonent 当我们访问一个path 自动把path对应的组件进行渲染 const routes = [ &#123; path:&#x27;/home&#x27;, component: Home &#125;, &#123; path:&#x27;/about&#x27;, component: About &#125;, &#123; path:&#x27;/article&#x27;, component: Article &#125;] 准备项目环境create-react-app -&gt; cra -&gt; webpackvite: 可以实现cra同等能力 但是速度更快的打包工具 [尤大]使用vite新增一个React项目，然后安装一个v6版本的react-router-dom # 创建react项目$ yarn create vite react-router --template react# 安装所有依赖包$ yarn# 启动项目$ yarn dev# 安装react-router包$ yarn add react-router-dom@6 基础使用需求: 准备俩个按钮，点击不同按钮切换不同组件内容的显示实现步骤： 导入必要的路由router内置组件 准备俩个React组件 按照路由的规则进行路由配置// 引入必要的内置组件import &#123; BrowserRouter, Routes, Route, Link &#125; from &#x27;react-router-dom&#x27;// 准备俩个路由组件const Home = () =&gt; &lt;div&gt;this is home&lt;/div&gt;const About = () =&gt; &lt;div&gt;this is about&lt;/div&gt;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 按照规则配置路由 */&#125; &lt;BrowserRouter&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; )&#125;export default App 核心内置组件说明1. BrowerRouter作用: 包裹整个应用，一个React应用只需要使用一次 模式 实现方式 路由url表现 HashRouter 监听url hash值实现 http://localhost:3000/#/about BrowerRouter h5的 history.pushState API实现 http://localhost:3000/about 2. Link作用: 用于指定导航链接，完成声明式的路由跳转 类似于 这里to属性用于指定路由地址，表示要跳转到哪里去，Link组件最终会被渲染为原生的a链接 3. Routes作用: 提供一个路由出口，组件内部会存在多个内置的Route组件，满足条件的路由会被渲染到组件内部类比 router-view 4. Route作用: 用于定义路由路径和渲染组件的对应关系 [element：因为react体系内 把组件叫做react element]其中path属性用来指定匹配的路径地址，element属性指定要渲染的组件，图中配置的意思为: 当url上访问的地址为 &#x2F;about 时，当前路由发生匹配，对应的About组件渲染 编程式导航声明式 【 Link to】 vs 编程式 【调用路由方法进行路由跳转】概念: 通过js编程的方式进行路由页面跳转，比如说从首页跳转到关于页实现步骤： 导入一个 useNavigate 钩子函数 执行 useNavigate 函数 得到 跳转函数 在事件中执行跳转函数完成路由跳转// 导入useNavigate函数import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;const Home = () =&gt; &#123; // 执行函数 const navigate = useNavigate() return ( &lt;div&gt; Home &lt;button onClick=&#123; ()=&gt; navigate(&#x27;/about&#x27;) &#125;&gt; 跳转关于页 &lt;/button&gt; &lt;/div&gt; )&#125;export default Home 注: 如果在跳转时不想添加历史记录，可以添加额外参数replace 为truenavigate(&#x27;/about&#x27;, &#123; replace: true &#125; ) 路由传参场景：跳转路由的同时，有时候要需要传递参数 1. searchParams传参路由传参路由取参 2. params传参路由传参路由取参 嵌套路由场景：在我们做的很多的管理后台系统中，通常我们都会设计一个Layout组件，在它内部实现嵌套路由实现步骤： App.js中定义嵌套路由声明 Layout组件内部通过 指定二级路由出口1- App.js组件中定义路由嵌套关系&lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;Layout/&gt;&#125;&gt; &lt;Route path=&quot;board&quot; element=&#123; &lt;Board/&gt; &#125; /&gt; &lt;Route path=&quot;article&quot; element=&#123; &lt;Article/&gt; &#125; /&gt; &lt;/Route&gt; &#123; /* 省略部分 */ &#125;&lt;/Routes&gt; 2- Layout.js组件中使用 Outlet 组件添加二级路由出口import &#123; Outlet &#125; from &#x27;react-router-dom&#x27;const Layout = () =&gt; &#123; return ( &lt;div&gt; layout &#123; /* 二级路由的path等于 一级path + 二级path */ &#125; &lt;Link to=&quot;/board&quot;&gt;board&lt;/Link&gt; &lt;Link to=&quot;/article&quot;&gt;article&lt;/Link&gt; &#123; /* 二级路由出口 */ &#125; &lt;Outlet/&gt; &lt;/div&gt; )&#125;export default Layout 默认二级路由场景: 应用首次渲染完毕就需要显示的二级路由实现步骤: 给默认二级路由标记index属性 把原本的路径path属性去掉&lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;Layout/&gt;&#125;&gt; &lt;Route index element=&#123; &lt;Board/&gt; &#125; /&gt; &lt;Route path=&quot;article&quot; element=&#123; &lt;Article/&gt; &#125; /&gt; &lt;/Route&gt;&lt;/Routes&gt;import &#123; Outlet &#125; from &#x27;react-router-dom&#x27;const Layout = () =&gt; &#123; return ( &lt;div&gt; layout &#123; /* 默认二级不再具有自己的路径 */ &#125; &lt;Link to=&quot;/&quot;&gt;board&lt;/Link&gt; &lt;Link to=&quot;/article&quot;&gt;article&lt;/Link&gt; &#123; /* 二级路由出口 */ &#125; &lt;Outlet/&gt; &lt;/div&gt; )&#125; 404路由配置场景：当url的路径在整个路由配置中都找不到对应的path，使用404兜底组件进行渲染1- 准备一个NotFound组件 const NotFound = () =&gt; &#123; return &lt;div&gt;this is NotFound&lt;/div&gt;&#125;export default NotFound&lt;BrowserRouter&gt; &lt;Routes&gt; &lt;Route path=&quot;/&quot; element=&#123;&lt;Layout /&gt;&#125;&gt; &lt;Route index element=&#123;&lt;Board /&gt;&#125; /&gt; &lt;Route path=&quot;article&quot; element=&#123;&lt;Article /&gt;&#125; /&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; element=&#123;&lt;NotFound /&gt;&#125;&gt;&lt;/Route&gt; &lt;/Routes&gt;&lt;/BrowserRouter&gt; 尝试访问一个不存在的路径，查看效果~ 集中式路由配置场景: 当我们需要路由权限控制点时候, 对路由数组做一些权限的筛选过滤，所谓的集中式路由配置就是用一个数组统一把所有的路由对应关系写好替换 本来的Roues组件 import &#123; BrowserRouter, Routes, Route, useRoutes &#125; from &#x27;react-router-dom&#x27;import Layout from &#x27;./pages/Layout&#x27;import Board from &#x27;./pages/Board&#x27;import Article from &#x27;./pages/Article&#x27;import NotFound from &#x27;./pages/NotFound&#x27;// 1. 准备一个路由数组 数组中定义所有的路由对应关系const routesList = [ &#123; path: &#x27;/&#x27;, element: &lt;Layout /&gt;, children: [ &#123; element: &lt;Board /&gt;, index: true, // index设置为true 变成默认的二级路由 &#125;, &#123; path: &#x27;article&#x27;, element: &lt;Article /&gt;, &#125;, ], &#125;, // 增加n个路由对应关系 &#123; path: &#x27;*&#x27;, element: &lt;NotFound /&gt;, &#125;,]// 2. 使用useRoutes方法传入routesList生成Routes组件function WrapperRoutes() &#123; let element = useRoutes(routesList) return element&#125;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;BrowserRouter&gt; &#123;/* 3. 替换之前的Routes组件 */&#125; &lt;WrapperRoutes /&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; )&#125;export default App 路由大练习需求如下: 使用vite创建一个新的项目 在项目中全局安装组件库 antDesign 文档地址: https://ant.design/ 准备一个一级路由 使用antDesign中的布局组件实现如下图Layout页面的布局方式​ Layout组件地址: https://ant.design/components/layout-cn/ ​ Menu组件地址: https://ant.design/components/menu-cn/ 用 &lt;4.2.0 的写法即可 准备三个二级路由，分别是数据概览，内容管理，发布文章，在Layout组件内部的主体部分实现点击左侧菜单切换二级路由内容显示 将数据概览路由作为默认渲染的二级路由 设置404一级路由页，在无法匹配的时候做兜底显示 [404页面UI不做要求] 在内容管理组件中增加一个按钮 点击可以跳转到 发布文章路由 并且传递一个参数 id &#x3D; 100参考链接:https://gitee.com/react-cp/react-pc-code/blob/master/src/pages/Layout/index.js","categories":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"}]},{"title":"React基础","slug":"编程语言/React/01.React基础","date":"2023-06-01T16:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bian-cheng-yu-yan/react/01.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/react/01.html","excerpt":"","text":"React介绍 原文请移步Bilibili 作者文档在视频简介内 源码地址：https://gitee.com/react-cp/react-pc-code React基础讲义: https://www.yuque.com/fechaichai/qeamqf/xbai87 React和Mobx讲义: https://www.yuque.com/fechaichai/qeamqf/apomum ReactPc项目讲义: https://www.yuque.com/fechaichai/tzzlh1目标任务: 了解什么是React以及它的特点React是什么 一个专注于构建用户界面的 JavaScript 库，和vue和angular并称前端三大框架，不夸张的说，react引领了很多新思想，世界范围内是最流行的js前端框架，最新版本已经到了18，加入了许多很棒的新特性​ React英文文档（https://reactjs.org/）​ React中文文档 （https://zh-hans.reactjs.org/）​ React新文档（https://beta.reactjs.org/）（开发中....）React有什么特点1- 声明式UI（JSX）写UI就和写普通的HTML一样，抛弃命令式的繁琐实现2- 组件化组件是react中最重要的内容，组件可以通过搭积木的方式拼成一个完整的页面，通过组件的抽象可以增加复用能力和提高可维护性3- 跨平台react既可以开发web应用也可以使用同样的语法开发原生应用（react-native），比如安卓和ios应用，甚至可以使用react开发VR应用，想象力空间十足，react更像是一个 元框架 为各种领域赋能 环境初始化目标任务: 能够独立使用React脚手架创建一个react项目 1. 使用脚手架创建项目 打开命令行窗口 执行命令 $ npx create-react-app react-basic 说明： npx create-react-app 是固定命令，create-react-app是React脚手架的名称 react-basic表示项目名称，可以自定义，保持语义化 npx 命令会帮助我们临时安装create-react-app包，然后初始化项目完成之后会自自动删掉，所以不需要全局安装create-react-app 启动项目 $ yarn startor$ npm start 2. 项目目录说明调整 目录说明 src 目录是我们写代码进行项目开发的目录 package.json 中俩个核心库：react 、react-dom 目录调整 删除src目录下自带的所有文件，只保留app.js根组件和index.js 创建index.js文件作为项目的入口文件，在这个文件中书写react代码即可 入口文件说明 import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &#x27;./index.css&#x27;// 引入根组件Appimport App from &#x27;./App&#x27;// 通过调用ReactDOM的render方法渲染App根组件到id为root的dom节点上ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;)) JSX基础1. JSX介绍目标任务: 能够理解什么是JSX，JSX的底层是什么概念：JSX是 JavaScript XML（HTML）的缩写，表示在 JS 代码中书写 HTML 结构作用：在React中创建HTML结构（页面UI结构）优势： 采用类似于HTML的语法，降低学习成本，会HTML就会JSX 充分利用JS自身的可编程能力创建HTML结构注意：JSX 并不是标准的 JS 语法，是 JS 的语法扩展，浏览器默认是不识别的，脚手架中内置的 @babel&#x2F;plugin-transform-react-jsx 包，用来解析该语法 2. JSX中使用js表达式目标任务: 能够在JSX中使用表达式语法 &#123; JS 表达式 &#125;const name = &#x27;柴柴&#x27;&lt;h1&gt;你好，我叫&#123;name&#125;&lt;/h1&gt; // &lt;h1&gt;你好,我叫柴柴&lt;/h1&gt; 可以使用的表达式 字符串、数值、布尔值、null、undefined、object（ [] &#x2F; {} ） 1 + 2、’abc’.split(‘’)、[‘a’, ‘b’].join(‘-‘) fn()特别注意if 语句&#x2F; switch-case 语句&#x2F; 变量声明语句，这些叫做语句，不是表达式，不能出现在 &#123;&#125; 中！！ 3. JSX列表渲染目标任务: 能够在JSX中实现列表渲染页面的构建离不开重复的列表结构，比如歌曲列表，商品列表等，我们知道vue中用的是v-for，react这边如何实现呢？实现：使用数组的map 方法 // 来个列表const songs = [ &#123; id: 1, name: &#x27;痴心绝对&#x27; &#125;, &#123; id: 2, name: &#x27;像我这样的人&#x27; &#125;, &#123; id: 3, name: &#x27;南山南&#x27; &#125;]function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;ul&gt; &#123; songs.map(item =&gt; &lt;li&gt;&#123;item.name&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;/div&gt; )&#125;export default App 注意点：需要为遍历项添加 key 属性 key 在 HTML 结构中是看不到的，是 React 内部用来进行性能优化时使用 key 在当前列表中要唯一的字符串或者数值（String&#x2F;Number） 如果列表中有像 id 这种的唯一值，就用 id 来作为 key 值 如果列表中没有像 id 这种的唯一值，就可以使用 index（下标）来作为 key 值 4. JSX条件渲染目标任务: 能够在JSX中实现条件渲染作用：根据是否满足条件生成HTML结构，比如Loading效果实现：可以使用 三元运算符 或 逻辑与(&amp;&amp;)运算符 // 来个布尔值const flag = truefunction App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 条件渲染字符串 */&#125; &#123;flag ? &#x27;react真有趣&#x27; : &#x27;vue真有趣&#x27;&#125; &#123;/* 条件渲染标签/组件 */&#125; &#123;flag ? &lt;span&gt;this is span&lt;/span&gt; : null&#125; &lt;/div&gt; )&#125;export default App 5. JSX样式处理目标任务: 能够在JSX中实现css样式处理 行内样式 - style function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;this is a div&lt;/div&gt; &lt;/div&gt; )&#125;export default App 行内样式 - style - 更优写法 const styleObj = &#123; color:red&#125;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div style=&#123; styleObj &#125;&gt;this is a div&lt;/div&gt; &lt;/div&gt; )&#125;export default App 类名 - className（推荐） .title &#123; font-size: 30px; color: blue;&#125; 类名 - className - 动态类名控制 import &#x27;./app.css&#x27;const showTitle = truefunction App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&#123; showTitle ? &#x27;title&#x27; : &#x27;&#x27;&#125;&gt;this is a div&lt;/div&gt; &lt;/div&gt; )&#125;export default App 6. JSX注意事项目标任务: 掌握JSX在实际应用时的注意事项 JSX必须有一个根节点，如果没有根节点，可以使用&lt;&gt;&lt;/&gt;（幽灵节点）替代 所有标签必须形成闭合，成对闭合或者自闭合都可以 JSX中的语法更加贴近JS语法，属性名采用驼峰命名法 class -&gt; className for -&gt; htmlFor JSX支持多行（换行），如果需要换行，需使用() 包裹，防止bug出现 格式化配置目标任务: 基于vscode配置格式化工具，提高开发效率 安装vsCode prettier插件 修改配置文件 setting.json &#123; &quot;git.enableSmartCommit&quot;: true, // 修改注释颜色 &quot;editor.tokenColorCustomizations&quot;: &#123; &quot;comments&quot;: &#123; &quot;fontStyle&quot;: &quot;bold&quot;, &quot;foreground&quot;: &quot;#82e0aa&quot; &#125; &#125;, // 配置文件类型识别 &quot;files.associations&quot;: &#123; &quot;*.js&quot;: &quot;javascript&quot;, &quot;*.json&quot;: &quot;jsonc&quot;, &quot;*.cjson&quot;: &quot;jsonc&quot;, &quot;*.wxss&quot;: &quot;css&quot;, &quot;*.wxs&quot;: &quot;javascript&quot; &#125;, &quot;extensions.ignoreRecommendations&quot;: false, &quot;files.exclude&quot;: &#123; &quot;**/.DS_Store&quot;: true, &quot;**/.git&quot;: true, &quot;**/.hg&quot;: true, &quot;**/.svn&quot;: true, &quot;**/CVS&quot;: true, &quot;**/node_modules&quot;: false, &quot;**/tmp&quot;: true &#125;, // &quot;javascript.implicitProjectConfig.experimentalDecorators&quot;: true, &quot;explorer.confirmDragAndDrop&quot;: false, &quot;typescript.updateImportsOnFileMove.enabled&quot;: &quot;prompt&quot;, &quot;git.confirmSync&quot;: false, &quot;editor.tabSize&quot;: 2, &quot;editor.fontWeight&quot;: &quot;500&quot;, &quot;[json]&quot;: &#123;&#125;, &quot;editor.tabCompletion&quot;: &quot;on&quot;, &quot;vsicons.projectDetection.autoReload&quot;: true, &quot;editor.fontFamily&quot;: &quot;Monaco, &#x27;Courier New&#x27;, monospace, Meslo LG M for Powerline&quot;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;vscode.html-language-features&quot; &#125;, &quot;editor.fontSize&quot;: 16, &quot;debug.console.fontSize&quot;: 14, &quot;vsicons.dontShowNewVersionMessage&quot;: true, &quot;editor.minimap.enabled&quot;: true, &quot;emmet.extensionsPath&quot;: [ &quot;&quot; ], // vue eslint start 保存时自动格式化代码 &quot;editor.formatOnSave&quot;: true, // eslint配置项，保存时自动修复错误 &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: true &#125;, &quot;vetur.ignoreProjectWarning&quot;: true, // 让vetur使用vs自带的js格式化工具 // uni-app和vue 项目使用 &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &quot;javascript.format.semicolons&quot;: &quot;remove&quot;, // // 指定 *.vue 文件的格式化工具为vetur &quot;[vue]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot; &#125;, // // 指定 *.js 文件的格式化工具为vscode自带 &quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;vscode.typescript-language-features&quot; &#125;, // // 默认使用prettier格式化支持的文件 &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;prettier.jsxBracketSameLine&quot;: true, // 函数前面加个空格 &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &quot;prettier.singleQuote&quot;: true, &quot;prettier.semi&quot;: false, // eslint end // react // 当按tab键的时候，会自动提示 &quot;emmet.triggerExpansionOnTab&quot;: true, &quot;emmet.showAbbreviationSuggestions&quot;: true, &quot;emmet.includeLanguages&quot;: &#123; // jsx的提示 &quot;javascript&quot;: &quot;javascriptreact&quot;, &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot;, &quot;wxml&quot;: &quot;html&quot; &#125;, // end &quot;[jsonc]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;vscode.json-language-features&quot; &#125;, // @路径提示 &quot;path-intellisense.mappings&quot;: &#123; &quot;@&quot;: &quot;$&#123;workspaceRoot&#125;/src&quot; &#125;, &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &quot;git.ignoreMissingGitWarning&quot;: true, &quot;window.zoomLevel&quot;: 1&#125; 阶段小练习练习说明 拉取准备好的项目模块到本地 ，安装依赖，run起来项目 https://gitee.com/react-course-series/react-jsx-demo 按照图示，完成 评论数据渲染 tab内容渲染 评论列表点赞和点踩 三个视图渲染 React组件基础组件概念 函数组件目标任务: 能够独立使用函数完成react组件的创建和渲染概念使用 JS 的函数（或箭头函数）创建的组件，就叫做函数组件组件定义与渲染 // 定义函数组件function HelloFn () &#123; return &lt;div&gt;这是我的第一个函数组件!&lt;/div&gt;&#125;// 定义类组件function App () &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 渲染函数组件 */&#125; &lt;HelloFn /&gt; &lt;HelloFn&gt;&lt;/HelloFn&gt; &lt;/div&gt; )&#125;export default App 约定说明 组件的名称必须首字母大写，react内部会根据这个来判断是组件还是普通的HTML标签 函数组件必须有返回值，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null 组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的返回值就是对应的内容 使用函数名称作为组件标签名称，可以成对出现也可以自闭合 类组件目标任务: 能够独立完成类组件的创建和渲染使用 ES6 的 class 创建的组件，叫做类（class）组件组件定义与渲染 // 引入Reactimport React from &#x27;react&#x27;// 定义类组件class HelloC extends React.Component &#123; render () &#123; return &lt;div&gt;这是我的第一个类组件!&lt;/div&gt; &#125;&#125;function App () &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 渲染类组件 */&#125; &lt;HelloC /&gt; &lt;HelloC&gt;&lt;/HelloC&gt; &lt;/div&gt; )&#125;export default App 约定说明 类名称也必须以大写字母开头 类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性 类组件必须提供 render 方法render 方法必须有返回值，表示该组件的 UI 结构 函数组件的事件绑定目标任务: 能够独立绑定任何事件并能获取到事件对象e 1. 如何绑定事件 语法 on + 事件名称 &#x3D; { 事件处理程序 } ，比如：&lt;div onClick=&#123; onClick &#125;&gt;&lt;/div&gt; 注意点 react事件采用驼峰命名法，比如：onMouseEnter、onFocus 样例 // 函数组件function HelloFn () &#123; // 定义事件回调函数 const clickHandler = () =&gt; &#123; console.log(&#x27;事件被触发了&#x27;) &#125; return ( // 绑定事件 &lt;button onClick=&#123;clickHandler&#125;&gt;click me!&lt;/button&gt; )&#125; 2. 获取事件对象 获取事件对象e只需要在 事件的回调函数中 补充一个形参e即可拿到 // 函数组件function HelloFn () &#123; // 定义事件回调函数 const clickHandler = (e) =&gt; &#123; console.log(&#x27;事件被触发了&#x27;, e) &#125; return ( // 绑定事件 &lt;button onClick=&#123;clickHandler&#125;&gt;click me!&lt;/button&gt; )&#125; 3. 传递额外参数解决思路: 改造事件绑定为箭头函数 在箭头函数中完成参数的传递 import React from &quot;react&quot;// 如何获取额外的参数？// onClick=&#123; onDel &#125; -&gt; onClick=&#123; () =&gt; onDel(id) &#125;// 注意: 一定不要在模板中写出函数调用的代码 onClick = &#123; onDel(id) &#125; bad!!!!!!const TestComponent = () =&gt; &#123; const list = [ &#123; id: 1001, name: &#x27;react&#x27; &#125;, &#123; id: 1002, name: &#x27;vue&#x27; &#125; ] const onDel = (e, id) =&gt; &#123; console.log(e, id) &#125; return ( &lt;ul&gt; &#123;list.map(item =&gt;（ &lt;li key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;button onClick=&#123;(e) =&gt; onDel(e, item.id)&#125;&gt;x&lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;function App () &#123; return ( &lt;div&gt; &lt;TestComponent /&gt; &lt;/div&gt; )&#125;export default App 类组件的事件绑定类组件中的事件绑定，整体的方式和函数组件差别不大唯一需要注意的 因为处于class类语境下 所以定义事件回调函数以及定它写法上有不同 定义的时候: class Fields语法 \\2. 使用的时候: 需要借助this关键词获取import React from &quot;react&quot;class CComponent extends React.Component &#123; // class Fields clickHandler = (e, num) =&gt; &#123; // 这里的this指向的是正确的当前的组件实例对象 // 可以非常方便的通过this关键词拿到组件实例身上的其他属性或者方法 console.log(this) &#125; clickHandler1 () &#123; // 这里的this 不指向当前的组件实例对象而指向undefined 存在this丢失问题 console.log(this) &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;(e) =&gt; this.clickHandler(e, &#x27;123&#x27;)&#125;&gt;click me&lt;/button&gt; &lt;button onClick=&#123;this.clickHandler1&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;function App () &#123; return ( &lt;div&gt; &lt;CComponent /&gt; &lt;/div&gt; )&#125;export default App 组件状态目标任务: 能够为组件添加状态和修改状态的值一个前提：在React hook出来之前，函数式组件是没有自己的状态的，所以我们统一通过类组件来讲解 1. 初始化状态 通过class的实例属性state来初始化 state的值是一个对象结构，表示一个组件可以有多个数据状态 class Counter extends React.Component &#123; // 初始化状态 state = &#123; count: 0 &#125; render() &#123; return &lt;button&gt;计数器&lt;/button&gt; &#125;&#125; 2. 读取状态 通过this.state来获取状态 class Counter extends React.Component &#123; // 初始化状态 state = &#123; count: 0 &#125; render() &#123; // 读取状态 return &lt;button&gt;计数器&#123;this.state.count&#125;&lt;/button&gt; &#125;&#125; 3. 修改状态 语法 this.setState(&#123; 要修改的部分数据 &#125;) setState方法作用 修改state中的数据状态 更新UI 思想 数据驱动视图，也就是只要修改数据状态，那么页面就会自动刷新，无需手动操作dom 注意事项 不要直接修改state中的值，必须通过setState方法进行修改 class Counter extends React.Component &#123; // 定义数据 state = &#123; count: 0 &#125; // 定义修改数据的方法 setCount = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; // 使用数据 并绑定事件 render () &#123; return &lt;button onClick=&#123;this.setCount&#125;&gt;&#123;this.state.count&#125;&lt;/button&gt; &#125;&#125; this问题说明这里我们作为了解内容，随着js标准的发展，主流的写法已经变成了class fields，无需考虑太多this问题 React的状态不可变目标任务: 能够理解不可变的意义并且知道在实际开发中如何修改状态概念：不要直接修改状态的值，而是基于当前状态创建新的状态值1. 错误的直接修改 state = &#123; count : 0, list: [1,2,3], person: &#123; name:&#x27;jack&#x27;, age:18 &#125;&#125;// 直接修改简单类型Numberthis.state.count++++this.state.countthis.state.count += 1this.state.count = 1// 直接修改数组this.state.list.push(123)this.state.list.spice(1,1)// 直接修改对象this.state.person.name = &#x27;rose&#x27; 2. 基于当前状态创建新值 this.setState(&#123; count: this.state.count + 1 list: [...this.state.list, 4], person: &#123; ...this.state.person, // 覆盖原来的属性 就可以达到修改对象中属性的目的 name: &#x27;rose&#x27; &#125;&#125;) 表单处理目标任务: 能够使用受控组件的方式获取文本框的值使用React处理表单元素，一般有俩种方式： 受控组件 （推荐使用） 非受控组件 （了解） 1. 受控表单组件什么是受控组件？ input框自己的状态被React组件状态控制React组件的状态的地方是在state中，input表单元素也有自己的状态是在value中，React将state与表单元素的值（value）绑定到一起，由state的值来控制表单元素的值，从而保证单一数据源特性实现步骤以获取文本框的值为例，受控组件的使用步骤如下： 在组件的state中声明一个组件的状态数据 将状态数据设置为input标签元素的value属性的值 为input添加change事件，在事件处理程序中，通过事件对象e获取到当前文本框的值（即用户当前输入的值） 调用setState方法，将文本框的值作为state状态的最新值代码落地import React from &#x27;react&#x27;class InputComponent extends React.Component &#123; // 声明组件状态 state = &#123; message: &#x27;this is message&#x27;, &#125; // 声明事件回调函数 changeHandler = (e) =&gt; &#123; this.setState(&#123; message: e.target.value &#125;) &#125; render () &#123; return ( &lt;div&gt; &#123;/* 绑定value 绑定事件*/&#125; &lt;input value=&#123;this.state.message&#125; onChange=&#123;this.changeHandler&#125; /&gt; &lt;/div&gt; ) &#125;&#125;function App () &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;InputComponent /&gt; &lt;/div&gt; )&#125;export default App 2. 非受控表单组件什么是非受控组件？非受控组件就是通过手动操作dom的方式获取文本框的值，文本框的状态不受react组件的state中的状态控制，直接通过原生dom获取输入框的值实现步骤 导入createRef 函数 调用createRef函数，创建一个ref对象，存储到名为msgRef的实例属性中 为input添加ref属性，值为msgRef 在按钮的事件处理程序中，通过msgRef.current即可拿到input对应的dom元素，而其中msgRef.current.value拿到的就是文本框的值代码落地import React, &#123; createRef &#125; from &#x27;react&#x27;class InputComponent extends React.Component &#123; // 使用createRef产生一个存放dom的对象容器 msgRef = createRef() changeHandler = () =&gt; &#123; console.log(this.msgRef.current.value) &#125; render() &#123; return ( &lt;div&gt; &#123;/* ref绑定 获取真实dom */&#125; &lt;input ref=&#123;this.msgRef&#125; /&gt; &lt;button onClick=&#123;this.changeHandler&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;function App () &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;InputComponent /&gt; &lt;/div&gt; )&#125;export default App 阶段小练习练习说明 拉取项目模板到本地，安装依赖，run起来项目 https://gitee.com/react-course-series/react-component-demo 完成tab点击切换激活状态交互 完成发表评论功能 注意：生成独立无二的id 可以使用 uuid 包 yarn add uuid import &#123; v4 as uuid &#125; from &#x27;uuid&#x27;uuid() // 得到一个独一无二的id 完成删除评论功能 React组件通信组件通信的意义目标任务: 了解为什么需要组件通信组件是独立且封闭的单元，默认情况下组件只能使用自己的数据（state）组件化开发的过程中，完整的功能会拆分多个组件，在这个过程中不可避免的需要互相传递一些数据为了能让各组件之间可以进行互相沟通，数据传递，这个过程就是组件通信 父子关系 - 最重要的 兄弟关系 - 自定义事件模式产生技术方法 eventBus &#x2F; 通过共同的父组件通信 其它关系 - mobx &#x2F; redux &#x2F; zustand 父传子实现目标任务: 实现父子通信中的父传子，把父组件中的数据传给子组件实现步骤 父组件提供要传递的数据 - state 给子组件标签添加属性值为 state中的数据 子组件中通过 props 接收父组件中传过来的数据 类组件使用this.props获取props对象 函数式组件直接通过参数获取props对象代码实现import React from &#x27;react&#x27;// 函数式子组件function FSon(props) &#123; console.log(props) return ( &lt;div&gt; 子组件1 &#123;props.msg&#125; &lt;/div&gt; )&#125;// 类子组件class CSon extends React.Component &#123; render() &#123; return ( &lt;div&gt; 子组件2 &#123;this.props.msg&#125; &lt;/div&gt; ) &#125;&#125;// 父组件class App extends React.Component &#123; state = &#123; message: &#x27;this is message&#x27; &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;FSon msg=&#123;this.state.message&#125; /&gt; &lt;CSon msg=&#123;this.state.message&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App props说明目标任务: 知道props传递时的一些注意事项1. props是只读对象（readonly）根据单项数据流的要求，子组件只能读取props中的数据，不能进行修改2. props可以传递任意数据数字、字符串、布尔值、数组、对象、函数、JSX class App extends React.Component &#123; state = &#123; message: &#x27;this is message&#x27; &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;FSon msg=&#123;this.state.message&#125; age=&#123;20&#125; isMan=&#123;true&#125; cb=&#123;() =&gt; &#123; console.log(1) &#125;&#125; child=&#123;&lt;span&gt;this is child&lt;/span&gt;&#125; /&gt; &lt;CSon msg=&#123;this.state.message&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 子传父实现目标任务: 实现父子通信中的子传父口诀： 父组件给子组件传递回调函数，子组件调用实现步骤 父组件提供一个回调函数 - 用于接收数据 将函数作为属性的值，传给子组件 子组件通过props调用 回调函数 将子组件中的数据作为参数传递给回调函数代码实现import React from &#x27;react&#x27;// 子组件function Son(props) &#123; function handleClick() &#123; // 调用父组件传递过来的回调函数 并注入参数 props.changeMsg(&#x27;this is newMessage&#x27;) &#125; return ( &lt;div&gt; &#123;props.msg&#125; &lt;button onClick=&#123;handleClick&#125;&gt;change&lt;/button&gt; &lt;/div&gt; )&#125;class App extends React.Component &#123; state = &#123; message: &#x27;this is message&#x27; &#125; // 提供回调函数 changeMessage = (newMsg) =&gt; &#123; console.log(&#x27;子组件传过来的数据:&#x27;,newMsg) this.setState(&#123; message: newMsg &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;Son msg=&#123;this.state.message&#125; // 传递给子组件 changeMsg=&#123;this.changeMessage&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App 兄弟组件通信目标任务: 实现兄弟组件之间的通信核心思路： 通过状态提升机制，利用共同的父组件实现兄弟通信实现步骤 将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态 提供共享状态 提供操作共享状态的方法 要接收数据状态的子组件通过 props 接收数据 要传递数据状态的子组件通过props接收方法，调用方法传递数据代码实现import React from &#x27;react&#x27;// 子组件Afunction SonA(props) &#123; return ( &lt;div&gt; SonA &#123;props.msg&#125; &lt;/div&gt; )&#125;// 子组件Bfunction SonB(props) &#123; return ( &lt;div&gt; SonB &lt;button onClick=&#123;() =&gt; props.changeMsg(&#x27;new message&#x27;)&#125;&gt;changeMsg&lt;/button&gt; &lt;/div&gt; )&#125;// 父组件class App extends React.Component &#123; // 父组件提供状态数据 state = &#123; message: &#x27;this is message&#x27; &#125; // 父组件提供修改数据的方法 changeMsg = (newMsg) =&gt; &#123; this.setState(&#123; message: newMsg &#125;) &#125; render() &#123; return ( &lt;&gt; &#123;/* 接收数据的组件 */&#125; &lt;SonA msg=&#123;this.state.message&#125; /&gt; &#123;/* 修改数据的组件 */&#125; &lt;SonB changeMsg=&#123;this.changeMsg&#125; /&gt; &lt;/&gt; ) &#125;&#125;export default App 跨组件通信Context目标任务: 了解Context机制解决的问题和使用步骤上图是一个react形成的嵌套组件树，如果我们想从App组件向任意一个下层组件传递数据，该怎么办呢？目前我们能采取的方式就是一层一层的props往下传，显然很繁琐那么，Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法实现步骤1- 创建Context对象 导出 Provider 和 Consumer对象 const &#123; Provider, Consumer &#125; = createContext() 2- 使用Provider包裹上层组件提供数据 &lt;Provider value=&#123;this.state.message&#125;&gt; &#123;/* 根组件 */&#125;&lt;/Provider&gt; 3- 需要用到数据的组件使用Consumer包裹获取数据 &lt;Consumer &gt; &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/Consumer&gt; 代码实现 import React, &#123; createContext &#125; from &#x27;react&#x27;// 1. 创建Context对象 const &#123; Provider, Consumer &#125; = createContext()// 3. 消费数据function ComC() &#123; return ( &lt;Consumer &gt; &#123;value =&gt; &lt;div&gt;&#123;value&#125;&lt;/div&gt;&#125; &lt;/Consumer&gt; )&#125;function ComA() &#123; return ( &lt;ComC/&gt; )&#125;// 2. 提供数据class App extends React.Component &#123; state = &#123; message: &#x27;this is message&#x27; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.message&#125;&gt; &lt;div className=&quot;app&quot;&gt; &lt;ComA /&gt; &lt;/div&gt; &lt;/Provider&gt; ) &#125;&#125;export default App 阶段小练习要求：App为父组件用来提供列表数据 ，ListItem为子组件用来渲染列表数据 // 列表数据[ &#123; id: 1, name: &#x27;超级好吃的棒棒糖&#x27;, price: 18.8, info: &#x27;开业大酬宾，全场8折&#x27; &#125;, &#123; id: 2, name: &#x27;超级好吃的大鸡腿&#x27;, price: 34.2, info: &#x27;开业大酬宾，全场8折&#x27; &#125;, &#123; id: 3, name: &#x27;超级无敌的冰激凌&#x27;, price: 14.2, info: &#x27;开业大酬宾，全场8折&#x27; &#125;] 完整代码 import React from &#x27;react&#x27;// 子组件function ListItem(props) &#123; const &#123; name, price, info, id, delHandler &#125; = props return ( &lt;div&gt; &lt;h3&gt;&#123;name&#125;&lt;/h3&gt; &lt;p&gt;&#123;price&#125;&lt;/p&gt; &lt;p&gt;&#123;info&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; delHandler(id)&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; )&#125;// 父组件class App extends React.Component &#123; state = &#123; list: [ &#123; id: 1, name: &#x27;超级好吃的棒棒糖&#x27;, price: 18.8, info: &#x27;开业大酬宾，全场8折&#x27; &#125;, &#123; id: 2, name: &#x27;超级好吃的大鸡腿&#x27;, price: 34.2, info: &#x27;开业大酬宾，全场8折&#x27; &#125;, &#123; id: 3, name: &#x27;超级无敌的冰激凌&#x27;, price: 14.2, info: &#x27;开业大酬宾，全场8折&#x27; &#125; ] &#125; delHandler = (id) =&gt; &#123; this.setState(&#123; list: this.state.list.filter(item =&gt; item.id !== id) &#125;) &#125; render() &#123; return ( &lt;&gt; &#123; this.state.list.map(item =&gt; &lt;ListItem key=&#123;item.id&#125; &#123;...item&#125; delHandler=&#123;this.delHandler&#125; /&gt; ) &#125; &lt;/&gt; ) &#125;&#125;export default App React组件进阶children属性目标任务: 掌握props中children属性的用法children属性是什么表示该组件的子节点，只要组件内部有子节点，props中就有该属性children可以是什么 普通文本 普通标签元素 函数 &#x2F; 对象 JSX props校验-场景和使用目标任务: 掌握组件props的校验写法，增加组件的健壮性对于组件来说，props是由外部传入的，我们其实无法保证组件使用者传入了什么格式的数据，如果传入的数据格式不对，就有可能会导致组件内部错误，有一个点很关键 - 组件的使用者可能报错了也不知道为什么，看下面的例子面对这样的问题，如何解决？ props校验实现步骤 安装属性校验包：yarn add prop-types 导入prop-types 包 使用 组件名.propTypes = &#123;&#125; 给组件添加校验规则核心代码import PropTypes from &#x27;prop-types&#x27;const List = props =&gt; &#123; const arr = props.colors const lis = arr.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;/li&gt;) return &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt;&#125;List.propTypes = &#123; colors: PropTypes.array&#125; props校验-规则说明目标任务: 掌握props常见的规则四种常见结构 常见类型：array、bool、func、number、object、string React元素类型：element 必填项：isRequired 特定的结构对象：shape({})核心代码// 常见类型optionalFunc: PropTypes.func,// 必填 只需要在类型后面串联一个isRequiredrequiredFunc: PropTypes.func.isRequired,// 特定结构的对象optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number&#125;) 官网文档更多阅读：https://reactjs.org/docs/typechecking-with-proptypes.html props校验-默认值目标任务: 掌握如何给组件的props提供默认值通过 defaultProps 可以给组件的props设置默认值，在未传入props的时候生效 1. 函数组件直接使用函数参数默认值 function List(&#123;pageSize = 10&#125;) &#123; return ( &lt;div&gt; 此处展示props的默认值：&#123; pageSize &#125; &lt;/div&gt; )&#125;// 不传入pageSize属性&lt;List /&gt; 2. 类组件使用类静态属性声明默认值，static defaultProps = &#123;&#125; class List extends Component &#123; static defaultProps = &#123; pageSize: 10 &#125; render() &#123; return ( &lt;div&gt; 此处展示props的默认值：&#123;this.props.pageSize&#125; &lt;/div&gt; ) &#125;&#125;&lt;List /&gt; 生命周期 - 概述目标任务: 能够说出组件生命周期一共几个阶段组件的生命周期是指组件从被创建到挂载到页面中运行起来，再到组件不用时卸载的过程，注意，只有类组件才有生命周期（类组件 实例化 函数组件 不需要实例化）http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ 生命周期 - 挂载阶段目标任务: 能够说出在组件挂载阶段执行的钩子函数和执行时机 钩子 函数 触发时机 作用 constructor 创建组件时，最先执行，初始化的时候只执行一次 1. 初始化state 2. 创建 Ref 3. 使用 bind 解决 this 指向问题等 render 每次组件渲染都会触发 渲染UI（注意： 不能在里面调用setState() ） componentDidMount 组件挂载（完成DOM渲染）后执行，初始化的时候执行一次 1. 发送网络请求 2.DOM操作 生命周期 - 更新阶段目标任务: 能够说出组件的更新阶段的钩子函数以及执行时机 钩子函数 触发时机 作用 render 每次组件渲染都会触发 渲染UI（与 挂载阶段 是同一个render） componentDidUpdate 组件更新后（DOM渲染完毕） DOM操作，可以获取到更新后的DOM内容，不要直接调用setState 生命周期 - 卸载阶段目标任务: 能够说出组件的销毁阶段的钩子函数以及执行时机 钩子函数 触发时机 作用 componentWillUnmount 组件卸载（从页面中消失） 执行清理工作（比如：清理定时器等） 阶段小练习 - todoMVC案例仓库地址：https://gitee.com/react-course-series/react-todo-mvc1- 克隆项目到本地 $ git clone https://gitee.com/react-course-series/react-todo-mvc.git 2- 安装必要依赖 $ yarn 3- 开启mock接口服务，保持窗口不关闭 ！！！！！ # 启动mock服务$ yarn mock-serve 4- 另起一个bash窗口开启前端服务 $ yarn start 5- 切换到todo-test分支 $ git checkout todo-test 接口文档 接口作用 接口地址 接口方法 接口参数 获取列表 http://localhost:3001/data GET 无 删除 http://localhost:3001/data/:id DELETE id 搜索 http://localhost:3001/data/?name=keyword GET name（以name字段搜索） 实现功能 功能 核心思路 ———— ———————————— 表格数据渲染 组件使用 删除功能 获取当前id 调用接口 搜索功能 用的依旧是列表接口，多传一个name参数 清除搜索功能 清空搜索参数 重新获取列表 Hooks基础Hooks概念理解本节任务: 能够理解hooks的概念及解决的问题 1. 什么是hooksHooks的本质：一套能够使函数组件更强大，更灵活的“钩子”React体系里组件分为 类组件 和 函数组件经过多年的实战，函数组件是一个更加匹配React的设计理念 UI = f(data)，也更有利于逻辑拆分与重用的组件表达形式，而先前的函数组件是不可以有自己的状态的，为了能让函数组件可以拥有自己的状态，所以从react v16.8开始，Hooks应运而生注意点： 有了hooks之后，为了兼容老版本，class类组件并没有被移除，俩者都可以使用 有了hooks之后，不能在把函数成为无状态组件了，因为hooks为函数组件提供了状态 hooks只能在函数组件中使用 2. Hooks解决了什么问题Hooks的出现解决了俩个问题 1. 组件的状态逻辑复用 2.class组件自身的问题 组件的逻辑复用 在hooks出现之前，react先后尝试了 mixins混入，HOC高阶组件，render-props等模式 但是都有各自的问题，比如mixin的数据来源不清晰，高阶组件的嵌套问题等等 class组件自身的问题 class组件就像一个厚重的‘战舰’ 一样，大而全，提供了很多东西，有不可忽视的学习成本，比如各种生命周期，this指向问题等等，而我们更多时候需要的是一个轻快灵活的’快艇’ useState1. 基础使用本节任务: 能够学会useState的基础用法作用useState为函数组件提供状态（state）使用步骤 导入 useState 函数 调用 useState 函数，并传入状态的初始值 从useState函数的返回值中，拿到状态和修改状态的方法 在JSX中展示状态 调用修改状态的方法更新状态代码实现import &#123; useState &#125; from &#x27;react&#x27;function App() &#123; // 参数：状态初始值比如,传入 0 表示该状态的初始值为 0 // 返回值：数组,包含两个值：1 状态值（state） 2 修改该状态的函数（setState） const [count, setCount] = useState(0) return ( &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt; )&#125;export default App 2. 状态的读取和修改本节任务: 能够理解useState下状态的读取和修改读取状态该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用修改状态 setCount是一个函数，参数表示最新的状态值 调用该函数后，将使用新值替换旧值 修改状态后，由于状态发生变化，会引起视图变化注意事项 修改状态的时候，一定要使用新的状态替换旧的状态，不能直接修改旧的状态，尤其是引用类型 3. 组件的更新过程本节任务: 能够理解使用hook之后组件的更新情况函数组件使用 useState hook 后的执行过程，以及状态值的变化 组件第一次渲染 从头开始执行该组件中的代码逻辑 调用 useState(0) 将传入的参数作为状态初始值，即：0 渲染组件，此时，获取到的状态 count 值为： 0 组件第二次渲染 点击按钮，调用 setCount(count + 1) 修改状态，因为状态发生改变，所以，该组件会重新渲染 组件重新渲染时，会再次执行该组件中的代码逻辑 再次调用 useState(0)，此时 React 内部会拿到最新的状态值而非初始值，比如，该案例中最新的状态值为 1 再次渲染组件，此时，获取到的状态 count 值为：1注意：useState 的初始值(参数)只会在组件第一次渲染时生效。也就是说，以后的每次渲染，useState 获取到都是最新的状态值，React 组件会记住每次最新的状态值import &#123; useState &#125; from &#x27;react&#x27;function App() &#123; const [count, setCount] = useState(0) // 在这里可以进行打印测试 console.log(count) return ( &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt; )&#125;export default App 4. 使用规则本节任务: 能够记住useState的使用规则 useState 函数可以执行多次，每次执行互相独立，每调用一次为函数组件提供一个状态 function List()&#123; // 以字符串为初始值 const [name, setName] = useState(&#x27;cp&#x27;) // 以数组为初始值 const [list,setList] = useState([])&#125; useState 注意事项 只能出现在函数组件或者其他hook函数中 不能嵌套在if&#x2F;for&#x2F;其它函数中（react按照hooks的调用顺序识别每一个hook） let num = 1function List()&#123; num++ if(num / 2 === 0)&#123; const [name, setName] = useState(&#x27;cp&#x27;) &#125; const [list,setList] = useState([])&#125;// 俩个hook的顺序不是固定的，这是不可以的！！！ 可以通过开发者工具查看hooks状态 useEffect1. 理解函数副作用本节任务: 能够理解副作用的概念什么是副作用副作用是相对于主作用来说的，一个函数除了主作用，其他的作用就是副作用。对于 React 组件来说，主作用就是根据数据（state&#x2F;props）渲染 UI，除此之外都是副作用（比如，手动修改 DOM）常见的副作用 数据请求 ajax发送 手动修改dom localstorage操作useEffect函数的作用就是为react函数组件提供副作用处理的！ 2. 基础使用本节任务: 能够学会useEffect的基础用法并且掌握默认的执行执行时机作用为react函数组件提供副作用处理使用步骤 导入 useEffect 函数 调用 useEffect 函数，并传入回调函数 在回调函数中编写副作用处理（dom操作） 修改数据状态 检测副作用是否生效代码实现import &#123; useEffect, useState &#125; from &#x27;react&#x27;function App() &#123; const [count, setCount] = useState(0) useEffect(()=&gt;&#123; // dom操作 document.title = `当前已点击了$&#123;count&#125;次` &#125;) return ( &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt; )&#125;export default App 3. 依赖项控制执行时机本节任务: 能够学会使用依赖项控制副作用的执行时机1. 不添加依赖项组件首次渲染执行一次，以及不管是哪个状态更改引起组件更新时都会重新执行 组件初始渲染 组件更新 （不管是哪个状态引起的更新）useEffect(()=&gt;&#123; console.log(&#x27;副作用执行了&#x27;)&#125;) 2. 添加空数组组件只在首次渲染时执行一次useEffect(()=&gt;&#123; console.log(&#x27;副作用执行了&#x27;)&#125;,[]) 3. 添加特定依赖项副作用函数在首次渲染时执行，在依赖项发生变化时重新执行function App() &#123; const [count, setCount] = useState(0) const [name, setName] = useState(&#x27;zs&#x27;) useEffect(() =&gt; &#123; console.log(&#x27;副作用执行了&#x27;) &#125;, [count]) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; setName(&#x27;cp&#x27;) &#125;&#125;&gt;&#123;name&#125;&lt;/button&gt; &lt;/&gt; )&#125; 注意事项useEffect 回调函数中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中，如果不添加依赖项就会有bug出现 4. 清理副作用如果想要清理副作用 可以在副作用函数中的末尾return一个新的函数，在新的函数中编写清理副作用的逻辑注意执行时机为： 组件卸载时自动执行 组件更新时，下一个useEffect副作用函数执行之前自动执行import &#123; useEffect, useState &#125; from &quot;react&quot;const App = () =&gt; &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; const timerId = setInterval(() =&gt; &#123; setCount(count + 1) &#125;, 1000) return () =&gt; &#123; // 用来清理副作用的事情 clearInterval(timerId) &#125; &#125;, [count]) return ( &lt;div&gt; &#123;count&#125; &lt;/div&gt; )&#125;export default App 阶段小练习 - 自定义hook需求描述：自定义一个hook函数，实现获取滚动距离Y const [y] = useWindowScroll()import &#123; useState, useEffect &#125; from &quot;react&quot;export function useWindowScroll () &#123; const [y, setY] = useState(0) useEffect(()=&gt;&#123; const scrollHandler = () =&gt; &#123; const h = document.documentElement.scrollTop setY(h) &#125;) window.addEventListener(&#x27;scroll&#x27;, scrollHandler) return () =&gt; window.removeEventListener(&#x27;scroll&#x27;, scrollHandler) &#125;) return [y]&#125; 需求描述： 自定义hook函数，可以自动同步到本地LocalStorage const [message, setMessage] = useLocalStorage(key，defaultValue) message可以通过自定义传入默认初始值 每次修改message数据的时候 都会自动往本地同步一份import &#123; useEffect, useState &#125; from &#x27;react&#x27;export function useLocalStorage (key, defaultValue) &#123; const [message, setMessage] = useState(defaultValue) // 每次只要message变化 就会自动同步到本地ls useEffect(() =&gt; &#123; window.localStorage.setItem(key, message) &#125;, [message, key]) return [message, setMessage]&#125; Hooks进阶useState - 回调函数的参数本节任务: 能够理解useState回调函数作为参数的使用场景使用场景参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过计算才能获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用语法 const [name, setName] = useState(()=&gt;&#123; // 编写计算逻辑 return &#x27;计算之后的初始值&#x27;&#125;) 语法规则 回调函数return出去的值将作为 name 的初始值 回调函数中的逻辑只会在组件初始化的时候执行一次语法选择 如果就是初始化一个普通的数据 直接使用 useState(普通数据) 即可 如果要初始化的数据无法直接得到需要通过计算才能获取到，使用useState(()=&gt;&#123;&#125;)来个需求import &#123; useState &#125; from &#x27;react&#x27;function Counter(props) &#123; const [count, setCount] = useState(() =&gt; &#123; return props.count &#125;) return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;/div&gt; )&#125;function App() &#123; return ( &lt;&gt; &lt;Counter count=&#123;10&#125; /&gt; &lt;Counter count=&#123;20&#125; /&gt; &lt;/&gt; )&#125;export default App useEffect - 发送网络请求本节任务: 能够掌握使用useEffect hook发送网络请求使用场景如何在useEffect中发送网络请求，并且封装同步 async await操作语法要求不可以直接在useEffect的回调函数外层直接包裹 await ，因为异步会导致清理函数无法立即返回 useEffect(async ()=&gt;&#123; const res = await axios.get(&#x27;http://geek.itheima.net/v1_0/channels&#x27;) console.log(res)&#125;,[]) 正确写法在内部单独定义一个函数，然后把这个函数包装成同步 useEffect(()=&gt;&#123; async function fetchData()&#123; const res = await axios.get(&#x27;http://geek.itheima.net/v1_0/channels&#x27;) console.log(res) &#125; &#125;,[]) useRef本节任务: 能够掌握使用useRef获取真实dom或组件实例的方法使用场景在函数组件中获取真实的dom元素对象或者是组件对象使用步骤 导入 useRef 函数 执行 useRef 函数并传入null，返回值为一个对象 内部有一个current属性存放拿到的dom对象（组件实例） 通过ref 绑定 要获取的元素或者组件获取domimport &#123; useEffect, useRef &#125; from &#x27;react&#x27;function App() &#123; const h1Ref = useRef(null) useEffect(() =&gt; &#123; console.log(h1Ref) &#125;,[]) return ( &lt;div&gt; &lt;h1 ref=&#123; h1Ref &#125;&gt;this is h1&lt;/h1&gt; &lt;/div&gt; )&#125;export default App 获取组件实例函数组件由于没有实例，不能使用ref获取，如果想获取组件实例，必须是类组件class Foo extends React.Component &#123; sayHi = () =&gt; &#123; console.log(&#x27;say hi&#x27;) &#125; render()&#123; return &lt;div&gt;Foo&lt;/div&gt; &#125;&#125; export default Foo import &#123; useEffect, useRef &#125; from &#x27;react&#x27;import Foo from &#x27;./Foo&#x27;function App() &#123; const h1Foo = useRef(null) useEffect(() =&gt; &#123; console.log(h1Foo) &#125;, []) return ( &lt;div&gt; &lt;Foo ref=&#123; h1Foo &#125; /&gt;&lt;/div&gt; )&#125;export default App useContext本节任务: 能够掌握hooks下的context使用方式实现步骤 使用createContext 创建Context对象 在顶层组件通过Provider 提供数据 在底层组件通过useContext函数获取数据代码实现import &#123; createContext, useContext &#125; from &#x27;react&#x27;// 创建Context对象const Context = createContext()function Foo() &#123; return &lt;div&gt;Foo &lt;Bar/&gt;&lt;/div&gt;&#125;function Bar() &#123; // 底层组件通过useContext函数获取数据 const name = useContext(Context) return &lt;div&gt;Bar &#123;name&#125;&lt;/div&gt;&#125;function App() &#123; return ( // 顶层组件通过Provider 提供数据 &lt;Context.Provider value=&#123;&#x27;this is name&#x27;&#125;&gt; &lt;div&gt;&lt;Foo/&gt;&lt;/div&gt; &lt;/Context.Provider&gt; )&#125;export default App 阶段小练习-todoMvc-hook版案例仓库地址：https://gitee.com/react-course-series/react-tomvc-hook 克隆项目到本地 $ git clone https://gitee.com/react-course-series/react-tomvc-hook.git 安装必要依赖 $ yarn 开启mock接口服务，保持窗口不关闭 ！！！！！ # 启动mock服务$ yarn mock-serve 另起一个bash窗口开启前端服务 $ yarn start 浏览器输入 localhost:3000演示效果项目开发步骤： 切换到todo-test分支 $ git checkout todo-test 打开 app.js 已有基础样板代码，在这个基础上编写业务逻辑即可 接口文档 接口作用 接口地址 接口方法 接口参数 获取列表 http://localhost:3001/data GET 无 删除 http://localhost:3001/data/:id DELETE id | 搜索 | http://localhost:3001/data/?name=keyword | GET | name（以name字段搜索） |实现功能 功能 核心思路 表格数据渲染 elementPlus el-table组件使用 删除功能 获取当前id 调用接口 搜索功能 用的依旧是列表接口，多传一个name参数 清除搜索功能 清空搜索参数 重新获取列表","categories":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"}]},{"title":"elasticsearch学习","slug":"编程语言/Java/学习/框架/Elasticsearct/Elasticsearct学习","date":"2023-05-29T16:00:00.000Z","updated":"2024-06-01T14:32:53.434Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearct-xue-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearct-xue-xi.html","excerpt":"","text":"elasticsearch学习索引库操作下载sql文件，执行sql 执行sql，创建表sql文件 进入kibana 进入kibana在 Elasticsearch 中，创建文档、索引和 mapping 的顺序如下： 创建索引：在 Elasticsearch 中，索引是存储文档的容器。要创建索引，可以使用 PUT 请求，指定索引名称和一些可选的设置。 创建 mapping：mapping 定义了索引中的字段和它们的数据类型。要创建 mapping，可以使用 PUT 请求，指定索引名称和 mapping 定义。 创建文档：文档是索引中的数据单元。要创建文档，可以使用 POST 请求，指定索引名称、文档 ID 和文档内容。 需要注意的是，如果在创建文档时指定的索引不存在，Elasticsearch 会自动创建该索引，并使用默认的 mapping。因此，为了确保索引中的字段和数据类型符合预期，最好在创建索引之前先定义好 mapping。 酒店定义如下，但是注意一个问题name、brand、business等字段都要参与搜索，也就是说用户输入的关键词可能是多个关键字（查询条件不是一个值，而是多个值） 可以使用copy_to属性，将当前字段拷贝到指定字段 # 酒店的mapping映射（不完美）PUT /hotel&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;business&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;:&quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:false &#125; &#125; &#125;&#125; 更改后的mapping如下 # 酒店的mapping映射PUT /hotel&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;address&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;score&quot;:&#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;brand&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;city&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;starName&quot;:&#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;business&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;copy_to&quot;:&quot;all&quot; &#125;, &quot;location&quot;:&#123; &quot;type&quot;:&quot;geo_point&quot; &#125;, &quot;pic&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:false &#125;, &quot;all&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125; &#125; &#125;&#125; 创建项目 可以看到我这里的版本是8.6.2pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.12.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--elasticsearch--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写测试类import lombok.extern.slf4j.Slf4j;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4jclass HotelDocumentTest &#123; private RestHighLevelClient client; @BeforeEach void initClient()&#123; this.client=new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://localhost:9200&quot;) // 若是集群，可指定多个地址如下 //HttpHost.create(&quot;http://localhost:9200&quot;), //HttpHost.create(&quot;http://localhost:9200&quot;) )); &#125; @AfterEach void destroyClient()&#123; try &#123; this.client.close(); &#125; catch (IOException e) &#123; log.error(&quot;关闭资源出错,&#123;&#125;&quot;,e.getMessage()); throw new RuntimeException(e); &#125; &#125; @Test void contextLoads() &#123; System.out.println(client); &#125;&#125; 存放静态常量 public class HotelContants &#123; public static final String MAPPING_TEMPLATE=&quot;&#123;\\n&quot; + &quot; \\&quot;mappings\\&quot;: &#123;\\n&quot; + &quot; \\&quot;properties\\&quot;: &#123;\\n&quot; + &quot; \\&quot;id\\&quot;: &#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;name\\&quot;: &#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot; \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;:\\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;address\\&quot;: &#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;index\\&quot;: false\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;price\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;score\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;brand\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;:\\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;city\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;starName\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;business\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;copy_to\\&quot;:\\&quot;all\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;location\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;geo_point\\&quot;\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;pic\\&quot;:&#123;\\n&quot; + &quot; \\&quot;type\\&quot;:\\&quot;keyword\\&quot;,\\n&quot; + &quot; \\&quot;index\\&quot;:false\\n&quot; + &quot; &#125;,\\n&quot; + &quot; \\&quot;all\\&quot;: &#123;\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot; \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;;&#125; 编写测试方法 import com.example.demo.constants.HotelContants;import lombok.extern.slf4j.Slf4j;import org.apache.http.HttpHost;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.common.xcontent.XContentType;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4jclass HotelDocumentTest &#123; private RestHighLevelClient client; @BeforeEach void initClient()&#123; this.client=new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://localhost:9200&quot;) // 若是集群，可指定多个地址如下 //HttpHost.create(&quot;http://localhost:9200&quot;), //HttpHost.create(&quot;http://localhost:9200&quot;) )); &#125; @AfterEach void destroyClient()&#123; try &#123; this.client.close(); &#125; catch (IOException e) &#123; log.error(&quot;关闭资源出错,&#123;&#125;&quot;,e.getMessage()); throw new RuntimeException(e); &#125; &#125; /** * 创建索引库 */ @Test void createHotelIndexTest()&#123; // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;); // 2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句 request.source(HotelContants.MAPPING_TEMPLATE, XContentType.JSON); // 3.发起请求 try &#123; client.indices().create(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 运行成功，前往kibana查询索引库 GET /hotel 删除索引库、判断索引库是否存在 import com.example.demo.constants.HotelContants;import lombok.extern.slf4j.Slf4j;import org.apache.http.HttpHost;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.common.xcontent.XContentType;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4jclass HotelDocumentTest &#123; private RestHighLevelClient client; @BeforeEach void initClient() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://localhost:9200&quot;) // 若是集群，可指定多个地址如下 //HttpHost.create(&quot;http://localhost:9200&quot;), //HttpHost.create(&quot;http://localhost:9200&quot;) )); &#125; @AfterEach void destroyClient() &#123; try &#123; this.client.close(); &#125; catch (IOException e) &#123; log.error(&quot;关闭资源出错,&#123;&#125;&quot;, e.getMessage()); throw new RuntimeException(e); &#125; &#125; /** * 创建索引库 */ @Test void createHotelIndexTest() &#123; // 1.创建Request对象 CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;); // 2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句 request.source(HotelContants.MAPPING_TEMPLATE, XContentType.JSON); // 3.发起请求 try &#123; client.indices().create(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 删除索引库 */ @Test void deleteHotelIndexTest() &#123; // 1.创建Request对象 DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;); // 2.发起请求 try &#123; client.indices().delete(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 判断索引库是否存在 */ @Test void existsHotelIndexTest() &#123; // 1.创建Request对象 GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;); // 2.发起请求 boolean exists = false; try &#123; exists = client.indices().exists(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; System.out.println(&quot;索引库&quot;+(exists?&quot;存在&quot;:&quot;不存在&quot;)); &#125;&#125; 索引库总结索引库操作的基本步骤 初始化RestHighLevelClient 创建XXXIndexRequest（XXX是create、get、delete） 准备DSL（create时需要语句） 发送请求，调用RestHighLevelClient对象的indices().xxx()方法（xxx是create、exists、delete） 文档操作插入数据import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.apache.http.HttpHost;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.common.xcontent.XContentType;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexTest &#123; @Autowired private HotelService hotelService; private RestHighLevelClient client; @BeforeEach void initClient() &#123; this.client = new RestHighLevelClient(RestClient.builder( HttpHost.create(&quot;http://localhost:9200&quot;) // 若是集群，可指定多个地址如下 //HttpHost.create(&quot;http://localhost:9200&quot;), //HttpHost.create(&quot;http://localhost:9200&quot;) )); &#125; @AfterEach void destroyClient() &#123; try &#123; this.client.close(); &#125; catch (IOException e) &#123; log.error(&quot;关闭资源出错,&#123;&#125;&quot;, e.getMessage()); throw new RuntimeException(e); &#125; &#125; @Test void addIndexTest() &#123; // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083L); HotelDoc hotelDoc = new HotelDoc(hotel); // 1.准备request对象 IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotel.getId().toString()); // 2.准备json文档 request.source(JSON.toJSONString(hotelDoc), XContentType.JSON); // 3.发送请求 try &#123; client.index(request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class HotelDoc &#123; private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc(Hotel hotel) &#123; this.id = hotel.getId(); this.name = hotel.getName(); this.address = hotel.getAddress(); this.price = hotel.getPrice(); this.score = hotel.getScore(); this.brand = hotel.getBrand(); this.city = hotel.getCity(); this.starName = hotel.getStarName(); this.business = hotel.getBusiness(); this.location = hotel.getLatitude() + &quot;,&quot; + hotel.getLongitude(); this.pic = hotel.getPic(); &#125;&#125; 这里运行报错了，不过不影响，插入数据已经成功kibana使用GET /hotel/_doc/61083查询 参考博客查看日志打印，发现es版本&gt;8 推介查看博客 添加依赖和配置 &lt;dependency&gt; &lt;groupId&gt;co.elastic.clients&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-java&lt;/artifactId&gt; &lt;version&gt;8.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.json&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt; spring: es: address: localhost port: 9200 scheme: http username: elastic password: 123456 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.json.jackson.JacksonJsonpMapper;import co.elastic.clients.transport.ElasticsearchTransport;import co.elastic.clients.transport.rest_client.RestClientTransport;import org.apache.http.HttpHost;import org.apache.http.auth.AuthScope;import org.apache.http.auth.UsernamePasswordCredentials;import org.apache.http.client.CredentialsProvider;import org.apache.http.impl.client.BasicCredentialsProvider;import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ElasticSearchConfig &#123; @Value(&quot;$&#123;spring.es.address&#125;&quot;) String address; @Value(&quot;$&#123;spring.es.port&#125;&quot;) Integer port; @Value(&quot;$&#123;spring.es.scheme&#125;&quot;) String scheme; @Value(&quot;$&#123;spring.es.username&#125;&quot;) String username; @Value(&quot;$&#123;spring.es.password&#125;&quot;) String password; @Bean public ElasticsearchClient esRestClientWithCred()&#123; final CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); // 配置连接ES的用户名和密码，如果没有用户名和密码可以不加这一行 credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password)); RestClientBuilder restClientBuilder = RestClient.builder(new HttpHost(address, port, scheme)) .setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() &#123; @Override public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpAsyncClientBuilder) &#123; return httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider); &#125; &#125;); RestClient restClient = restClientBuilder.build(); ElasticsearchTransport transport = new RestClientTransport( restClient, new JacksonJsonpMapper()); return new ElasticsearchClient(transport); &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void addIndexTest() &#123; // 创建要插入的实体 // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 方法一 IndexRequest&lt;Object&gt; indexRequest = new IndexRequest.Builder&lt;&gt;() // 博客中并未添加这句话，需要自己指定id，否则 GET /hotel/_doc/61083 在kibana中无法查询到相关数据 .id(hotel.getId().toString()) .index(&quot;hotel&quot;) .document(hotelDoc) .build(); try &#123; client.index(indexRequest); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 在上述代码中遇到过一个问题正常运行结束，但是在kibana中无法查询到数据 是因为没有手动指定id，具体查看上述代码注释 采用lambda表达式的写法 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void addIndexTest2() &#123; // 创建要插入的实体 // hotel对象与索引库不符，经纬度是分开的两个字段，索引库则是一个字段 // 所以新建一个HotelDoc类与索引库对应 Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 方法二 try &#123; client.index(item -&gt; item .id(hotel.getId().toString()) .index(&quot;hotel&quot;) .document(hotelDoc)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 查询数据import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 获取索引 */ @Test void getIndexTest()&#123; String id = &quot;61083&quot;; GetResponse&lt;HotelDoc&gt; response = null; try &#123; response = client.get(g -&gt; g .index(&quot;hotel&quot;) .id(id), HotelDoc.class ); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; if (response.found()) &#123; HotelDoc hotelDoc = response.source(); log.info(&quot;返回结果 &quot; + JSON.toJSONString(hotelDoc)); &#125; else &#123; log.info(&quot;数据不存在&quot;); &#125; &#125;&#125; 修改数据import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void updateIndexTest() &#123; Hotel hotel = hotelService.getById(61083); HotelDoc hotelDoc = new HotelDoc(hotel); // 将城市从“上海”变为“不在上海” hotelDoc.setCity(&quot;不在上海&quot;); try &#123; client.update(item -&gt; item .index(&quot;hotel&quot;) .doc(hotelDoc) .id(hotel.getId().toString()), HotelDoc.class ); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 删除数据import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 删除索引测试 */ @Test void deleteIndexTest() &#123; Hotel hotel = hotelService.getById(61083); try &#123; client.delete(item -&gt; item .id(hotel.getId().toString()) .index(&quot;hotel&quot;)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 批量导入数据 利用JavaRestClient批量导入酒店数据到ES需求:批量查询酒店数据，然后批量导入索引库中 思路: 利用mybatis-plus查询酒店数据 将查询到的酒店数据(Hotel) 转换为文档类型数据( HotelDoc ) 利用JavaRestClient中 的Bulk批处理，实现批量新增文档 黑马程序员里的写法如上图所示但是由于我在windows安装的elasticsearch的版本问题，所以采用如下写法 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.BulkRequest;import co.elastic.clients.elasticsearch.core.GetResponse;import co.elastic.clients.elasticsearch.core.IndexRequest;import co.elastic.clients.elasticsearch.core.bulk.BulkOperation;import co.elastic.clients.elasticsearch.core.bulk.IndexOperation;import com.alibaba.fastjson.JSON;import com.example.demo.domain.Hotel;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.ArrayList;import java.util.List;@Slf4j@SpringBootTestclass HotelIndexElasticTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; /** * 批量导入数据测试 */ @Test void bulkIndexListTest() &#123; // 1.创建Bulk请求 BulkRequest bulkRequest = null; List&lt;BulkOperation&gt; bulkOperations = new ArrayList&lt;&gt;(); for (Hotel hotel : hotelService.list()) &#123; HotelDoc hotelDoc = new HotelDoc(hotel); IndexOperation&lt;Object&gt; build = new IndexOperation.Builder&lt;&gt;() .id(hotelDoc.getId().toString()) .index(&quot;hotel&quot;) .document(hotelDoc).build(); bulkOperations.add(build._toBulkOperation()); &#125; // 2.添加要批量提交的请求 bulkRequest = new BulkRequest.Builder() .index(&quot;hotel&quot;) .operations(bulkOperations) .build(); System.out.printf(&quot;一共插入了%s条数据%n&quot;,bulkRequest.operations().size()); // 3.发起bulk请求 try &#123; client.bulk(bulkRequest); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 批量查询 GET /hotel/_search 文档总结文档操作的基本步骤 初始化RestHighLevelClient 创建XXXRequest。（XXX是Index、Get、Update、Delete） 准备参数（Index和Update时需要） 发送请求，调用RestHighLevelClient对象的xxx()方法（xxx是index、get、update、delete） 解析结果（get时需要） DSL查询及案例DSL查询语法基本语法# 查询所有GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 全文检索查询# match查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;all&quot;:&quot;外滩&quot; &#125; &#125;&#125; 如下查询与上面的查询效果一样，但是由于检索多个字段，效率更低推介使用上面的查询（copy_to） # multi_match查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;外滩如家&quot;, &quot;fields&quot;: [&quot;brand&quot;,&quot;name&quot;,&quot;business&quot;] &#125; &#125;&#125; 精确查询 精确匹配不会对输入的内容进行分词，必须完全一致假如:输入的是上海杭州，则查询结果为0 # term查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;city&quot;:&#123; &quot;value&quot;:&quot;上海&quot; &#125; &#125; &#125;&#125; 价格大于等于100，小于等于300gt为大于，gte为大于等于；lte和lt同理 # range查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; &quot;price&quot;: &#123; &quot;gte&quot;: 100, &quot;lte&quot;: 300 &#125; &#125; &#125;&#125; 地理查询 查询在一个矩形范围内的地点top_left(左上角)和bottom_right(右下角)分别确定一个点，两个点水平作两条直线得到的矩形范围 # geo_bounding_box查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;geo_bounding_box&quot;: &#123; &quot;location&quot;: &#123; &quot;top_left&quot;: &#123; &quot;lat&quot;: 31.1, &quot;lon&quot;: 121.5 &#125;, &quot;bottom_right&quot;: &#123; &quot;lat&quot;: 30.9, &quot;lon&quot;: 121.7 &#125; &#125; &#125; &#125;&#125; 查询距离一个点一定范围内的数据 # geo_distance查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;15km&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.21, &quot;lon&quot;: 121.5 &#125; &#125; &#125;&#125; 也可以使用下面这种写法 # geo_distance查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;15km&quot;, &quot;location&quot;: &quot;31.21,121.5&quot; &#125; &#125;&#125; Function score query 案例让“如家”这个品牌的酒店排名靠前一些 # 让“如家”这个品牌的酒店排名靠前一些# function score查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;all&quot;: &quot;如家&quot; &#125; &#125;, &quot;functions&quot;: [ &#123; &quot;filter&quot;:&#123; &quot;term&quot;:&#123; &quot;brand&quot;:&quot;如家&quot; &#125; &#125;, &quot;weight&quot;: 10 &#125; ], &quot;boost_mode&quot;: &quot;sum&quot; &#125; &#125;&#125; 复合查询Boolean Query 布尔查询是-个或多个查询子句的组合。子查询的组合方式有: must:必须匹配每个子查询，类似“与” should:选择性匹配子查询，类似“或” must_ not:必须不匹配，不参与算分，类似“非” filter:必须匹配，不参与算分 # city在上海、brand是“皇冠假日”和“华美达”中的一个、price不能小于等于500、score大于等于45GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;term&quot;: &#123; &quot;city&quot;: &#123; &quot;value&quot;: &quot;上海&quot; &#125; &#125; &#125; ], &quot;should&quot;: [ &#123; &quot;term&quot;: &#123; &quot;brand&quot;: &#123; &quot;value&quot;: &quot;皇冠假日&quot; &#125; &#125; &#125;, &#123; &quot;term&quot;: &#123; &quot;brand&quot;: &#123; &quot;value&quot;: &quot;华美达&quot; &#125; &#125; &#125; ], &quot;must_not&quot;: [ &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 500 &#125; &#125; &#125;, &#123; &quot;range&quot;: &#123; &quot;score&quot;: &#123; &quot;gte&quot;: 45 &#125; &#125; &#125; ] &#125; &#125;&#125; 案例练习需求：搜索名字包含如家，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店 # 搜索名字包含`如家`，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;如家&quot; &#125; &#125; ], &quot;must_not&quot;: [ &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gt&quot;: 400 &#125; &#125; &#125; ], &quot;filter&quot;: [ &#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;10km&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.21, &quot;lon&quot;: 121.5 &#125; &#125; &#125; ] &#125; &#125;&#125; 搜索结果处理排序# 排序，排序字段和排序方式 asc、descGET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;price&quot;:&quot;asc&quot; &#125;&#125; 地理位置排序 # 排序，排序字段和排序方式 asc、descGET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;_geo_distance&quot;:&#123; &quot;location&quot;:&#123; &quot;lat&quot;: 31.21, &quot;lon&quot;: 121.5 &#125;, &quot;order&quot;:&quot;asc&quot;, &quot;unit&quot;:&quot;km&quot; &#125; &#125;&#125; 也可以采用如下写法 # 排序，排序字段和排序方式 asc、descGET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;_geo_distance&quot;:&#123; &quot;location&quot;:&quot;31.21,121.5&quot;, &quot;order&quot;:&quot;asc&quot;, &quot;unit&quot;:&quot;km&quot; &#125; &#125;&#125; 案例：对酒店数据按照用户评价降序排序，评价相同的按照价格升序排序 # 对酒店数据按照用户评价降序排序，评价相同的按照价格升序排序GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:[ &#123; &quot;score&quot;:&quot;desc&quot; &#125;, &#123; &quot;price&quot;:&quot;asc&quot; &#125; ]&#125; 案例：实现对酒店数据按照位置坐标的距离升序排序 # 实现对酒店数据按照位置坐标的距离升序排序GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;_geo_distance&quot;:&#123; &quot;location&quot;:&quot;31.21,121.5&quot;, &quot;order&quot;:&quot;asc&quot;, &quot;unit&quot;:&quot;km&quot; &#125; &#125;&#125;# 或者采用如下地理位置写法# 实现对酒店数据按照位置坐标的距离升序排序GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:&#123; &quot;_geo_distance&quot;:&#123; &quot;location&quot;:&#123; &quot;lat&quot;:31.21, &quot;lon&quot;:121.5 &#125;, &quot;order&quot;:&quot;asc&quot;, &quot;unit&quot;:&quot;km&quot; &#125; &#125;&#125; 分页 elasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。 elasticsearch中通过修改from、size参 数来控制要返回的分页结果 # 分页查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;:[ &#123; &quot;price&quot;:&quot;asc&quot; &#125; ], &quot;from&quot;:0, &quot;size&quot;:5&#125; 深度分页问题ES是分布式的，所以会面临深度分页问题。例如按price排序后，获取from &#x3D; 990，size &#x3D;10的数据: 如果希望查找前1000条数据，正确的做法是取每个片上的前1000条数据，然后将这些数据重新排序 首先在每个数据分片.上都排序并查询前1000条文档。 然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档 最后从这1000条中，选取从990开始的10条文档 注意：如果搜索页数过深，或者结果集(from + size)越大，对内存和CPU的消耗也越高。因此ES设定结果集查询的.上限是10000 针对深度分页，ES提供了两种解决方案,官方文档: search after:分页时需要排序，原理是从上一-次的排序值开始，查询下一页数据。官方推荐使用的方式。 scroll:原理将排序数据形成快照，保存在内存。官方已经不推荐使用。from + size:优点:支持随机翻页缺点:深度分页问题，默认查询上限(from + size)是10000场景:百度、京东、谷歌、淘宝这样的随机翻页搜索after search:优点:没有查询上限(单次查询的size不超过10000 )缺点:只能向后逐页查询，不支持随机翻页场景:没有随机翻页需求的搜索，例如手机向下滚动翻页scroll:优点:没有查询.上限(单次查询的size不超过10000)缺点:会有额外内存消耗，并且搜索结果是非实时的场景:海量数据的获取和迁移。从ES7.1开始不推荐，建议用aftersearch方案 高亮# 高亮查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;all&quot;: &quot;如家&quot; &#125; &#125;, &quot;highlight&quot;:&#123; // 指定要高亮的字段 &quot;fields&quot;: &#123; &quot;all&quot;: &#123; // 用来标记高亮字段的前置标签 &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;, // 用来标记高亮字段的后置标签 &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; &#125; &#125; &#125;&#125; 注意这里不能使用match_all，因为需要指定搜索的关键字同时，默认情况下 ES搜索字段必须与高亮字段一致，上述案例中都是all，请看下面案例 # 高亮查询GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;all&quot;: &quot;如家&quot; &#125; &#125;, &quot;highlight&quot;:&#123; // 指定要高亮的字段 &quot;fields&quot;: &#123; &quot;name&quot;: &#123; // 搜索字段和高亮字段可以不匹配 &quot;require_field_match&quot;: &quot;false&quot;, // 用来标记高亮字段的前置标签 &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;, // 用来标记高亮字段的后置标签 &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; &#125; &#125; &#125;&#125; RestClient查询match_allimport co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void matchAllTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(q -&gt; q.matchAll(matchAllQuery -&gt; matchAllQuery)) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); log.info(&quot;共搜索到:&#123;&#125;条数据&quot;, (matchSearch.hits().total() == null ? 0 : matchSearch.hits().total().value())); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; matchimport co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void matchTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(query-&gt;query.match( matchQuery-&gt;matchQuery.field(&quot;brand&quot;).query(&quot;如家&quot;) )) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; termimport co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void termQueryTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(query -&gt; query.term( termQuery -&gt; termQuery.field(&quot;city&quot;).value(&quot;北京&quot;) )) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; rangeimport co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void termQueryTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(query -&gt; query.range( rangeQuery-&gt;rangeQuery .field(&quot;price&quot;) .gte(JsonData.of(100)).lte(JsonData.of(300)) )) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; bool 搜索名字包含如家，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店（案例在之前boolean query部分出现过） # 搜索名字包含`如家`，价格不高于400，在坐标31.21、121.5周围10km范围内的酒店GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;如家&quot; &#125; &#125; ], &quot;must_not&quot;: [ &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;gt&quot;: 400 &#125; &#125; &#125; ], &quot;filter&quot;: [ &#123; &quot;geo_distance&quot;: &#123; &quot;distance&quot;: &quot;10km&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: 31.21, &quot;lon&quot;: 121.5 &#125; &#125; &#125; ] &#125; &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import com.example.demo.domain.HotelDoc;import com.example.demo.service.HotelService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired private HotelService hotelService; @Autowired ElasticsearchClient client; @Test void boolQueryTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(query -&gt; query.bool( boolQuery -&gt; boolQuery .must(mustQuery -&gt; mustQuery .match(matchQuery -&gt; matchQuery .field(&quot;name&quot;).query(&quot;如家&quot;)) ) .mustNot(mustNotQuery -&gt; mustNotQuery .range(rangeQuery -&gt; rangeQuery .field(&quot;price&quot;) .gt(JsonData.of(400)) ) ) .filter(filterQuery -&gt; filterQuery .geoDistance(geoDistanceQuery -&gt; geoDistanceQuery .distance(&quot;10km&quot;) .field(&quot;location&quot;) .location(geoLocation -&gt; geoLocation .latlon(new LatLonGeoLocation.Builder() .lat(31.21) .lon(121.5) .build() ) ) ) ) )) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125; &#125; 也可以使用下面的写法注意：QueryBuilders的包别导错了 import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.LatLonGeoLocation;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.json.JsonData;import com.example.demo.domain.HotelDoc;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired ElasticsearchClient client; @Test void boolQueryTest() throws IOException &#123; BoolQuery build = new BoolQuery.Builder() .must(QueryBuilders.term().field(&quot;name&quot;).value(&quot;如家&quot;).build()._toQuery()) .mustNot(QueryBuilders.range().field(&quot;price&quot;).gt(JsonData.of(400)).build()._toQuery()) .filter(QueryBuilders.geoDistance().field(&quot;location&quot;) .distance(&quot;10km&quot;) .location(item -&gt; item.latlon(new LatLonGeoLocation.Builder().lat(31.21).lon(121.5).build())) .build()._toQuery()) .build(); SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(build._toQuery()) .build(); SearchResponse&lt;HotelDoc&gt; matchSearch = client.search(request, HotelDoc.class); matchSearch.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; fuzzy 模糊查询（fuzzy query）是一种搜索技术，它允许在搜索时使用模糊匹配，以便在搜索结果中包含与搜索词项相似但不完全匹配的项。模糊查询通常用于处理拼写错误、同义词、缩写词、音近字等情况。在实现模糊查询时，常用的算法包括编辑距离算法、n-gram算法、Soundex算法等。在搜索引擎、数据库、信息检索等领域中，模糊查询是一种常见的技术手段。 GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;fuzzy&quot;: &#123; &quot;brand&quot;: &#123; &quot;fuzziness&quot;: &quot;2&quot;, &quot;value&quot;: &quot;儒家&quot; &#125; &#125; &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.LatLonGeoLocation;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.json.JsonData;import com.example.demo.domain.HotelDoc;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired ElasticsearchClient client; @Test void fuzzyQueryTest() throws IOException &#123; SearchResponse&lt;HotelDoc&gt; request = client.search(searchRequest -&gt; searchRequest .index(&quot;hotel&quot;) .query(query -&gt; query .fuzzy(fuzzyQuery -&gt; fuzzyQuery .field(&quot;brand&quot;) .fuzziness(&quot;auto&quot;) .value(&quot;儒家&quot;) ) ), HotelDoc.class); log.info(&quot;共搜索到:&#123;&#125;条数据&quot;, (request.hits().total() == null ? 0 : request.hits().total().value())); request.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; 排序和分页import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.LatLonGeoLocation;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.json.JsonData;import com.example.demo.domain.HotelDoc;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired ElasticsearchClient client; /** * 分页、排序测试 */ @Test void pageAndSortTest() throws IOException &#123; // 页码、每页信息条数 int page = 1, size = 10; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(builder -&gt; builder.match(matchAllQuery -&gt; matchAllQuery.field(&quot;brand&quot;).query(&quot;如家&quot;))) .from((page - 1) * size) .size(size) .sort(sortOptions -&gt; sortOptions.field(fieldSort -&gt; fieldSort.field(&quot;price&quot;).order(SortOrder.Asc))) .build(); SearchResponse&lt;HotelDoc&gt; search = client.search(request, HotelDoc.class); log.info(&quot;共搜索到:&#123;&#125;条数据&quot;, (search.hits().total() == null ? 0 : search.hits().total().value())); search.hits().hits().forEach(item -&gt; &#123; System.out.println(item.source()); &#125;); &#125;&#125; 高亮 总体来说不算太难，对应sql语句使用idea的提示基本就可以凑出来 GET /hotel/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;all&quot;: &quot;如家&quot; &#125; &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;: &#123; &quot;name&quot;: &#123; &quot;require_field_match&quot;: &quot;false&quot;, &quot;pre_tags&quot;:&quot;&lt;em&gt;&quot;, &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; &#125; &#125; &#125;&#125; import co.elastic.clients.elasticsearch.ElasticsearchClient;import co.elastic.clients.elasticsearch._types.LatLonGeoLocation;import co.elastic.clients.elasticsearch._types.SortOrder;import co.elastic.clients.elasticsearch._types.query_dsl.BoolQuery;import co.elastic.clients.elasticsearch._types.query_dsl.QueryBuilders;import co.elastic.clients.elasticsearch.core.SearchRequest;import co.elastic.clients.elasticsearch.core.SearchResponse;import co.elastic.clients.json.JsonData;import com.example.demo.domain.HotelDoc;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;@Slf4j@SpringBootTestclass HotelSearchTest &#123; @Autowired ElasticsearchClient client; /** * 高亮测试 */ @Test void highLightTest() throws IOException &#123; SearchRequest request = new SearchRequest.Builder() .index(&quot;hotel&quot;) .query(query-&gt;query.match(matchQuery-&gt;matchQuery.field(&quot;all&quot;).query(&quot;如家&quot;))) .highlight(highLight-&gt;highLight.fields(&quot;name&quot;,builder -&gt; builder.preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)).requireFieldMatch(false)) .build(); SearchResponse&lt;HotelDoc&gt; search = client.search(request, HotelDoc.class); log.info(&quot;共搜索到:&#123;&#125;条数据&quot;, (search.hits().total() == null ? 0 : search.hits().total().value())); search.hits().hits().forEach(item -&gt; &#123; item.highlight().values().forEach(System.out::println); &#125;); &#125;&#125;","categories":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/categories/elasticsearch/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/tags/elasticsearch/"}]},{"title":"PO、VO、DAO、BO、DTO、POJO","slug":"实用小技巧/编程/PO、VO、DAO、BO、DTO、POJO/PO、VO、DAO、BO、DTO、POJO","date":"2023-05-27T16:00:00.000Z","updated":"2024-06-01T14:12:24.842Z","comments":true,"path":"/shi-yong-xiao-ji-qiao/bian-cheng/po-vo-dao-bo-dto-pojo/po-vo-dao-bo-dto-pojo.html","link":"","permalink":"https://isunderachiever.github.io/shi-yong-xiao-ji-qiao/bian-cheng/po-vo-dao-bo-dto-pojo/po-vo-dao-bo-dto-pojo.html","excerpt":"","text":"PO、VO、DAO、BO、DTO、POJO 《阿里巴巴Java开发规范》关于领域模型的部分介绍如下分层领域模型规约: DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。 BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。 AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。 VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。领域模型命名规约： 数据对象：xxxDO，xxx即为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 展示对象：xxxVO，xxx一般为网页名称。 POJO是DO&#x2F;DTO&#x2F;BO&#x2F;VO的统称，禁止命名成xxxPOJO。 一、PO :(persistant object )，持久对象可以看成是与数据库中的表相映射的java对象。使用Hibernate来生成PO是不错的选择。二、VO :(value object) ，值对象通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要。PO只能用在数据层，VO用在商业逻辑层和表示层。各层操作属于该层自己的数据对象，这样就可以降低各层之间的耦合，便于以后系统的维护和扩展。三、DAO :(Data Access Objects) ，数据访问对象接口DAO是Data Access Object数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。J2EE开发人员使用数据访问对象（DAO）设计模式把底层的数据访问逻辑和高层的商务逻辑分开.实现DAO模式能够更加专注于编写数据访问代码。DAO模式是标准的J2EE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的商务逻辑分开.一个典型的DAO实现有下列几个组件： 一个DAO工厂类； 一个DAO接口； 一个实现DAO接口的具体类； 数据传递对象（有些时候叫做值对象）。具体的DAO类包含了从特定的数据源访问数据的逻辑。 四、BO :(Business Object)，业务对象层表示应用程序领域内“事物”的所有实体类。这些实体类驻留在服务器上，并利用服务类来协助完成它们的职责。五、DTO Data Transfer Object数据传输对象主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO六、POJO :(Plain Old Java Objects)，简单的Java对象实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接.其中有一些属性及其getter、setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用。当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。","categories":[{"name":"实用小技巧 ","slug":"实用小技巧","permalink":"https://isunderachiever.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"PO、VO、DAO、BO、DTO、POJO ","slug":"PO、VO、DAO、BO、DTO、POJO","permalink":"https://isunderachiever.github.io/tags/PO%E3%80%81VO%E3%80%81DAO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO/"}]},{"title":"map与实体互相转换","slug":"实用小技巧/编程/Map与实体转换/Map与实体转换","date":"2023-05-27T16:00:00.000Z","updated":"2024-06-01T14:12:24.841Z","comments":true,"path":"/shi-yong-xiao-ji-qiao/bian-cheng/map-yu-shi-ti-zhuan-huan/map-yu-shi-ti-zhuan-huan.html","link":"","permalink":"https://isunderachiever.github.io/shi-yong-xiao-ji-qiao/bian-cheng/map-yu-shi-ti-zhuan-huan/map-yu-shi-ti-zhuan-huan.html","excerpt":"","text":"map与实体转换 以下工具类请查看此博客 import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class MapAndEntityConverter &#123; /** * 利用反射将map集合封装成bean对象 * * @param map * @param clazz * @return &#123;@link T&#125; * @throws Exception 异常 */ public static &lt;T&gt; T mapToBean(Map&lt;String, Object&gt; map, Class&lt;?&gt; clazz) throws Exception &#123; Object obj = clazz.newInstance(); if (map != null &amp;&amp; !map.isEmpty() &amp;&amp; map.size() &gt; 0) &#123; // map.entrySet():获取到Map集合中所有的键值对对象的集合(Set集合) for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; // 属性名 String propertyName = entry.getKey(); // 属性值 Object value = entry.getValue(); String setMethodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); //获取和map的key匹配的属性名称 Field field = getClassField(clazz, propertyName); if (field == null) &#123; continue; &#125; Class&lt;?&gt; fieldTypeClass = field.getType(); value = convertValType(value, fieldTypeClass); try &#123; clazz.getMethod(setMethodName, field.getType()).invoke(obj, value); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return (T) obj; &#125; /** * 根据给定对象类匹配对象中的特定字段 * * @param clazz clazz * @param fieldName 字段名 * @return &#123;@link Field&#125; */ private static Field getClassField(Class&lt;?&gt; clazz, String fieldName) &#123; if (Object.class.getName().equals(clazz.getName())) &#123; return null; &#125; Field[] declaredFields = clazz.getDeclaredFields(); for (Field field : declaredFields) &#123; if (field.getName().equals(fieldName)) &#123; return field; &#125; &#125; //如果该类还有父类，将父类对象中的字段也取出 Class&lt;?&gt; superClass = clazz.getSuperclass(); //递归获取 if (superClass != null) &#123; return getClassField(superClass, fieldName); &#125; return null; &#125; /** * 将map的value值转为实体类中字段类型匹配的方法 * * @param value * @param fieldTypeClass * @return &#123;@link Object&#125; */ private static Object convertValType(Object value, Class&lt;?&gt; fieldTypeClass) &#123; Object retVal = null; if (Long.class.getName().equals(fieldTypeClass.getName()) || long.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Long.parseLong(value.toString()); &#125; else if (Integer.class.getName().equals(fieldTypeClass.getName()) || int.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Integer.parseInt(value.toString()); &#125; else if (Float.class.getName().equals(fieldTypeClass.getName()) || float.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Float.parseFloat(value.toString()); &#125; else if (Double.class.getName().equals(fieldTypeClass.getName()) || double.class.getName().equals(fieldTypeClass.getName())) &#123; retVal = Double.parseDouble(value.toString()); &#125; else &#123; retVal = value; &#125; return retVal; &#125; /** * 对象转map * * @param obj obj * @return &#123;@link Map&#125;&lt;&#123;@link String&#125;, &#123;@link Object&#125;&gt; */ public static Map&lt;String, Object&gt; objToMap(Object obj) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); // 获取f对象对应类中的所有属性域 Field[] fields = obj.getClass().getDeclaredFields(); for (int i = 0, len = fields.length; i &lt; len; i++) &#123; String varName = fields[i].getName(); // 将key置为小写，默认为对象的属性 varName = varName.toLowerCase(); try &#123; // 获取原来的访问控制权限 boolean accessFlag = fields[i].isAccessible(); // 修改访问控制权限 fields[i].setAccessible(true); // 获取在对象f中属性fields[i]对应的对象中的变量 Object o = fields[i].get(obj); if (o != null) &#123; map.put(varName, o.toString()); &#125; // 恢复访问控制权限 fields[i].setAccessible(accessFlag); &#125; catch (IllegalArgumentException | IllegalAccessException ex) &#123; ex.printStackTrace(); &#125; &#125; return map; &#125;&#125; 编写测试类 import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class UserToMap &#123; private Long id; private String name; private String gender;&#125; import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.util.HashMap;import java.util.Map;@Slf4j@SpringBootTestclass DemoApplicationTests &#123; @Test void contextLoads() &#123; &#125; /** * 实体转map测试 */ @Test void entityToMapTest() &#123; UserToMap userToMap = new UserToMap(1L, &quot;马小跳&quot;, &quot;男&quot;); Map&lt;String, Object&gt; stringObjectMap = MapAndEntityConverter.objToMap(userToMap); System.out.println(stringObjectMap); &#125; /** * map转实体测试 */ @Test void mapToEntityTest() &#123; Map&lt;String, Object&gt; stringObjectMap = new HashMap&lt;&gt;(); stringObjectMap.put(&quot;id&quot;, 1L); stringObjectMap.put(&quot;name&quot;, &quot;马小跳&quot;); stringObjectMap.put(&quot;gender&quot;, &quot;男&quot;); UserToMap user = null; try &#123; user = MapAndEntityConverter.mapToBean(stringObjectMap, UserToMap.class); &#125; catch (Exception e) &#123; log.error(&quot;map转实体失败&quot;); throw new RuntimeException(e); &#125; System.out.println(user); &#125;&#125; 注意 有个需要注意lombok生成的class文件的get、set方法有可能会导致转换出错（博客楼主提供的工具类并未出错） 视频查看 视频中使用Jackson的ObjectMapper类实现map转entity entity有一个字段是lDate，而ObjectMapper的规定需要生成的get、set方法为getlDate、setlDate 但是lombok @Data注解生成的get、set方法为getLDate、setLDate 导致lDate转换后的值为空，同样的情况还出现在BeanUtils 解决方法就是手写（idea自动生成）get、set方法楼主这里采用的set方法和lombok一致 String setMethodName = &quot;set&quot; + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1); 有个需要注意的地方是entity转map，结果如下 &#123;uname=马小跳, gender=男, id=1&#125; 而entity属性名为uName","categories":[{"name":"map与实体互相转换","slug":"map与实体互相转换","permalink":"https://isunderachiever.github.io/categories/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"map与实体互相转换","slug":"map与实体互相转换","permalink":"https://isunderachiever.github.io/tags/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"}]},{"title":"apifox使用","slug":"系统配置/编程配置/apifox使用/apifox使用","date":"2023-05-24T16:00:00.000Z","updated":"2024-06-01T14:32:53.520Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/apifox-shi-yong/apifox-shi-yong.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/apifox-shi-yong/apifox-shi-yong.html","excerpt":"","text":"apifox使用 当请求跑通之后，可以保存为接口，生成api文档 新建接口 此时可以定义成功后的响应，也可以引用一下其他的数据模型新建BaseResponse接口引用数据模型同理可以把data也引用对应的实体类数据模型（user、book、order…） 自动生成测试数据","categories":[{"name":"apifox","slug":"apifox","permalink":"https://isunderachiever.github.io/categories/apifox/"}],"tags":[{"name":"apifox","slug":"apifox","permalink":"https://isunderachiever.github.io/tags/apifox/"}]},{"title":"vue3 & typescript学习","slug":"编程语言/Vue/Vue3/Vue3+Typescript","date":"2023-04-30T03:00:00.000Z","updated":"2024-06-01T14:12:25.026Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-typescript.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-typescript.html","excerpt":"","text":"vue3 &amp; typescript学习 学习文档 我这个已经安装过Element-plus了 初识语法类型注解&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;user.name&#125;&#125;&lt;/h3&gt; &lt;hr&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testGreeter&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import &#123;defineComponent, reactive&#125; from &#x27;vue&#x27;; export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; // 1.类型注解 const greeter = (person: string) =&gt; &#123; return &#x27;Hello,&#x27; + person &#125; const user = reactive(&#123; name: &quot;张三&quot;, age: 25 &#125;); function testGreeter() &#123; user.name = greeter(user.name); &#125; return &#123; testGreeter, user &#125; &#125; &#125;)&lt;/script&gt; 接口&lt;template&gt; &lt;div&gt; &lt;el-input v-model=&quot;input&quot; placeholder=&quot;Please input&quot;/&gt; &lt;hr&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testGreeter&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;; // 2.接口 interface UserInfo &#123; firstName: string; lastName: string; &#125; export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; const greeter = (user: UserInfo) =&gt; &#123; return &#x27;Hello,&#x27; + user.firstName + &#x27;_&#x27; + user.lastName &#125; const user = reactive(&#123; firstName: &quot;南宫&quot;, lastName: &quot;问天&quot; &#125;); let input = ref(); function testGreeter() &#123; input.value = greeter(user); &#125; return &#123; testGreeter, input &#125; &#125; &#125;)&lt;/script&gt; 类&lt;template&gt; &lt;div&gt; &lt;el-input v-model=&quot;input&quot; placeholder=&quot;Please input&quot;/&gt; &lt;hr&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testGreeter&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;; // 3.类 class User &#123; fullName: string; firstName: string; lastName: string; constructor(firstName: string, lastName: string) &#123; this.firstName = firstName; this.lastName = lastName; this.fullName = firstName + &#x27;_&#x27; + lastName; &#125; &#125; interface UserInfo &#123; firstName: string; lastName: string; &#125; export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; const greeter = (user: UserInfo) =&gt; &#123; return &#x27;Hello,&#x27; + user.firstName + &#x27;_&#x27; + user.lastName &#125; const obj = new User(&#x27;南宫&#x27;, &#x27;问天&#x27;); const user = reactive(obj); let input = ref(); function testGreeter() &#123; input.value = greeter(user); &#125; return &#123; testGreeter, input &#125; &#125; &#125;)&lt;/script&gt; 常用语法 查看原文档 基础类型布尔值let isDone: boolean = false;isDone = true;// isDone = 2 // error 数字let a1: number = 10 // 十进制let a2: number = 0b1010 // 二进制let a3: number = 0o12 // 八进制let a4: number = 0xa // 十六进制 字符串let name:string = &#x27;tom&#x27;name = &#x27;jack&#x27;// name = 12 // errorlet age:number = 12const info = `My name is $&#123;name&#125;, I am $&#123;age&#125; years old!` undefined &amp; nulllet u: undefined = undefinedlet n: null = null 数组let list1: number[] = [1, 2, 3] 数组泛型 let list2: Array&lt;number&gt; = [1, 2, 3] 元组 tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 let t1: [string, number]t1 = [&#x27;hello&#x27;, 10] // OKt1 = [10, &#x27;hello&#x27;] // Error 枚举enum 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。 enum Color &#123; Red, Green, Blue&#125;// 枚举数值默认从0开始依次递增// 根据特定的名称得到对应的枚举数值let myColor: Color = Color.Green // 0console.log(myColor, Color.Red, Color.Blue)// 输出:1 0 2 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green 或者，全部都采用手动赋值： enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字： enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]console.log(colorName) // &#x27;Green&#x27; 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： let notSure: any = 4notSure = &#x27;maybe a string&#x27;notSure = false // 也可以是个 boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, &#x27;free&#x27;]list[1] = 100 void某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： /* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */function fn(): void &#123; console.log(&#x27;fn()&#x27;) // return undefined // return null // return 1 // error&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null： let unusable: void = undefined objectobject 表示非原始类型，也就是除 number，string，boolean之外的类型。使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如： function fn2(obj:object):object &#123; console.log(&#x27;fn2()&#x27;, obj) return &#123;&#125; // return undefined // return null&#125;console.log(fn2(new String(&#x27;abc&#x27;)))// console.log(fn2(&#x27;abc&#x27;) // errorconsole.log(fn2(String)) 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值 function toString2(x: number | string) : string &#123; return x.toString()&#125; 需求2: 定义一个一个函数得到一个数字或字符串值的长度 function getLength(x: number | string) &#123; // return x.length // error if (x.length) &#123; // error return x.length &#125; else &#123; return x.toString().length &#125;&#125; 类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法 /* 类型断言(Type Assertion): 可以用来手动指定一个值的类型语法: 方式一: &lt;类型&gt;值 方式二: 值 as 类型 tsx中只能用这种方式*//* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */function getLength(x: number | string) &#123; if ((&lt;string&gt;x).length) &#123; return (x as string).length &#125; else &#123; return x.toString().length &#125;&#125;console.log(getLength(&#x27;abcd&#x27;), getLength(1234)) 类型推断类型推断: TS会在没有明确的指定类型的时候推测出一个类型有下面2种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为any类型 /* 定义变量时赋值了, 推断为对应的类型 */let b9 = 123 // number// b9 = &#x27;abc&#x27; // error/* 定义变量时没有赋值, 推断为any类型 */let b10 // any类型b10 = 123b10 = &#x27;abc&#x27; 接口简单用法&lt;template&gt; &lt;div&gt; &lt;span&gt;次数:&#123;&#123;num&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;el-button @click=&quot;test&quot;&gt;点击&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;interface UserForm&#123; // 只读属性 readonly name:string, age:number&#125;interface Alarm&#123; alert(): any;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm &#123; alert() &#123; console.log(&#x27;Car alert&#x27;); &#125;&#125;export default defineComponent(&#123; name: &#x27;&#x27;, setup() &#123; let num=ref&lt;number&gt;(0); const test=()=&gt;&#123; num.value++; const car=new Car() car.alert(); &#125; return &#123; test, num &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 类实现接口/* 类类型: 实现接口1. 一个类可以实现多个接口2. 一个接口可以继承多个接口*/interface Alarm &#123; alert(): any;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm &#123; alert() &#123; console.log(&#x27;Car alert&#x27;); &#125;&#125; 一个类实现多个接口class Car2 implements Alarm, Light &#123; alert() &#123; console.log(&#x27;Car alert&#x27;); &#125; lightOn() &#123; console.log(&#x27;Car light on&#x27;); &#125; lightOff() &#123; console.log(&#x27;Car light off&#x27;); &#125;&#125; 接口继承接口interface LightableAlarm extends Alarm, Light &#123;&#125; 类修饰符当成员被标记成 private 时，它就不能在声明它的类的外部访问protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问 /* 访问修饰符: 用来描述类内部的属性/方法的可访问性 public: 默认值, 公开的外部也可以访问 private: 只能类内部可以访问 protected: 类内部和子类可以访问*/class Animal &#123; public name: string public constructor (name: string) &#123; this.name = name &#125; public run (distance: number=0) &#123; console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`) &#125;&#125;class Person extends Animal &#123; private age: number = 18 protected sex: string = &#x27;男&#x27; run (distance: number=5) &#123; console.log(&#x27;Person jumping...&#x27;) super.run(distance) &#125;&#125;class Student extends Person &#123; run (distance: number=6) &#123; console.log(&#x27;Student jumping...&#x27;) console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // 子类看不到父类中私有的成员 super.run(distance) &#125;&#125;console.log(new Person(&#x27;abc&#x27;).name) // 公开的可见// console.log(new Person(&#x27;abc&#x27;).sex) // 受保护的不可见// console.log(new Person(&#x27;abc&#x27;).age) // 私有的不可见 静态属性/* 静态属性, 是类对象的属性非静态属性, 是类的实例对象的属性*/class Person &#123; name1: string = &#x27;A&#x27; static name2: string = &#x27;B&#x27;&#125;console.log(Person.name2)console.log(new Person().name1) 抽象类/* 抽象类 不能创建实例对象, 只有实现类才能创建实例 可以包含未实现的抽象方法*/abstract class Animal &#123; abstract cry () run () &#123; console.log(&#x27;run()&#x27;) &#125;&#125;class Dog extends Animal &#123; cry () &#123; console.log(&#x27; Dog cry()&#x27;) &#125;&#125;const dog = new Dog()dog.cry()dog.run() 函数函数类型function add(x: number, y: number): number &#123; return x + y&#125;let myAdd = function(x: number, y: number): number &#123; return x + y&#125; 可选参数和默认参数 JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的 function buildName(firstName: string=&#x27;A&#x27;, lastName?: string): string &#123; if (lastName) &#123; return firstName + &#x27;-&#x27; + lastName &#125; else &#123; return firstName &#125;&#125;console.log(buildName(&#x27;C&#x27;, &#x27;D&#x27;))console.log(buildName(&#x27;C&#x27;))console.log(buildName()) 函数重载 typeof判断参数的类型 /* 函数重载: 函数名相同, 而形参不同的多个函数需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加 */// 重载函数声明function add (x: string, y: string): stringfunction add (x: number, y: number): number// 定义函数实现function add(x: string | number, y: string | number): string | number &#123; // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y if (typeof x === &#x27;string&#x27; &amp;&amp; typeof y === &#x27;string&#x27;) &#123; return x + y &#125; else if (typeof x === &#x27;number&#x27; &amp;&amp; typeof y === &#x27;number&#x27;) &#123; return x + y &#125;&#125;console.log(add(1, 2))console.log(add(&#x27;a&#x27;, &#x27;b&#x27;))// console.log(add(1, &#x27;a&#x27;)) // error 泛型 基本使用 function createArray(value: any, count: number): any[] &#123; const arr: any[] = [] for (let index = 0; index &lt; count; index++) &#123; arr.push(value) &#125; return arr&#125;const arr1 = createArray(11, 3)const arr2 = createArray(&#x27;aa&#x27;, 3)console.log(arr1[0].toFixed(), arr2[0].split(&#x27;&#x27;)) 函数泛型function createArray2 &lt;T&gt; (value: T, count: number) &#123; const arr: Array&lt;T&gt; = [] for (let index = 0; index &lt; count; index++) &#123; arr.push(value) &#125; return arr&#125;const arr3 = createArray2&lt;number&gt;(11, 3)console.log(arr3[0].toFixed())// console.log(arr3[0].split(&#x27;&#x27;)) // errorconst arr4 = createArray2&lt;string&gt;(&#x27;aa&#x27;, 3)console.log(arr4[0].split(&#x27;&#x27;))// console.log(arr4[0].toFixed()) // error 多个泛型参数的函数function swap &lt;K, V&gt; (a: K, b: V): [K, V] &#123; return [a, b]&#125;const result = swap&lt;string, number&gt;(&#x27;abc&#x27;, 123)console.log(result[0].length, result[1].toFixed()) 泛型接口interface IbaseCRUD &lt;T&gt; &#123; data: T[] add: (t: T) =&gt; void getById: (id: number) =&gt; T&#125;class User &#123; id?: number; //id主键自增 name: string; //姓名 age: number; //年龄 constructor (name, age) &#123; this.name = name this.age = age &#125;&#125;class UserCRUD implements IbaseCRUD &lt;User&gt; &#123; data: User[] = [] add(user: User): void &#123; user = &#123;...user, id: Date.now()&#125; this.data.push(user) console.log(&#x27;保存user&#x27;, user.id) &#125; getById(id: number): User &#123; return this.data.find(item =&gt; item.id===id) &#125;&#125;const userCRUD = new UserCRUD()userCRUD.add(new User(&#x27;tom&#x27;, 12))userCRUD.add(new User(&#x27;tom2&#x27;, 13))console.log(userCRUD.data) 泛型类class GenericNumber&lt;T&gt; &#123; zeroValue: T add: (x: T, y: T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;()myGenericNumber.zeroValue = 0myGenericNumber.add = function(x, y) &#123; return x + y &#125;let myGenericString = new GenericNumber&lt;string&gt;()myGenericString.zeroValue = &#x27;abc&#x27;myGenericString.add = function(x, y) &#123; return x + y&#125;console.log(myGenericString.add(myGenericString.zeroValue, &#x27;test&#x27;))console.log(myGenericNumber.add(myGenericNumber.zeroValue, 12)) 泛型约束如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性 // 没有泛型约束function fn &lt;T&gt;(x: T): void &#123; // console.log(x.length) // error&#125; 我们可以使用泛型约束来实现 interface Lengthwise &#123; length: number;&#125;// 指定泛型约束function fn2 &lt;T extends Lengthwise&gt;(x: T): void &#123; console.log(x.length)&#125; 我们需要传入符合约束类型的值，必须包含必须 length 属性： fn2(&#x27;abc&#x27;)// fn2(123) // error number没有length属性 vuexnpm install vuex --save-dev store&#x2F;index.ts import &#123; createStore &#125; from &#x27;vuex&#x27;export default createStore(&#123; state: &#123; &#125;, getters: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, modules: &#123; &#125;&#125;) main.ts import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(store)app.mount(&#x27;#app&#x27;) 在vue3中，vuex提供了一个useStore方法来获取全局的store没有什么比直接看官网更清楚了 访问 State 和 Getter 为了访问 state 和 getter，需要创建 computed 引用以保留响应性，这与在选项式 API 中创建计算属性等效。 import &#123;createStore&#125; from &#x27;vuex&#x27;export default createStore(&#123; state: &#123; count:0, &#125;, getters: &#123; double(state)&#123; return state.count; &#125; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, modules: &#123; &#125;, plugins:[ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testGreeter&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); let count = computed(() =&gt; &#123; return store.state.count; &#125;) let double = computed(() =&gt; &#123; return store.getters.double; &#125;) function testGreeter() &#123; console.log(&quot;count的值:&quot;,count.value); console.log(&quot;double的值:&quot;,double.value); &#125; return &#123; testGreeter, &#125; &#125;&#125;)&lt;/script&gt; 官网采用以下写法 &lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); return &#123; count: computed(() =&gt; store.state.count), double: computed(() =&gt; store.getters.double) &#125; &#125;&#125;)&lt;/script&gt; 访问 Mutation 和 Action 要使用 mutation 和 action 时，只需要在 setup 钩子函数中调用 commit 和 dispatch 函数 参考博客 import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedstate from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; count:0, &#125;, getters: &#123; &#125;, mutations: &#123; sum (state, num) &#123; state.count += num &#125; &#125;, actions: &#123; &#125;, modules: &#123; &#125;, plugins:[ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testVuex(10)&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); const testVuex=(num)=&gt;&#123; // 使用 store.commit(&#x27;mution中函数名&#x27;, &#x27;需要传递的参数&#x27; ) 在commit里添加参数的方式进行传递 store.commit(&#x27;sum&#x27;, num) console.log(store.state.count); &#125; return &#123; testVuex, &#125; &#125;&#125;)&lt;/script&gt; 也可以采用以下方式 import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedstate from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; count:0, &#125;, getters: &#123; &#125;, mutations: &#123; sum (state, payload) &#123; state.count += payload.num &#125; &#125;, actions: &#123; &#125;, modules: &#123; &#125;, plugins:[ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testVuex(10)&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); const testVuex=(num)=&gt;&#123; // 前面提到了 mution 主要包含 type 和 回调函数 两部分, 和通过commit payload的方式进行参数传递（提交）,下面我们可以用这种方式进行 mution 的提交 store.commit(&#123; type: &#x27;sum&#x27;, // 类型就是mution中定义的方法名称 num &#125;) console.log(store.state.count); &#125; return &#123; testVuex, &#125; &#125;&#125;)&lt;/script&gt; actions import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedstate from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; count:0, &#125;, getters: &#123; &#125;, mutations: &#123; sum (state, num) &#123; state.count += num &#125; &#125;, actions: &#123; // context 上下文对象，可以理解为store sum_actions (context, num) &#123; setTimeout(() =&gt; &#123; context.commit(&#x27;sum&#x27;, num) // 通过context去触发mutions中的sum &#125;, 1000) &#125; &#125;, modules: &#123; &#125;, plugins:[ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testVuex(10)&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); const testVuex=(num)=&gt;&#123; store.dispatch(&#x27;sum_actions&#x27;, num) console.log(store.state.count); &#125; return &#123; testVuex, &#125; &#125;&#125;)&lt;/script&gt; 通过 promise 实现异步操作完成，通知组件异步执行成功或是失败。 import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedstate from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; count: 0, &#125;, getters: &#123; &#125;, mutations: &#123; sum(state, num) &#123; state.count += num &#125; &#125;, actions: &#123; sum_actions(context, payload) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 通过 context 上下文对象拿到 count if (context.state.count &lt; 30) &#123; context.commit(&#x27;sum&#x27;, payload.num) resolve(&#x27;异步操作执行成功&#x27;) &#125; else &#123; reject(new Error(&#x27;异步操作执行错误&#x27;)) &#125; &#125;, 1000) &#125;) &#125; &#125;, modules: &#123;&#125;, plugins: [ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testVuex(10)&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); const testVuex=(num)=&gt;&#123; store.dispatch(&#x27;sum_actions&#x27;, &#123; num &#125;).then((res) =&gt; &#123; console.log(&quot;success:&quot;,res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) &#125; return &#123; testVuex, &#125; &#125;&#125;)&lt;/script&gt; getters import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedstate from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; users: [&#123; name: &quot;小美&quot;, age: 12 &#125;, &#123; name: &quot;小红&quot;, age: 22 &#125;, &#123; name: &quot;小明&quot;, age: 23 &#125;] &#125;, getters: &#123; filterUsersByAge(state) &#123; return state.users.filter(item =&gt; item.age &gt;= 20) &#125; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;, plugins: [ ]&#125;) &lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle @click=&quot;testVuex(10)&quot;/&gt; &lt;br&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123; store.getters.filterUsersByAge &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for=&quot;item in store.getters.filterUsersByAge&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; setup() &#123; const store = useStore(); const testVuex = (num) =&gt; &#123; &#125; return &#123; testVuex, store &#125; &#125;&#125;)&lt;/script&gt; modules user.js export default &#123; namespaced: true, // 为每个模块添加一个前缀名，保证模块命明不冲突 // state中存放的就是全局共享的数据 // sessionStorage.getItem(&#x27;userState&#x27;)?JSON.parse(sessionStorage.getItem(&#x27;userState&#x27;)) state: null != window.sessionStorage.getItem(&#x27;state&#x27;) ? JSON.parse(sessionStorage.getItem(&#x27;state&#x27;)) : &#123; user: &#123; name: &quot;&quot;, age: null, gender: &quot;&quot; &#125; &#125;, // 取值的方法，计算属性 getters: &#123; getUser(state) &#123; return state.user; &#125; &#125;, // 可以修改state值的方法，同步阻塞 mutations: &#123; // 传入user对象，更新全局的user updateUser(state, user) &#123; state.user = user; &#125; &#125;, // 异步调用mutations方法 actions: &#123; asyncUpdateUser(context, user) &#123; context.commit(&#x27;updateUser&#x27;, user); &#125; &#125;&#125;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"vue3快速上手","slug":"编程语言/Vue/Vue3/Vue3速成","date":"2023-04-30T02:50:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-su-cheng.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-su-cheng.html","excerpt":"","text":"vue3快速上手vue create vue3-demo ElementPlusnpm install element-plus --save 完整引入 // main.tsimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;) 安装图标 npm install @element-plus/icons-vue 图标注册 // main.ts// 如果您正在使用CDN引入，请删除下面一行。import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125; 综合 // main.tsimport &#123;createApp&#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;const app = createApp(App)app.use(store)app.use(router)app.use(ElementPlus)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125;app.mount(&#x27;#app&#x27;) axios 安装axios 以下内容参考【程序员青戈】的博客 npm install axios -s utils&#x2F;request.js import axios from &#x27;axios&#x27;const request = axios.create(&#123; baseURL: &#x27;/api&#x27;, // 注意！！ 这里是全局统一加上了 &#x27;/api&#x27; 前缀，也就是说所有接口都会加上&#x27;/api&#x27;前缀在，页面里面写接口的时候就不要加 &#x27;/api&#x27;了，否则会出现2个&#x27;/api&#x27;，类似 &#x27;/api/api/user&#x27;这样的报错，切记！！！ timeout: 5000&#125;)// request 拦截器// 可以自请求发送前对请求做一些处理// 比如统一加token，对请求参数统一加密request.interceptors.request.use(config =&gt; &#123; config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=utf-8&#x27;; // config.headers[&#x27;token&#x27;] = user.token; // 设置请求头 return config&#125;, error =&gt; &#123; return Promise.reject(error)&#125;);// response 拦截器// 可以在接口响应后统一处理结果request.interceptors.response.use( response =&gt; &#123; let res = response.data; // 如果是返回的文件 if (response.config.responseType === &#x27;blob&#x27;) &#123; return res &#125; // 兼容服务端返回的字符串数据 if (typeof res === &#x27;string&#x27;) &#123; res = res ? JSON.parse(res) : res &#125; return res; &#125;, error =&gt; &#123; console.log(&#x27;err&#x27; + error) // for debug return Promise.reject(error) &#125;)export default request vue.config.js // 跨域配置module.exports = &#123; devServer: &#123; //记住，别写错了devServer//设置本地默认端口 选填 port: 10020, proxy: &#123; //设置代理，必须填 &#x27;/api&#x27;: &#123; //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: &#x27;http://localhost:10010&#x27;, //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: &#123; //路径重写 &#x27;^/api&#x27;: &#x27;&#x27; //选择忽略拦截器里面的内容 &#125; &#125; &#125; &#125;&#125; vuex 安装vuex（已安装，main.ts配置参考element plus处） npm install vuex --save-dev 安装持久化插件 npm i vuex-persistedstate 关闭严格模式 tsconfig.json里将&quot;strict&quot;: false设置为&quot;strict&quot;: truesotore&#x2F;modules&#x2F;userts export default &#123; namespaced: true, // 为每个模块添加一个前缀名，保证模块命明不冲突 // state中存放的就是全局共享的数据 // sessionStorage.getItem(&#x27;userState&#x27;)?JSON.parse(sessionStorage.getItem(&#x27;userState&#x27;)) state: null != window.sessionStorage.getItem(&#x27;state&#x27;) ? JSON.parse(sessionStorage.getItem(&#x27;state&#x27;)) : &#123; user: &#123; name: &quot;&quot;, age: null, gender: &quot;&quot; &#125; &#125;, // 取值的方法，计算属性 getters: &#123; getUser(state) &#123; return state.user; &#125; &#125;, // 可以修改state值的方法，同步阻塞 mutations: &#123; // 传入user对象，更新全局的user updateUser(state, user) &#123; state.user = user; &#125; &#125;, // 异步调用mutations方法 actions: &#123; asyncUpdateUser(context, user) &#123; context.commit(&#x27;updateUser&#x27;, user); &#125; &#125;&#125; store&#x2F;indexts import &#123;createStore&#125; from &#x27;vuex&#x27;import createPersistedState from &#x27;vuex-persistedstate&#x27;import user from &#x27;./modules/user&#x27;export default createStore(&#123; state: &#123; &#125;, getters: &#123; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123; user &#125;, plugins: [ // 配置vuex插件 // 使用模块提供的方法 createPersistedState(&#123; // 默认存储在localStorage 现改为sessionStorage storage: window.sessionStorage, // 本地存储数据的键名 // 配置存储持久化的key键名 key: &#x27;user&#x27;, // 指定需要存储的模块，如果是模块下具体的数据需要加上模块名称，如user.token // paths数组可以选择配置持久化的模块，不写代表所有 // paths: [&#x27;user&#x27;, &#x27;cart&#x27;] &#125;) ]&#125;) 测试页面 &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;el-button icon=&quot;Search&quot; circle @click=&quot;testVuex&quot; /&gt; &lt;br&gt; &lt;el-button type=&quot;success&quot; @click=&quot;clearDataFromVuex&quot;&gt;删除vuex内的数据&lt;/el-button&gt; &lt;br&gt; &lt;h3&gt;name:&#123;&#123; store.state.user.user.name &#125;&#125;&lt;/h3&gt; &lt;h3&gt;age:&#123;&#123; store.state.user.user.age &#125;&#125;&lt;/h3&gt; &lt;h3&gt;gender:&#123;&#123; store.state.user.user.gender &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;export default defineComponent(&#123; name: &#x27;HelloWorld&#x27;, props: &#123; msg: String, &#125;, setup() &#123; const store = useStore(); const testVuex = () =&gt; &#123; // 使用这种方式可以改变值，但是无法实现数据的持久化 // store.state.user.user.name=&#x27;假面骑士decade&#x27; // store.state.user.user.age=22 // store.state.user.user.gender=&#x27;男&#x27; // 下面两种方法可以实现vuex的数据持久化 // store.commit(&#x27;user/updateUser&#x27;,&#123; // name: &quot;Decade&quot;, // age: 22, // gender: &quot;男&quot; // &#125;); store.dispatch(&#x27;user/asyncUpdateUser&#x27;, &#123; name: &quot;假面骑士&quot;, age: 18, gender: &quot;女&quot; &#125;); &#125; const clearDataFromVuex=()=&gt;&#123; store.dispatch(&#x27;user/asyncUpdateUser&#x27;, &#123;&#125;); &#125;; return &#123; testVuex, clearDataFromVuex, store &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 简单集成ts &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;el-button icon=&quot;Search&quot; circle @click=&quot;testVuex&quot;/&gt; &lt;br&gt; &lt;el-button type=&quot;success&quot; @click=&quot;clearDataFromVuex&quot;&gt;删除vuex内的数据&lt;/el-button&gt; &lt;br&gt; &lt;h3&gt;name:&#123;&#123; store.state.user.user.name &#125;&#125;&lt;/h3&gt; &lt;h3&gt;age:&#123;&#123; store.state.user.user.age &#125;&#125;&lt;/h3&gt; &lt;h3&gt;gender:&#123;&#123; store.state.user.user.gender &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref, computed&#125; from &#x27;vue&#x27;;import &#123;useStore&#125; from &quot;vuex&quot;;interface userForm &#123; name: string, age: number, gender: string&#125;export default defineComponent(&#123; name: &#x27;HelloWorld&#x27;, props: &#123; msg: String, &#125;, setup() &#123; const store = useStore(); const testVuex = (user: userForm) =&gt; &#123; user = &#123; name: &quot;Decade&quot;, age: 22, gender: &quot;男&quot; &#125;; store.commit(&#x27;user/updateUser&#x27;, user); &#125; const clearDataFromVuex = () =&gt; &#123; store.dispatch(&#x27;user/asyncUpdateUser&#x27;, &#123;&#125;); &#125;; return &#123; testVuex, clearDataFromVuex, store &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; cookienpm install vue-cookies --save main.ts import &#123;createApp&#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;import &#x27;@/assets/css/global.css&#x27;import VueCookies from &#x27;vue-cookies&#x27;const app = createApp(App)app.use(store)app.use(router)app.use(ElementPlus)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125;// @ts-ignoreapp.config.globalProperties.$cookies = VueCookies;app.mount(&#x27;#app&#x27;) &lt;template&gt; &lt;div class=&quot;cookie-test&quot;&gt; &lt;el-button @click=&quot;cookieInTest&quot;&gt;点击存入cookie&lt;/el-button&gt; &lt;el-button @click=&quot;cookieDeleteTest&quot;&gt;点击删除cookie&lt;/el-button&gt; &lt;br&gt; &lt;span&gt;cookieForm:&#123;&#123;cookieForm&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;span&gt;mydata:&#123;&#123;myData&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, getCurrentInstance, ref,onMounted&#125; from &#x27;vue&#x27;;import VueCookies from &#x27;vue-cookies&#x27;export default defineComponent(&#123; name: &#x27;&#x27;, setup()&#123; let cookieForm=ref(); let internalInstance = getCurrentInstance(); let cookies = internalInstance.appContext.config.globalProperties.$cookies const cookieInTest=()=&gt;&#123; // 存入，可加时间限制(秒) // cookies.set(&#x27;test&#x27;, &#x27;Hello world!&#x27;,5); // cookies.set(&#x27;test&#x27;, &#x27;Hello world!&#x27;,5000); // 获取 // cookieForm.value=cookies.get(&#x27;test&#x27;); // 将数据保存到cookie中 cookies.set(&#x27;myData&#x27;, &#x27;测试数据&#x27;, &#x27;30d&#x27;) myData.value=cookies.get(&#x27;myData&#x27;); console.log(&quot;set--mydata,&quot;,myData.value); &#125; const cookieDeleteTest=()=&gt;&#123; // cookies.remove(&#x27;test&#x27;); // 获取 // cookieForm.value=cookies.get(&#x27;test&#x27;); cookies.remove(&#x27;myData&#x27;); myData.value=cookies.get(&#x27;myData&#x27;); &#125; const createdData=()=&gt;&#123; // cookieForm = cookies.get(&#x27;myData&#x27;) &#125; const myData = ref(&#x27;&#x27;) onMounted(() =&gt; &#123; // 从cookie中读取数据 myData.value = cookies.get(&#x27;myData&#x27;) console.log(&quot;mydata,&quot;,myData.value); &#125;) return &#123; cookieForm, cookieInTest, cookieDeleteTest, myData &#125; &#125;&#125;)&lt;/script&gt; 工具类 util&#x2F;index.js import Vue from &#x27;vue&#x27;import &#123;Router as router&#125; from &quot;vue-router&quot;;/** * 获取uuid * @returns &#123;string&#125; uuid */export function getUUID() &#123; return &#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27;.replace(/[xy]/g, c =&gt; &#123; return (c === &#x27;x&#x27; ? (Math.random() * 16 | 0) : (&#x27;r&amp;0x3&#x27; | &#x27;0x8&#x27;)).toString(16) &#125;)&#125;/** * 是否有权限 * @param &#123;*&#125; key */export function isAuth (key) &#123; return JSON.parse(sessionStorage.getItem(&#x27;permissions&#x27;) || &#x27;[]&#x27;).indexOf(key) !== -1 || false&#125;/** * 树形数据转换 * @param &#123;*&#125; data * @param &#123;*&#125; id * @param &#123;*&#125; pid */export function treeDataTranslate (data, id = &#x27;id&#x27;, pid = &#x27;parentId&#x27;) &#123; const res = []; const temp = &#123;&#125;; for (let i = 0; i &lt; data.length; i++) &#123; temp[data[i][id]] = data[i] &#125; for (let k = 0; k &lt; data.length; k++) &#123; if (temp[data[k][pid]] &amp;&amp; data[k][id] !== data[k][pid]) &#123; if (!temp[data[k][pid]][&#x27;children&#x27;]) &#123; temp[data[k][pid]][&#x27;children&#x27;] = [] &#125; if (!temp[data[k][pid]][&#x27;_level&#x27;]) &#123; temp[data[k][pid]][&#x27;_level&#x27;] = 1 &#125; data[k][&#x27;_level&#x27;] = temp[data[k][pid]]._level + 1 temp[data[k][pid]][&#x27;children&#x27;].push(data[k]) &#125; else &#123; res.push(data[k]) &#125; &#125; return res&#125;/** * 清除登录信息 */export function clearLoginInfo () &#123; // Vue.cookie.delete(&#x27;token&#x27;) // store.commit(&#x27;resetStore&#x27;) // router.options.isAddDynamicMenuRoutes = false&#125; qsnpm install qs --save qs的使用parse 将url的参数转化为object对象 const str = &quot;name=%E9%A9%AC%E5%B0%8F%E8%B7%B3&amp;age=12&amp;address=%E5%BC%82%E6%AC%A1%E5%85%83&#x27;&quot; console.log(qs.parse(str)) // Object &#123;name: &quot;马小跳&quot;,age: &quot;12&quot;,address: &quot;异次元&quot;&#125; stringfy 将对象转为url参数格式 console.log(qs.stringify(&#123; name:&#x27;马小跳&#x27;, age:12, address:&#x27;异次元&#x27;&#125;))// logs name=%E9%A9%AC%E5%B0%8F%E8%B7%B3&amp;age=12&amp;address=%E5%BC%82%E6%AC%A1%E5%85%83 echarts echarts官网数据可视化 npm install echarts --save main.ts内引入 // 全局引入相关包import * as echarts from &quot;echarts&quot;;// 开启echartsapp.config.globalProperties.$echarts = echarts; 组件内使用 &lt;template&gt; &lt;div id=&quot;myChart&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, toRefs, reactive, onMounted&#125; from &#x27;vue&#x27;import * as echarts from &#x27;echarts&#x27;export default defineComponent(&#123; name: &#x27;EchartsTest&#x27;, setup() &#123; const state = reactive(&#123; option: &#123; title: &#123; text: &#x27;Referer of a Website&#x27;, subtext: &#x27;Fake Data&#x27;, left: &#x27;center&#x27; &#125;, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27; &#125;, grid: &#123; top: &#x27;4%&#x27;, left: &#x27;2%&#x27;, right: &#x27;4%&#x27;, bottom: &#x27;0%&#x27;, containLabel: true, &#125;, series: [ &#123; name: &#x27;Access From&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, data: [ &#123; value: 1048, name: &#x27;Search Engine&#x27; &#125;, &#123; value: 735, name: &#x27;Direct&#x27; &#125;, &#123; value: 580, name: &#x27;Email&#x27; &#125;, &#123; value: 484, name: &#x27;Union Ads&#x27; &#125;, &#123; value: 300, name: &#x27;Video Ads&#x27; &#125; ], emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125;, &#125;) const initEcharts = () =&gt; &#123; let myChart = echarts.init(document.getElementById(&#x27;myChart&#x27;)) // 绘制图表 myChart.setOption(state.option) &#125; onMounted(() =&gt; &#123; initEcharts() &#125;) return &#123; ...toRefs(state), &#125; &#125;,&#125;)&lt;/script&gt;&lt;style scoped&gt;#myChart&#123; width: 700px; height: 700px;&#125;&lt;/style&gt; 其他常用依赖 博客 常用库 博客","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"JavaScript&JQuery复习","slug":"编程语言/Js&JQuery/JavaScript&JQuery复习","date":"2023-04-19T13:00:00.000Z","updated":"2024-06-01T14:12:25.014Z","comments":true,"path":"/bian-cheng-yu-yan/js-jquery/javascript-jquery-fu-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/js-jquery/javascript-jquery-fu-xi.html","excerpt":"","text":"JavaScript&amp;JQuery复习JavaScript弹窗&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;myAlert()&quot; class=&quot;large-btn btn&quot;&gt;click&lt;/button&gt; &lt;script&gt; // 警告框 function myAlert()&#123; alert(&quot;警告&quot;); &#125; // 确认框 function myConfirm()&#123; var flag=confirm(&quot;是否确认？&quot;); console.log(&quot;您选择是:&quot;,flag===true?&#x27;确认&#x27;:&#x27;取消&#x27;); &#125; // 提示框 function myPrompt()&#123; prompt(&quot;标题&quot;,&quot;默认的内容是XXX(不写则为空)&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .my-div&#123; width:100px; height: 100px; background-color: red; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;my-div&quot; onclick=&quot;myClick()&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; onfocus=&quot;myFocus()&quot; placeholder=&quot;获取焦点&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; onblur=&quot;myBlur()&quot; placeholder=&quot;失去焦点&quot;&gt;&lt;br&gt; &lt;div class=&quot;my-div&quot; onmouseover=&quot;myMouseover()&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; onkeyup=&quot;myKeyup()&quot; placeholder=&quot;键盘弹起&quot;&gt;&lt;br&gt; &lt;script&gt; // 鼠标点击 function myClick()&#123; console.log(&quot;鼠标点击&quot;); &#125; // 获取焦点 function myFocus()&#123; console.log(&quot;获取焦点&quot;); &#125; // 失去焦点 function myBlur()&#123; console.log(&quot;失去焦点&quot;); &#125; // 鼠标移入 function myMouseover()&#123; console.log(&quot;鼠标移入&quot;); &#125; // 键盘弹起 function myKeyup()&#123; console.log(&quot;键盘弹起&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 时钟 setInterval &amp; setTimeout &lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; // var 日期对象=new Date(参数) // 参数格式 MM DD,YYYY,hh:mm:ss window.onload = function () &#123; this.showTime(); &#125;; function showTime() &#123; // 每隔1秒执行一次 setInterval(function () &#123; time = this.getTime(); document.getElementById(&#x27;app&#x27;).innerText = time &#125;, 1000); // 定时1秒后执行 // setTimeout(function () &#123; // console.log(&#x27;aaa&#x27;); // &#125;) &#125; function getTime() &#123; var today = new Date(); console.log(today.getDay()); console.log(today.getMonth() + 1); console.log(today.getFullYear() + &#x27;年:&#x27; + (today.getMonth() + 1) + &#x27;月&#x27; + today.getDate() + &#x27;日&#x27; + today.getHours() + &#x27;:&#x27; + today.getMinutes() + &#x27;:&#x27; + today.getSeconds()); return today.getFullYear() + &#x27;年:&#x27; + (today.getMonth() + 1) + &#x27;月&#x27; + today.getDate() + &#x27;日&#x27; + today.getHours() + &#x27;:&#x27; + today.getMinutes() + &#x27;:&#x27; + today.getSeconds(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 显示与隐藏 display 不保留隐藏的属性 visibility 只是隐藏，原本的标签还在 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot; onclick=&quot;dpcq()&quot;&gt;斗破苍穹&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#&quot; onclick=&quot;wdqk()&quot;&gt;武动乾坤&lt;/a&gt;&lt;br&gt; &lt;button&gt;点击1&lt;/button&gt; &lt;br&gt; &lt;button onclick=&quot;showButton1()&quot;&gt;点击2&lt;/button&gt; &lt;script&gt; // document.URL 返回当前文档URL // document.referrer 载入本页面文档的地址 // 由于代码写在body上方，此时还未加载a标签，所以应该将script写在body下方 var num = document.getElementsByTagName(&#x27;a&#x27;); for (var i = 0; i &lt; num.length; i++) &#123; console.log(num[i]); &#125; console.log(&#x27;aaa&#x27;); // 显示斗破苍穹 function dpcq() &#123; document.getElementsByTagName(&#x27;div&#x27;)[0].style.display = &#x27;block&#x27;; document.getElementsByTagName(&#x27;div&#x27;)[1].style.display = &#x27;none&#x27;; &#125; // 显示武动乾坤 function wdqk() &#123; document.getElementsByTagName(&#x27;div&#x27;)[1].style.display = &#x27;block&#x27;; document.getElementsByTagName(&#x27;div&#x27;)[0].style.display = &#x27;none&#x27;; &#125; function showButton1() &#123; var button1 = document.getElementsByTagName(&#x27;button&#x27;)[0]; button1.style.visibility = &#x27;hidden&#x27; button1.style.display = &#x27;none&#x27; // display 和 visibility 的区别 // display 不保留隐藏的属性 // visibility 只是隐藏，原本的标签还在 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全选&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; // document获取对象的其他方法 // querySelector() 返回页面中第一个匹配规则的元素 // querySelectorAll() 返回页面中匹配规则的全部元素 window.onload = function () &#123; var list = document.querySelectorAll(&quot;.one&quot;) for (let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = function () &#123; var flag = true; for (let j = 0; j &lt; list.length; j++) &#123; // 等同于 // if(lest[j].checked==false) if (!list[j].checked) &#123; flag = false; &#125; document.querySelector(&quot;input&quot;).checked = flag; &#125; &#125; &#125; &#125; function chooseAll() &#123; // 打印全选的选中状态 // console.log(document.querySelector(&quot;input&quot;).checked); var checkList = document.querySelectorAll(&quot;.one&quot;) for (let i = 0; i &lt; checkList.length; i++) &#123; checkList[i].checked = document.querySelector(&quot;input&quot;).checked; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;checkbox&quot; value=&quot;all&quot; onclick=&quot;chooseAll()&quot;&gt;全选&lt;br&gt; &lt;input type=&quot;checkbox&quot; class=&quot;one&quot; value=&quot;eat&quot;&gt;吃饭&lt;br&gt; &lt;input type=&quot;checkbox&quot; class=&quot;one&quot; value=&quot;game&quot;&gt;游戏&lt;br&gt; &lt;input type=&quot;checkbox&quot; class=&quot;one&quot; value=&quot;learn&quot;&gt;学习&lt;br&gt;&lt;/body&gt;&lt;/html&gt; CSS交互&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #app &#123; width: 50px; height: 50px; background-color: red; &#125; .one &#123; width: 50px; height: 50px; background-color: red; &#125; .two &#123; width: 50px; height: 50px; background-color: green; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; // 方法一： // var allDiv = document.querySelector(&quot;#app&quot;); // allDiv.onmouseover = function () &#123; // allDiv.style.backgroundColor = &#x27;green&#x27;; // &#125;; // allDiv.onmouseout = function () &#123; // allDiv.style.backgroundColor = &#x27;red&#x27;; // &#125;; // 方法二： // var allDiv = document.querySelector(&quot;#app&quot;); // allDiv.onmouseover = function () &#123; // allDiv.id = &#x27;&#x27;; // // 去掉div id则可以显示 two的样式 // // 因为id的优先级大于class // allDiv.className = &#x27;two&#x27;; // &#125;; // allDiv.onmouseout = function () &#123; // allDiv.className = &#x27;one&#x27;; // &#125;; &#125;; function test() &#123; // background-color 改为 backgroundColor，驼峰命名 document.getElementById(&quot;app&quot;).style.backgroundColor = &#x27;grey&#x27;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;test()&quot;&gt;点击&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;div id=&quot;app&quot; class=&quot;two&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 获取文本框的值&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button onclick=&quot;getInputData()&quot;&gt;获取&lt;/button&gt; &lt;script&gt; function getInputData()&#123; console.log(&quot;值:&quot;,document.getElementsByTagName(&quot;input&quot;)[0].value); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 省市级联&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; window.onload=function () &#123; var pro=document.getElementById(&quot;province&quot;); var city=document.getElementById(&quot;city&quot;); pro.onchange=function () &#123; city.innerHTML=&quot;&quot;; var arr=new Array(2); arr[0]=[&#x27;武汉&#x27;,&#x27;荆州&#x27;,&quot;aaa&quot;]; arr[1]=[&#x27;长沙&#x27;,&#x27;啊啊&#x27;]; var index=pro.selectedIndex-1; for(let i=0;i&lt;arr.length;i++)&#123; city.add(new Option(arr[index][i],arr[index][i]),null) &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select id=&quot;province&quot;&gt; &lt;option value=&quot;0&quot; hidden&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;湖北&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;湖南&lt;/option&gt;&lt;/select&gt;&lt;select id=&quot;city&quot;&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 正则表达式校验&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;tip&quot; style=&quot;color: red&quot;&gt;&lt;/span&gt; &lt;script&gt; // 正则表达式语法 // 普通方式 // var reg=/表达式/附加参数 // 如：var reg=/white/g; // 构造函数 // var reg=new RegExp(&quot;表达式&quot;,&quot;附加参数&quot;); // 简单模式 // var reg=/china8/; // 复合模式 // var reg=/^\\w+$/; // RegExp 对象的方法 // exec 检索字符中是正则表达式的匹配，返回找到的值 // test 检索字符中指定的值，返回true or false // RegExp 对象的属性 // global RegExp对象是否具有标志g，全文查找 // ignoreCase RegExp对象是否具有标志i，忽略大小写 // multiline RegExp对象是否具有标志m，多行查找 window.onload = function () &#123; var user = document.getElementById(&quot;username&quot;); user.onblur = function () &#123; var reg = /^\\d&#123;3&#125;\\S&#123;1&#125;@\\S&#123;2&#125;.com$/ if (!reg.test(user.value)) &#123; document.getElementById(&quot;tip&quot;).innerText = &#x27;格式输入错误&#x27; &#125; else &#123; document.getElementById(&quot;tip&quot;).innerText = &#x27;&#x27; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JQuery初识语法&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .one &#123; width: 300px; height: 300px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; $(document).ready(function () &#123; console.log(&quot;aaa&quot;); &#125;); // 以上写法可简写成如下写法 $(function () &#123; console.log(&quot;bbb&quot;); &#125;); $(function () &#123; // 支持链式编程，如下 // $(&quot;.one&quot;).mouseover(function () &#123; // $(&quot;.one&quot;).css(&quot;backgroundColor&quot;, &quot;green&quot;).next().css() // &#125;); $(&quot;#app&quot;).addClass(&quot;one&quot;); $(&quot;.one&quot;).mouseover(function () &#123; $(&quot;.one&quot;).css(&quot;backgroundColor&quot;, &quot;green&quot;) &#125;); $(&quot;.one&quot;).mouseout(function () &#123; $(&quot;.one&quot;).css(&quot;backgroundColor&quot;, &quot;red&quot;) &#125;); &#125;); // jquery对象转DOM对象 // var $app = $(&quot;#app&quot;); //jquery对象 // var app = $app[0]; // DOM对象 // var $app = $(&quot;#app&quot;); //jquery对象 // var app = $app.get(0); // DOM对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类CSS选择器&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;h2 class=&quot;top&quot; name=&quot;qaq&quot;&gt;啊啊啊&lt;/h2&gt; &lt;span&gt;呵呵&lt;/span&gt; &lt;div id=&quot;aaa&quot;&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;div&gt;呵呵&lt;/div&gt; &lt;span&gt;aa&lt;/span&gt; &lt;p&gt;bb&lt;/p&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;div&gt;cc&lt;/div&gt; &lt;p&gt;哈哈&lt;/p&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; // 并集选择器 $(&quot;h2,span&quot;).css(&quot;color&quot;, &quot;red&quot;); // 交集选择器 // 选择class为top的h2标签 $(&quot;h2.top&quot;).css(&quot;color&quot;, &quot;green&quot;); // 全局选择器 // $(&#x27;*&#x27;).css(...) // 后代选择器 // $(&quot;#aaa p&quot;) // 子选择器 // $(&quot;#aaa&gt;p) // 相邻选择器 // 这里选择的是id为aaa内的p标签，p标签后紧邻着的div $(&quot;#aaa&gt;p+div&quot;).css(&#x27;color&#x27;, &#x27;red&#x27;); // 同辈选择器 // 这里选择的是id为aaa内的div标签,div标签之后的所有的同辈的p标签 // 请注意！！！ // 选择的是div之后的p标签，所以第一个p标签并不会被选中 // $(&quot;#aaa&gt;div~p&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 属性选择器 // 选择的是页面上具有class属性的标签 $(&quot;[class]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择的是页面上具有class属性的h2标签 $(&quot;h2[class]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择的是页面上class属性为top的h2标签 $(&quot;h2[class=&#x27;top&#x27;]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择的是页面上class属性以op结尾的h2标签 $(&quot;h2[class$=&#x27;op&#x27;]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择的是页面上class属性以t开头的h2标签 $(&quot;h2[class^=&#x27;t&#x27;]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择的是页面上class属性包含t的h2标签 $(&quot;h2[class*=&#x27;t&#x27;]&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 多属性条件选择 // 选择的是页面上包含class属性，且name属性以q开头 以q结尾的标签 $(&quot;h2[class][name^=&#x27;q&#x27;][name$=&#x27;q&#x27;]&quot;).css(&quot;color&quot;, &quot;blue&quot;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤选择器&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;script src=&quot;/js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/vue2.7.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt; &lt;p hidden&gt;aaa&lt;/p&gt; &lt;script&gt; $(function () &#123; // 基本过滤选择器 // 选择第一个div $(&quot;div:first&quot;).css(&quot;color&quot;, &quot;red&quot;); // 选择最后一个div $(&quot;div:last&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择第偶数个div(从0开始) $(&quot;div:even&quot;).css(&quot;color&quot;, &quot;red&quot;); // 选择第奇数个div(从0开始) $(&quot;div:odd&quot;).css(&quot;color&quot;, &quot;red&quot;); // // 选择索引为1(从0开始) $(&quot;div:eq(1)&quot;).css(&quot;color&quot;, &quot;red&quot;); // 选择索引大于1(从0开始) $(&quot;div:gt(1)&quot;).css(&quot;color&quot;, &quot;red&quot;); // 选择索引小于1(从0开始) $(&quot;div:lt(1)&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 选择class不为one的li元素 $(&quot;li:not(.one)&quot;) // 选择所有的标题元素 $(&quot;:header&quot;) // 选择获取焦点的元素 $(&quot;:focus&quot;) // 可见性过滤选择器 // 选择隐藏的p标签，使其显示 $(&quot;p:hidden&quot;).show(); // 选择显示的p标签，使其隐藏 $(&quot;p:visible&quot;).hide(); // 表单对象过滤选择器 // 内容过滤选择器、子元素过滤选择器 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #app&#123; width: 300px; height: 300px; background-color: red; &#125; &lt;/style&gt; &lt;script src=&quot;../js/jquery/jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 鼠标事件 $(&quot;div[id=&#x27;app&#x27;]&quot;).mouseover(function () &#123; $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&#x27;backgroundColor&#x27;,&quot;blue&quot;); &#125;); $(&quot;div[id=&#x27;app&#x27;]&quot;).mouseout(function () &#123; $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&#x27;backgroundColor&#x27;,&quot;red&quot;); &#125;) &#125;) $(document).keyup(function (event) &#123;// console.log(event.keyCode); if(event.keyCode==13)&#123; console.log(&quot;提交成功!&quot;); &#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JQuery动画&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #app &#123; width: 300px; height: 300px; background-color: red; &#125; &lt;/style&gt; &lt;script src=&quot;../js/jquery/jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;div[id=&#x27;app&#x27;]&quot;).hover( function () &#123; $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&quot;backgroundColor&quot;, &quot;green&quot;); &#125;, function () &#123; $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&quot;backgroundColor&quot;, &quot;red&quot;); &#125; ); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; var i=0; $(&quot;button:first&quot;).click(function () &#123; i++; if(i%2==1)&#123;// $(&quot;div#app&quot;).hide(&quot;show&quot;); // 1000毫秒// $(&quot;div#app&quot;).hide(1000);// $(&quot;div#app&quot;).fadeOut(&quot;show&quot;); $(&quot;div#app&quot;).slideUp(&quot;show&quot;); &#125;else&#123;// $(&quot;div#app&quot;).show(&quot;show&quot;);// $(&quot;div#app&quot;).fadeIn(&quot;show&quot;); $(&quot;div#app&quot;).slideDown(&quot;show&quot;); &#125; // 淡入、淡出效果// fadeIn、fadeOut // 改变元素的高度// slideUp、slideDown &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样式及内容操作&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/jquery/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;cli&quot;&gt;点击&lt;/button&gt;&lt;input type=&quot;text&quot; placeholder=&quot;随便输入&quot;&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;$(&quot;button[id=&#x27;cli&#x27;]&quot;).click(function () &#123;// $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&quot;backgroundColor&quot;,&quot;red&quot;) // 同时设置多个样式 $(&quot;div[id=&#x27;app&#x27;]&quot;).css(&#123; &quot;width&quot;:&quot;300px&quot;, &quot;height&quot;:&quot;300px&quot;, &quot;backgroundColor&quot;:&quot;red&quot; &#125;) // 追加样式// addClass(&quot;classname1 classname2&quot;) // 移除样式// removeClass(&quot;style1 style2&quot;)&#125;) $(&quot;input[type=&#x27;text&#x27;]&quot;).bind(&#123; &quot;blur&quot;:function () &#123; // 获取值// console.log(&quot;失去焦点了&quot;,$(&quot;input[type=&#x27;text&#x27;]&quot;).val()); // 设置值 // val()为空时，获取值；val(&quot;xxx&quot;)时，设置值 $(&quot;input[type=&#x27;text&#x27;]&quot;).val(&quot;aaa&quot;) &#125;, &quot;focus&quot;:function () &#123; // 获取值 console.log(&quot;获取焦点了&quot;,$(&quot;input[type=&#x27;text&#x27;]&quot;).val()); &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 节点操作&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/jquery/jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; // 前者添加到后者// $(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;).appendTo(&quot;#app&quot;); // 向前者中添加后者// $(&quot;#app&quot;).append(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;); // 将后者添加到前者之前// $(&quot;#app&quot;).prepend(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;); // 将前者添加到后者之前// $(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;).prependTo(&quot;#app&quot;); // 前者后面添加后者，同辈节点// $(&quot;#app&quot;).after(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;); // 前者添加后者后面，同辈节点// $(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;).insertAfter(&quot;#app&quot;); // 前者前面添加后者，同辈节点// $(&quot;#app&quot;).before(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;); // 后者前面添加前者，同辈节点// $(&quot;&lt;li&gt;啊哈哈哈&lt;/li&gt;&quot;).insertBefore(&quot;#app&quot;); // replace()和replaceAll()用于替换某个节点 // 新节点替换旧节点// $(&quot;旧节点&quot;).replaceWith(&quot;新节点&quot;);// $(&quot;新节点&quot;).replaceAll(&quot;旧节点&quot;);// clone()用于复制某个节点 // true 表示需要copy事件处理// $(&quot;span&quot;).clone(true).appendTo(&quot;div&quot;); // 删除节点// remove() 删除某个节点，自身删除自身// detach() 删除整个节点，保留元素事件、附加数据// empty() 清空节点内容，清空子节点&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 属性操作&amp;节点遍历&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/jquery/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; name=&quot;哈哈&quot;&gt; &lt;span id=&quot;test&quot;&gt; &lt;span&gt;aaa&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;男&lt;script&gt;$(function () &#123; // 获取name属性的值 console.log($(&quot;#app&quot;).attr(&quot;name&quot;)); // 设置值 $(&quot;#app&quot;).attr(&#123;style:&quot;width: 300px;height:300px;background-color:red&quot;&#125;) $(&quot;img&quot;).attr(&#123;width:&#x27;300px&#x27;,height:&quot;300px&quot;&#125;) // prop 和 attr的区别 // 第一个input标签 // 显示 undefined// console.log($(&quot;input[type=&#x27;radio&#x27;]&quot;).attr(&quot;checked&quot;)); // 显示 false// console.log($(&quot;input[type=&#x27;radio&#x27;]&quot;).prop(&quot;checked&quot;));// $(&quot;input[type=&#x27;radio&#x27;]&quot;).attr(&quot;checked&quot;,&quot;checked&quot;);// $(&quot;input[type=&#x27;radio&#x27;]&quot;).prop(&quot;checked&quot;,&quot;true&quot;); // 获取父级元素// console.log($(&quot;span[id=&#x27;test&#x27;]&quot;).parent()); // 获取所有父级及祖级元素// console.log($(&quot;span[id=&#x27;test&#x27;]&quot;).parents()); // 获取元素的所有子元素，但不包含孙子元素（子元素的子元素）// console.log($(&quot;#app&quot;).children()); // 用于获取该标签之后的元素// next() // 用于获取该标签之前的元素// prev() // 用于获取该标签之前、与后的所有同辈元素元素// sublings()// css() // 设置或返回元素的宽度// weight // 设置或返回元素的高度// height $(function () &#123;// $(&quot;div&quot;).each(function (i, domEle) &#123;// // 索引//// console.log(i);// console.log($(domEle).text());// &#125;) &#125;) $.each((&quot;div&quot;),function (i, domEle) &#123; console.log($(domEle).text()); &#125;)&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"复习","slug":"复习","permalink":"https://isunderachiever.github.io/categories/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"JavaScript&JQuery复习","slug":"JavaScript-JQuery复习","permalink":"https://isunderachiever.github.io/tags/JavaScript-JQuery%E5%A4%8D%E4%B9%A0/"}]},{"title":"Vue3学习","slug":"编程语言/Vue/Vue3/Vue3学习","date":"2023-04-15T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue3/vue3-xue-xi.html","excerpt":"","text":"Vue3学习 要求，点击按钮，改变数据vue2的写法也可以实现 &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;span&gt;count:&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, data()&#123; return&#123; count:0 &#125; &#125;, methods:&#123; test()&#123; this.count++; &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button&#123; width: 80px; height: 30px;&#125;&lt;/style&gt; 接下来看vue3的写法 &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;span&gt;count:&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, setup()&#123; // 变量 let count=0; // 方法 function test()&#123; count++; console.log(&quot;测试:&quot;,count); &#125; return&#123; count:count, test &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button&#123; width: 80px; height: 30px;&#125;&lt;/style&gt; 然而此时的页面并没有变化，为什么？ 因为此时的数据并不是响应式数据 ref 正确写法ref一般用来定义一个基本类型的响应式数据 &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;span&gt;count:&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, ref&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, setup()&#123; // ref一般用来定义一个基本类型的响应式数据，若需要将一个对象变成响应式数据该用谁呢？（答:reactive） let count=ref(0); // 方法 function test()&#123; // count是一个ref对象，所以不能直接count++ // 而上面并没有写&#123;&#123;count.value&#125;&#125;来进行渲染，而是&#123;&#123;count&#125;&#125; count.value++; console.log(&quot;测试:&quot;,count); &#125; return&#123; count:count, test &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button&#123; width: 80px; height: 30px;&#125;&lt;/style&gt; reactive 要求，显示用户的相关信息，点击按钮后更新用户信息 &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄:&#123;&#123;user.age&#125;&#125;&lt;/p&gt; &lt;p&gt;座驾:&#123;&#123;user.cars&#125;&#125;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;父亲姓名:&#123;&#123;user.father.name&#125;&#125;&lt;/li&gt; &lt;li&gt;父亲年龄:&#123;&#123;user.father.age&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;母亲姓名:&#123;&#123;user.mather.name&#125;&#125;&lt;/li&gt; &lt;li&gt;母亲年龄:&#123;&#123;user.father.age&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, /* 作用:定义多个数据的响应式 const proxy=reactive(obj):接收一个普通对象然后返回该普通对象的响应式代理器对象 响应式转换是“深层的”:会影响对象内部所有嵌套的属性 内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据都是响应式的 */ setup() &#123; // 把数据编程响应式的数据 // 返回的是一个proxy代理对象，被代理的对象是传入的对象 // testObj是代理对象，而obj是目标对象 // obj=&#123;&#125; // const testObj=reactive(obj); // obj.name=&#x27;aaa&#x27; // 直接使用目标对象的方式来更新属性的值，是无法改变的，只能使用代理对象来进行修改 // 正确使用方式如下: // testObj.name=&#x27;aaa&#x27; let user = reactive(&#123; name: &quot;王明&quot;, age: 20, cars: [&#x27;风火轮&#x27;, &#x27;哮天犬&#x27;, &#x27;筋斗云&#x27;], father: &#123; name: &quot;王海&quot;, age: 45 &#125;, mather: &#123; name: &quot;李花花&quot;, age: 43 &#125; &#125;); // 方法 const test=()=&gt;&#123; user.name+=&#x27;-&#x27;; user.age++; user.cars=[&#x27;葫芦&#x27;,&#x27;飞剑&#x27;] &#125; return &#123; user: user, test &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button &#123; width: 80px; height: 30px;&#125;&lt;/style&gt; 新需求， user-&gt;代理对象obj -&gt;目标对象 user对象或者obj对象添加一个新的属性，哪种方式会影响界面的更新？ user对象或者obj对象移除一个已存在的属性，哪种方式会影响界面的更新？ &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄:&#123;&#123;user.age&#125;&#125;&lt;/p&gt; &lt;p&gt;性别:&#123;&#123;user.gender&#125;&#125;&lt;/p&gt; &lt;p&gt;座驾:&#123;&#123;user.cars&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, setup() &#123; // 为了在使用【obj.gender=&#x27;男&#x27;;】时不出现错误信息才采用这种写法 // let obj:any=&#123; let obj:any=&#123; name: &quot;王明&quot;, age: 20, cars: [&#x27;风火轮&#x27;, &#x27;哮天犬&#x27;, &#x27;筋斗云&#x27;] &#125;; let user = reactive(obj); // 方法 const test=()=&gt;&#123; // 这种方式页面并没有更新渲染，但是obj中的属性已被添加 // obj.gender=&#x27;男&#x27;; // 为了不出现错误提示，可【let obj:any=&#123;】或者【let user = reactive&lt;any&gt;(obj);】 // 这种方式可以更新界面，而且属性也被添加到obj对象了 user.gender=&#x27;男&#x27; // 界面没有更新，但是obj中的属性已被删除 // delete obj.age; // 页面更新渲染,obj中属性已被删除 delete user.age; console.log(user); &#125; return &#123; user: user, test &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button &#123; width: 80px; height: 30px;&#125;&lt;/style&gt; 总结：如果操作代理对象,目标对象中的数据也会随之变化，同时如果想要在操作数据的时候，界面也要跟着重新更新渲染，那么需要操作代理对象 vue2与vue3响应式的对比 vue2 核心: 对象:通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视&#x2F;拦截) 数组:通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持 问题 对象直接新添加的属性或删除已有属性,界面不会自动更新 直接通过下标替换元素或更新length,界面不会自动更新arr[1]&#x3D; {} vue3 核心: 通过Proxy(代理):拦截对data任意属性的任意(13种)操作,包括属性值的读写,属性的添加，属性的删除等.. 通过Reflect(反射):动态对被代理对象的相应属性进行特定的操作 响应式数据 响应式数据原理: 直接在vue项目中新建一个html页面 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;响应式的原理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 目标对象 const user = &#123; name: &#x27;佐助&#x27;, age: 20, wife: &#123; name: &#x27;小樱&#x27;, age: 19 &#125; &#125; // 代理对象 const proxyUser = new Proxy(user, &#123; // 获取目标对象的某个属性值 get(target, prop) &#123; console.log(&quot;get方法被调用了&quot;); return Reflect.get(target, prop); &#125;, // 修改目标对象的属性值 &amp; 为目标对象添加新的属性 set(target, prop, newValue) &#123; console.log(&quot;set方法被调用了&quot;); return Reflect.set(target, prop, newValue); &#125;, // 删除目标对象上的某个属性 deleteProperty(target, prop) &#123; console.log(&quot;deleteProperty方法被调用了&quot;); return Reflect.deleteProperty(target, prop); &#125; &#125;); // 通过代理对象获取目标对象的信息 console.log(proxyUser.name); // 通过代理对象更新目标对象上的属性值 proxyUser.name = &#x27;鸣人&#x27;; console.log(user); // 通过代理对象向目标对象中添加一个新的属性 proxyUser.gender=&#x27;男&#x27;; // 通过代理对象删除目标对象中的属性 delete proxyUser.name; console.log(user); // 更新目标对象中的某个属性的对象的值 proxyUser.wife.name=&#x27;雏田&#x27;; console.log(user);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 响应式数据的测试 &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt; &lt;br&gt; &lt;p&gt;姓名:&#123;&#123;user.name&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄:&#123;&#123;user.age&#125;&#125;&lt;/p&gt; &lt;p&gt;性别:&#123;&#123;user.gender&#125;&#125;&lt;/p&gt; &lt;p&gt;座驾:&#123;&#123;user.cars&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent, reactive, ref&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Home&#x27;, props: &#123; msg: String, &#125;, setup() &#123; // 为了在使用【obj.gender=&#x27;男&#x27;;】时不出现错误信息才采用这种写法 // let obj:any=&#123; let obj:any=&#123; name: &quot;王明&quot;, age: 20, cars: [&#x27;风火轮&#x27;, &#x27;哮天犬&#x27;, &#x27;筋斗云&#x27;] &#125;; let user = reactive(obj); // 方法 const test=()=&gt;&#123; user.cars[0]=&#x27;炼丹炉&#x27;; // 数组中添加新元素 user.cars[3]=&#x27;葫芦&#x27;; &#125; return &#123; user: user, test &#125; &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;button &#123; width: 80px; height: 30px;&#125;&lt;/style&gt; setup细节&lt;template&gt; &lt;div&gt; &lt;h2&gt;子级组件&lt;/h2&gt; &lt;p&gt;msg:&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; name: &#x27;Child&#x27;, props:[&#x27;msg&#x27;], // setup细节问题: // 1.setup在beforeCreate之前就会执行 setup()&#123; console.log(&quot;setup执行了&quot;); // setup中一般都是返回一个对象，对象中的属性和方法可以都在html模板中使用 return&#123; &#125; &#125;, // 数据初始化的生命周期的回调 beforeCreate() &#123; console.log(&quot;beforeCreate执行了&quot;); &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"flex布局","slug":"编程语言/Vue/布局/Flex布局","date":"2023-04-15T16:00:00.000Z","updated":"2024-06-01T14:12:25.057Z","comments":true,"path":"/bian-cheng-yu-yan/vue/bu-ju/flex-bu-ju.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/bu-ju/flex-bu-ju.html","excerpt":"","text":"推介查看 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; width: 100%; height: 100vh; /* flex布局 */ display: flex; /* justify-content &amp; align-items */ /* 延横轴方向居中对齐 */ /*justify-content: center;*/ /* 靠右对齐 */ /*justify-content: flex-end;*/ /* 左右两端对齐，相等间距 */ /*justify-content: space-between;*/ /* 项目中间的间距为左右两端的2倍 */ /*justify-content: space-around;*/ /* 项目之间间距与项目容器之间间距相等 */ /*justify-content: space-evenly;*/ /* 默认，沿着交叉轴布局方向分布 */ /*justify-content: flex-start;*/ /* 交叉轴居中排列,此处需要将父元素设置一定高度才起作用 */ /*align-items: center;*/ /* 交叉轴底部对齐 */ /*align-items: flex-end;*/ /* 项目水平垂直居中 */ /*justify-content: center;*/ /*align-items: center;*/ /* flex-direction &amp; flex-wrap*/ /* 默认为row */ /*flex-direction: row-reverse;*/ /* 按列分布 */ /*flex-direction: column;*/ /*flex-direction: column-reverse;*/ /* flex-wrap默认为nowrap，项目会强行等分容器，且不换行 */ /* 根据自身宽度进行排列 */ flex-wrap: wrap; &#125; /* 项目属性: order &amp; flex &amp; align-self */ /*order 排列顺序*/ /*flex-grow 项目在有剩余空间时，是否放大*/ /*取值:默认0 1 auto, flex属性是flex- grow, flex-shrink与flex- basis三个属性的简写，*/ /*用于定义项目放大，缩小与宽度。该属性有两个快捷键值，分别是auto(1 1 auto)等分放大缩小，与none(0 0 auto)不放大，但等分缩小，*/ .test-div &#123; width: 200px; height: 200px; background-color: #00FFFF; border: 1px solid black; text-align: center; line-height: 200px; &#125; .test-div:first-child &#123; background-color: red; /*order: 1;*/ /*align-self: center;*/ /*align-self: flex-end;*/ &#125; .test-div:nth-child(2) &#123; background-color: gray; /*order: 0;*/ &#125; .test-div:nth-child(3) &#123; background-color: greenyellow; /*order: 2;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;test-div&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;test-div&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;test-div&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"布局","slug":"布局","permalink":"https://isunderachiever.github.io/categories/%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"flex布局","slug":"flex布局","permalink":"https://isunderachiever.github.io/tags/flex%E5%B8%83%E5%B1%80/"}]},{"title":"thymeleaf学习","slug":"编程语言/模板语言/Thymeleaf/Thymeleaf","date":"2023-04-15T06:50:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/mo-ban-yu-yan/thymeleaf/thymeleaf.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/mo-ban-yu-yan/thymeleaf/thymeleaf.html","excerpt":"","text":"thymeleaf学习依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; thymeleaf默认模板&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ch&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;默认的标题&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;默认的描述&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;默认的关键字&quot;&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; thymeleaf配置server: # 应用服务 WEB 访问端口 port: 10010spring: # 应用名称 application: name: thymeleaf-demo # 配置thymeleaf thymeleaf: cache: false mode: HTML5 encoding: UTF-8 prefix: classpath:/templates/ #名称的后缀 suffix: .html servlet: content-type: text/html datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据源名称 name: defaultDataSource # 数据库连接地址 url: jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8 # 数据库用户名&amp;密码： username: root password: 123456mybatis-plus: # 指定Mybatis的Mapper文件 mapper-locations: classpath:mapper/*xml # 指定Mybatis的实体目录 type-aliases-package: com.example.plus.domain # 日志打印 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 逻辑删除列配置 global-config: db-config: # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-field: delFlag # 逻辑已删除值(默认为 1) logic-delete-value: 1 # 逻辑未删除值(默认为 0) logic-not-delete-value: 0logging: pattern: dateformat: MM-ddHH:mm:ss:SSS 注意 本项目采用thymeleaf+mybatis plus+mysql+springboot，项目结构如下其中templates用来存放html，templates下的component内用于存放页面中可复用的组件static下存放静态文件，如js、css、img…thymeleaf:. └─src └─main ├─java │ └─com │ └─example │ ├─controller │ ├─domain │ ├─mapper │ └─service │ └─impl └─resources ├─mapper ├─static │ ├─css │ ├─js │ └─json └─templates └─component 示例1 语法:$&#123;&#125;获取数据，||拼接(当然可也用单引号+双引号拼接) 访问localhost:10010/test可观察到页面标题的变化 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ch&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;|拼接+$&#123;title&#125;|&quot;&gt;默认的标题&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;默认的描述&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;默认的关键字&quot;&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; @GetMapping(&quot;/test&quot;)public ModelAndView indexTest()&#123; ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(&quot;title&quot;,&quot;传递的标题&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView; &#125; 语法@GetMapping(&quot;/basic-train&quot;)public ModelAndView basicTest()&#123; ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(&quot;userList&quot;,userService.list()); modelAndView.addObject(&quot;user&quot;,userService.getById(2)); modelAndView.addObject(&quot;title&quot;,&quot;basic页面&quot;); modelAndView.setViewName(&quot;basic&quot;); return modelAndView; &#125; 链接变表达式：可引入外部文件，如js、css等&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;css/test.css&#125;&quot;&gt;&lt;script th:src=&quot;@&#123;js/jquery-3.0.0.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;a th:href=&quot;@&#123;index.html&#125;&quot;&gt;超链接&lt;/a&gt; th:text 这里有个细节请注意:mysql表中的字段为nick_name，这里的属性和java实体类对应，所以是nickName &lt;!-- th:text --&gt;&lt;span th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span th:text=&quot;$&#123;user.password&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span th:text=&quot;$&#123;user.nickName&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;!-- 换一种方式 --&gt;&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt; &lt;span th:text=&quot;*&#123;id&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:text=&quot;*&#123;username&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:text=&quot;*&#123;password&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:text=&quot;*&#123;nickName&#125;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;3. th:if &lt;!-- th:if --&gt;&lt;div th:if=&quot;$&#123;user.id&#125;==1&quot;&gt;id为1&lt;/div&gt; th:each 循环 &lt;!-- th:each --&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;昵称&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;item,index : $&#123;userList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;item.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.username&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.password&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.nickName&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; th:classappend 添加class &lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;昵称&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;item,index : $&#123;userList&#125;&quot;&gt; &lt;!-- 追加class --&gt; &lt;!-- 如果是最后一个，则添加test为class --&gt; &lt;td th:text=&quot;$&#123;item.id&#125;&quot; th:classappend=&quot;$&#123;index.last&#125;?test&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.username&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.password&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;item.nickName&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; th:switch &lt;!-- th:switch --&gt;&lt;div th:switch=&quot;$&#123;user.username&#125;&quot;&gt; &lt;p th:case=&quot;admin&quot;&gt;用户是admin&lt;/p&gt; &lt;p th:case=&quot;aaaaa&quot;&gt;用户是aaaaa&lt;/p&gt; &lt;p th:case=&quot;asdas&quot;&gt;用户是asdas&lt;/p&gt; &lt;!-- 若都不是其他case，则显示默认值 --&gt; &lt;p th:case=&quot;*&quot;&gt;默认值&lt;/p&gt;&lt;/div&gt; 如何动态获取th:text里的内容？–th:inline &lt;!-- 需要动态渲染的javascript --&gt;&lt;!-- 同理，css也可以这样渲染 --&gt;&lt;script th:inline=&quot;javascript&quot;&gt; /* 若user没有传值，则使用后面的默认值;若user传了值，使用注释里的user值 */ let user =/*[[$&#123;user&#125;]]*/&#123;&#125; console.log(&quot;thymeleaf-user:&quot;,user);&lt;/script&gt; 组件(碎片) th:replacecomponent&#x2F;com.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;ch&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 本页面的style样式在组件被其它页面引入后是不会显示的 --&gt; &lt;style&gt; #com1 &#123; width: 300px; height: 20px; background-color: greenyellow; &#125; #com2 &#123; width: 300px; height: 20px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:fragment=&quot;com1&quot; id=&quot;com1&quot;&gt; com1&lt;/div&gt;&lt;div th:fragment=&quot;com2&quot; id=&quot;com2&quot;&gt; com2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; basic.html &lt;!-- th:replace --&gt;&lt;!-- 替换碎片 --&gt;&lt;!-- 将div标签也替换成com1内的标签 --&gt;&lt;div th:replace=&quot;~&#123;component/com::com1&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 如果不希望div标签被替换，可以使用insert --&gt;&lt;div th:insert=&quot;~&#123;component/com::com2&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 也可以通过类似jquery选择器的方式获取 --&gt;&lt;div th:insert=&quot;~&#123;component/com::#com2&#125;&quot;&gt;&lt;/div&gt; ajax格式$.ajax(&#123; //请求的url地址 url: &quot;&quot;, //返回格式为json dataType: &quot;json&quot;, //请求是否异步，默认为异步，这也是ajax重要特性 async: true, //参数值 data: &#123;&#125;, //请求方式 type: &quot;GET&quot;, beforeSend: function () &#123; //请求前的处理 &#125;, success: function (data) &#123; //请求成功时处理 console.log(&quot;data:&quot;, data) &#125;, complete: function () &#123; //请求完成的处理 &#125;, error: function () &#123; //请求出错处理 &#125;&#125;); 项目地址点击","categories":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://isunderachiever.github.io/categories/thymeleaf/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://isunderachiever.github.io/tags/thymeleaf/"}]},{"title":"自定义异常未被捕获","slug":"报错记录/SpringBoot/自定义异常未被@RestControllerAdvice捕获","date":"2023-04-05T12:30:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/springboot/zi-ding-yi-yi-chang-wei-bei-restcontrolleradvice-bu-huo.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/springboot/zi-ding-yi-yi-chang-wei-bei-restcontrolleradvice-bu-huo.html","excerpt":"","text":"自定义异常未被捕获自定义异常未被@RestControllerAdvice捕获 自定义了一个异常未被@RestControllerAdvice捕获 原因是被try..catch..捕获了，而没被@RestControllerAdvice捕获 这个原因其实我之前听说过但是没遇到过，现在遇到了，真的长记性了…","categories":[{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/categories/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/tags/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"}]},{"title":"注解@RequestBody使用报错","slug":"报错记录/SpringBoot/注解@RequestBody使用报错","date":"2023-04-05T12:30:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/springboot/zhu-jie-requestbody-shi-yong-bao-cuo.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/springboot/zhu-jie-requestbody-shi-yong-bao-cuo.html","excerpt":"","text":"注解@RequestBody使用报错@RequestBody 今天在使用requestBody注解时，出现了一些问题不知道咋想的，传参不是这么传的 既然用的是@RequestBody注解，如果是User user，那这么写没问题，但是写的是Integer id 那应该使用如下格式的传参","categories":[{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/categories/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/tags/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"}]},{"title":"Clion配置","slug":"系统配置/编程配置/环境配置/CLion配置/Clion配置","date":"2023-04-04T13:00:00.000Z","updated":"2024-06-02T13:38:04.896Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/clion-pei-zhi/clion-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/clion-pei-zhi/clion-pei-zhi.html","excerpt":"","text":"Clion配置准备工作 仅用作学习记录，可点击下方【参考博客】的链接前往原博客，支持原创 参考博客 mingw-w64 如果下载速度太慢，可点击此处下载 配置环境 在环境变量的path中添加mingw64下bin的路径 D:\\mingw64\\bin cmd输入gcc -v，若显示如下，表示成功 配置Clion","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Hibernate","slug":"编程语言/Java/学习/框架/ORM/Hibernate","date":"2023-04-02T00:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/orm/hibernate.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/orm/hibernate.html","excerpt":"","text":"Hibernate学习01 参考博客 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。名称为【实体类+.hbm.xml】 --&gt;&lt;!-- 导入约束:dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 复制hibernate-mapping-3.0.dtd内约束指实体类xml create table tb_user( id number primary key , username varchar2(20), password varchar2(20), nick_name varchar2(20));comment on table tb_user is &#x27;用户表&#x27;;comment on column tb_user.id is &#x27;主键&#x27;;comment on column tb_user.username is &#x27;用户名&#x27;;comment on column tb_user.password is &#x27;密码&#x27;;comment on column tb_user.nick_name is &#x27;昵称&#x27;;commit; public class User &#123; private int uids; private String username; private String password; private String nickName; public User() &#123; &#125; public User(int uids, String username, String password, String nickName) &#123; this.uids = uids; this.username = username; this.password = password; this.nickName = nickName; &#125; public int getUids() &#123; return uids; &#125; public void setUids(int uids) &#123; this.uids = uids; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!-- 在实体类所在的包下，创建一个xml文件。名称为【实体类+.hbm.xml】 --&gt;&lt;!-- 导入约束:dtd约束 --&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.example.domain&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;TB_USER&quot;&gt; &lt;id name=&quot;uids&quot; column=&quot;id&quot;&gt; &lt;!-- 主键的生成方式 native是使用本地数据库的自动增长能力--&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;property name=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;property name=&quot;nickName&quot; column=&quot;nick_name&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在根目录下创建hibernate.cfg.xml，一般是src，但是我这里设置的是java &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!-- 在项目的根路径下创建名为hibernate.cfg.xml的配置文件 --&gt;&lt;!-- 导入约束:dtd约束 --&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 配置sessionFactory --&gt; &lt;!-- sessionFactory的作用是用来创建session对象，session对象就是hibernate中操作数据库的核心对象--&gt; &lt;!-- 创建sessionFactory的三步 --&gt; &lt;!-- 1.连接数据库的信息 2.hibernate的可选配置 3.映射文件位置 --&gt; &lt;session-factory&gt; &lt;!-- 1.连接数据库的信息 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt; oracle.jdbc.driver.OracleDriver &lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt; jdbc:oracle:thin:@localhost:1521:orcl &lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt; test &lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt; 123456 &lt;/property&gt; &lt;!-- 数据库的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.Oracle8iDialect&lt;/property&gt; &lt;!-- 2.hibernate的可选配置 --&gt; &lt;!-- 显示hibernate生成的sql语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 是否使用格式化输出sql语句 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 配置hibernate采用何种方式生成DDL语句 --&gt; &lt;!-- update表示检测实体类的映射配置与数据库结构是否一致，如果不一致，更新表结构;如果没有该表，则创建该表 --&gt; &lt;!-- SQL结构化查询语言: 一共分为6个部分 DDL: Data Definition Language DML: Data Manipulatiok Language DQL: Data Query Language DCL: Data Control Language 数据控制语言 CCL: Cursor Control Language 游标控制语言 TPL: Transaction Processing Language 事务处理语言 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 3.映射配置文件的路径 --&gt; &lt;!-- 多个配置文件就在这里写多次 --&gt; &lt;mapping resource=&quot;com/example/domain/User.hbm.xml&quot;/&gt;&lt;!-- &lt;mapping resource=&quot;com/example/domain/User.hbm.xml&quot;/&gt;--&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;","categories":[{"name":"ORM框架","slug":"ORM框架","permalink":"https://isunderachiever.github.io/categories/ORM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://isunderachiever.github.io/tags/Hibernate/"}]},{"title":"Java泛型","slug":"编程语言/Java/学习/基础/009_Java泛型","date":"2023-04-01T10:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/009-java-fan-xing.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/009-java-fan-xing.html","excerpt":"","text":"Java泛型Java泛型参考视频 在类上 这是个打印integer的类，但也仅仅只能打印integer了 难道以后要打印String、Double还需要复制粘贴再新建类吗？ public class PrinterInteger &#123; Integer needToPrint; public PrinterInteger(Integer needToPrint) &#123; this.needToPrint = needToPrint; &#125; public void print()&#123; System.out.println(needToPrint); &#125;&#125; 可以考虑采用以下方式 public class Printer &lt;T&gt;&#123; T needToPrint; public Printer(T needToPrint) &#123; this.needToPrint = needToPrint; &#125; public void print()&#123; System.out.println(needToPrint); &#125; /** * 测试 */ static class MyTest&#123; public static void main(String[] args) &#123; // 打印String Printer&lt;String&gt; stringPrinter = new Printer&lt;&gt;(&quot;hello world&quot;); stringPrinter.print(); // 打印Double Printer&lt;Double&gt; doublePrinter = new Printer&lt;&gt;(30.5); doublePrinter.print(); &#125; &#125;&#125; 泛型不能使用基本数据类型，如int、long等泛型 extends public class Animal &#123; String name; int age; public void eat()&#123; System.out.println(&quot;吃饭ing&quot;); &#125;&#125; public class Cat extends Animal&#123; private String litterPreference; public Cat(String name) &#123; this.name = name; &#125; public Cat() &#123; &#125; public String getLitterPreference() &#123; return litterPreference; &#125; public void setLitterPreference(String litterPreference) &#123; this.litterPreference = litterPreference; &#125;&#125; public class Dog extends Animal&#123; int walkDistancePreference;&#125; 泛型这么写 public class Printer &lt;T extends Animal&gt;&#123; T needToPrint; public Printer(T needToPrint) &#123; this.needToPrint = needToPrint; &#125; public void print()&#123; System.out.println(needToPrint); &#125;&#125; 这个时候就会报错了，因为泛型写了&lt;T extends Animal&gt;，改写成如下写法后正确 public class Printer &lt;T extends Animal&gt;&#123; T needToPrint; public Printer(T needToPrint) &#123; this.needToPrint = needToPrint; &#125; public void print()&#123; System.out.println(needToPrint); &#125; /** * 测试 */ static class MyTest&#123; public static void main(String[] args) &#123; // 打印Cat Printer&lt;Cat&gt; stringPrinter = new Printer&lt;&gt;(new Cat()); stringPrinter.print(); // 打印Dog Printer&lt;Dog&gt; doublePrinter = new Printer&lt;&gt;(new Dog()); doublePrinter.print(); &#125; &#125;&#125; eat方法定义在Animal类中，但如果取消掉类上的&lt;T extends Animal&gt;后，这行代码会报错但是java不支持多继承，所以如果还需要同时继承Animal怎么办，参考如下写法 但是注意，接口要写在后面，如果调换位置会报错 public class Printer&lt;T extends Animal &amp; Serializable&gt; &#123; T needToPrint; public Printer(T needToPrint) &#123; this.needToPrint = needToPrint; &#125; public void print() &#123; System.out.println(needToPrint); &#125; /** * 测试 */ static class MyTest &#123; public static void main(String[] args) &#123; &#125; &#125;&#125; 多个泛型参数 public class Printer&lt;T, V&gt; &#123; T needToPrint; V moreMsg; public Printer(T needToPrint, V moreMsg) &#123; this.needToPrint = needToPrint; this.moreMsg = moreMsg; &#125; public void print() &#123; System.out.printf(&quot;T:%s%n&quot;, needToPrint); System.out.printf(&quot;V:%s%n&quot;, moreMsg); &#125; /** * 测试 */ static class MyTest &#123; public static void main(String[] args) &#123; Printer&lt;String, Cat&gt; catPrinter = new Printer&lt;&gt;(&quot;哈哈哈&quot;, new Cat()); catPrinter.print(); &#125; &#125;&#125; 在方法上 作用在方法上注意，这个时候他并不知道T是一个泛型，你需要”告诉他” public class MyTest &#123; public static void main(String[] args) &#123; print(&quot;abc&quot;); print(123); print(new Cat()); &#125; public static &lt;T&gt; void print(T str)&#123; System.out.println(str+&quot;:打印完成&quot;); &#125;&#125; 当然，也可以写多个参数 public class MyTest &#123; public static void main(String[] args) &#123; print(&quot;哈哈哈&quot;, new Cat()); &#125; public static &lt;T, V&gt; void print(T str, V msg) &#123; System.out.printf(&quot;T:%s%n&quot;, str); System.out.printf(&quot;V:%s%n&quot;, msg); &#125;&#125; 指定返回值的泛型 public class MyTest &#123; public static void main(String[] args) &#123; String print = print(&quot;哈哈哈&quot;, new Cat()); System.out.println(&quot;返回值:&quot;+print); &#125; public static &lt;T, V&gt; T print(T str, V msg) &#123; System.out.printf(&quot;T:%s%n&quot;, str); System.out.printf(&quot;V:%s%n&quot;, msg); return str; &#125;&#125; 泛型通配符首先，来看一下下面这个问题报错如下是不是觉得很奇怪？Integer是Object的子类，为什么不能这么传值呢? 对，Integer是Object的子类没错，但是这里是List&lt;Object&gt;和List&lt;Integer&gt; List&lt;Integer&gt;并不是List&lt;Object&gt;的子类 或者可以把List&lt;Object&gt;换成Object，List&lt;Integer&gt;是Object的子类 但是我们要的不是这种效果 这时可以采用通配符? public class MyTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); print(list); &#125; public static void print(List&lt;?&gt; list) &#123; System.out.println(list); &#125;&#125; 甚至还可以指定是否继承某个类 public class MyTest &#123; public static void main(String[] args) &#123; List&lt;Cat&gt; animal = new ArrayList&lt;&gt;(); animal.add(new Cat()); print(animal); &#125; public static void print(List&lt;? extends Animal&gt; list) &#123; System.out.println(list); &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://isunderachiever.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://isunderachiever.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"支付宝沙箱支付","slug":"编程语言/Java/学习/框架/SpringBoot/支付宝沙箱支付","date":"2023-03-27T03:00:00.000Z","updated":"2024-06-01T14:32:53.429Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/zhi-fu-bao-sha-xiang-zhi-fu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/zhi-fu-bao-sha-xiang-zhi-fu.html","excerpt":"","text":"支付宝沙箱支付 参考博客1 参考博客2 网站 参考视频,青戈的demo项目密钥导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.22.110.ALL&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.20&lt;/version&gt;&lt;/dependency&gt; application.properties里需要配置这四个这里复制第一个appid复制第二个私钥复制第三个支付宝公钥至于第四个url，需要下载一个工具natapp地址 官网：https://natapp.cn/下载：https://pan.baidu.com/s/1L99Ibawylnck4b4c0NtmXg?pwd=685x 下载后，去官网注册账号配好之后双击start.bat还需要配置controller的地址配置到此结束 import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Data@Component@ConfigurationProperties(prefix = &quot;alipay&quot;)public class AliPayConfig &#123; private String appId; private String appPrivateKey; private String alipayPublicKey; private String notifyUrl;&#125; import lombok.Data;@Datapublic class AliPay &#123; private String traceNo; private double totalAmount; private String subject; private String alipayTraceNo;&#125; 继续新建AliPayController，把报错的AliPayConfig包换成自己项目里的路径，还有Order import cn.hutool.json.JSONObject;import com.alipay.api.AlipayApiException;import com.alipay.api.AlipayClient;import com.alipay.api.DefaultAlipayClient;import com.alipay.api.internal.util.AlipaySignature;import com.alipay.api.request.AlipayTradePagePayRequest;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.example.alipay.common.AliPayConfig;import com.example.alipay.dao.OrdersMapper;import com.example.alipay.entity.Orders;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Date;import java.util.HashMap;import java.util.Map;// xjlugv6874@sandbox.com// 9428521.24 - 30 = 9428491.24 + 30 = 9428521.24@RestController@RequestMapping(&quot;/alipay&quot;)public class AliPayController &#123; private static final String GATEWAY_URL = &quot;https://openapi.alipaydev.com/gateway.do&quot;; private static final String FORMAT = &quot;JSON&quot;; private static final String CHARSET = &quot;UTF-8&quot;; //签名方式 private static final String SIGN_TYPE = &quot;RSA2&quot;; @Resource private AliPayConfig aliPayConfig; @Resource private OrdersMapper ordersMapper; @GetMapping(&quot;/pay&quot;) // &amp;subject=xxx&amp;traceNo=xxx&amp;totalAmount=xxx public void pay(AliPay aliPay, HttpServletResponse httpResponse) throws Exception &#123; // 1. 创建Client，通用SDK提供的Client，负责调用支付宝的API AlipayClient alipayClient = new DefaultAlipayClient(GATEWAY_URL, aliPayConfig.getAppId(), aliPayConfig.getAppPrivateKey(), FORMAT, CHARSET, aliPayConfig.getAlipayPublicKey(), SIGN_TYPE); // 2. 创建 Request并设置Request参数 AlipayTradePagePayRequest request = new AlipayTradePagePayRequest(); // 发送请求的 Request类 request.setNotifyUrl(aliPayConfig.getNotifyUrl()); JSONObject bizContent = new JSONObject(); bizContent.set(&quot;out_trade_no&quot;, aliPay.getTraceNo()); // 我们自己生成的订单编号 bizContent.set(&quot;total_amount&quot;, aliPay.getTotalAmount()); // 订单的总金额 bizContent.set(&quot;subject&quot;, aliPay.getSubject()); // 支付的名称 bizContent.set(&quot;product_code&quot;, &quot;FAST_INSTANT_TRADE_PAY&quot;); // 固定配置 request.setBizContent(bizContent.toString()); // 执行请求，拿到响应的结果，返回给浏览器 String form = &quot;&quot;; try &#123; form = alipayClient.pageExecute(request).getBody(); // 调用SDK生成表单 &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; httpResponse.setContentType(&quot;text/html;charset=&quot; + CHARSET); httpResponse.getWriter().write(form);// 直接将完整的表单html输出到页面 httpResponse.getWriter().flush(); httpResponse.getWriter().close(); &#125; @PostMapping(&quot;/notify&quot;) // 注意这里必须是POST接口 public String payNotify(HttpServletRequest request) throws Exception &#123; if (request.getParameter(&quot;trade_status&quot;).equals(&quot;TRADE_SUCCESS&quot;)) &#123; System.out.println(&quot;=========支付宝异步回调========&quot;); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); Map&lt;String, String[]&gt; requestParams = request.getParameterMap(); for (String name : requestParams.keySet()) &#123; params.put(name, request.getParameter(name)); // System.out.println(name + &quot; = &quot; + request.getParameter(name)); &#125; String outTradeNo = params.get(&quot;out_trade_no&quot;); String gmtPayment = params.get(&quot;gmt_payment&quot;); String alipayTradeNo = params.get(&quot;trade_no&quot;); String sign = params.get(&quot;sign&quot;); String content = AlipaySignature.getSignCheckContentV1(params); boolean checkSignature = AlipaySignature.rsa256CheckContent(content, sign, aliPayConfig.getAlipayPublicKey(), &quot;UTF-8&quot;); // 验证签名 // 支付宝验签 if (checkSignature) &#123; // 验签通过 System.out.println(&quot;交易名称: &quot; + params.get(&quot;subject&quot;)); System.out.println(&quot;交易状态: &quot; + params.get(&quot;trade_status&quot;)); System.out.println(&quot;支付宝交易凭证号: &quot; + params.get(&quot;trade_no&quot;)); System.out.println(&quot;商户订单号: &quot; + params.get(&quot;out_trade_no&quot;)); System.out.println(&quot;交易金额: &quot; + params.get(&quot;total_amount&quot;)); System.out.println(&quot;买家在支付宝唯一id: &quot; + params.get(&quot;buyer_id&quot;)); System.out.println(&quot;买家付款时间: &quot; + params.get(&quot;gmt_payment&quot;)); System.out.println(&quot;买家付款金额: &quot; + params.get(&quot;buyer_pay_amount&quot;)); // 查询订单 QueryWrapper&lt;Orders&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;order_id&quot;, outTradeNo); Orders orders = ordersMapper.selectOne(queryWrapper); if (orders != null) &#123; orders.setAlipayNo(alipayTradeNo); orders.setPayTime(new Date()); orders.setState(&quot;已支付&quot;); ordersMapper.updateById(orders); &#125; &#125; &#125; return &quot;success&quot;; &#125;&#125; http://localhost:15000/alipay/pay?subject=香蕉&amp;traceNo=202208221661165525068&amp;totalAmount=6.99 可以看到这里是502，奇怪，视频上明明是这样做的，上网搜了一下，发现博客每周日中午12点至每周一中午12点沙箱环境进行维护，今天是周日 官方也说了，请查看ok，过了时间就可以打开了 商家信息商户账号rilvmb5932@sandbox.com登录密码111111商户PID2088621987551356账户余额2132135.00买家信息买家账号xesgkm3338@sandbox.com登录密码111111支付密码111111用户UID2088622987164881用户名称xesgkm3338证件类型IDENTITY_CARD证件账号308282195800026310账户余额99999.00 这里我遇到了一个问题，没有执行回调，我上网查了一下，找到这篇博客，但是我不是这个原因这个url，复制粘贴到alipay.notifyUrl这里，这个url每次启动都会改变，所以应该更改properties","categories":[{"name":"支付宝沙箱支付","slug":"支付宝沙箱支付","permalink":"https://isunderachiever.github.io/categories/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/"}],"tags":[{"name":"支付宝沙箱支付","slug":"支付宝沙箱支付","permalink":"https://isunderachiever.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/"}]},{"title":"添加\"通过XXX打开\"的右键菜单","slug":"系统配置/编程配置/环境配置/添加右键以XXX的方式打开/添加右键以XXX的方式打开","date":"2023-03-26T23:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tian-jia-you-jian-yi-xxx-de-fang-shi-da-kai/tian-jia-you-jian-yi-xxx-de-fang-shi-da-kai.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tian-jia-you-jian-yi-xxx-de-fang-shi-da-kai/tian-jia-you-jian-yi-xxx-de-fang-shi-da-kai.html","excerpt":"","text":"添加【通过XXX打开】的右键菜单 参考博文 可以看到暂时还没有以webstorm打开的快捷方式win+R，输入regedit新建项，命名为webstorm点击默认项，输入Open Folder as WebStorm Project设置图标命名为Icon赋值webStorm文件路径设置之前新建的Icon的值参考&quot;D:\\IntelliJ IDEA 2022.3.1\\bin\\idea64.exe&quot; &quot;%1&quot;这个命令，将文件路径换成自己的，其他不变","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"添加【通过XXX打开】的右键菜单","slug":"添加【通过XXX打开】的右键菜单","permalink":"https://isunderachiever.github.io/tags/%E6%B7%BB%E5%8A%A0%E3%80%90%E9%80%9A%E8%BF%87XXX%E6%89%93%E5%BC%80%E3%80%91%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"}]},{"title":"SpringSecurity密码加密存储","slug":"编程语言/Java/学习/框架/SpringSecurity/SpringSecurity密码加密存储","date":"2023-03-26T10:00:00.000Z","updated":"2024-06-01T14:12:24.998Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springsecurity/springsecurity-mi-ma-jia-mi-cun-chu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springsecurity/springsecurity-mi-ma-jia-mi-cun-chu.html","excerpt":"","text":"SpringSecurity密码加密存储BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();String encode = passwordEncoder.encode(user.getPassword());// 配置加密后的密码user.setPassword(encode);public static void main(String[] args) &#123; BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(&quot;123&quot;); String encode1 = passwordEncoder.encode(&quot;123&quot;); boolean matches = passwordEncoder.matches(&quot;123&quot;, encode); //true boolean matches1 = passwordEncoder.matches(&quot;123&quot;, encode1); //true boolean matches2 = passwordEncoder.matches(encode,encode1); //false System.out.println(matches); System.out.println(matches1); System.out.println(matches2);&#125;","categories":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://isunderachiever.github.io/categories/SpringSecurity/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://isunderachiever.github.io/tags/SpringSecurity/"}]},{"title":"vue需求","slug":"编程语言/Vue/Vue2/项目中遇到的问题","date":"2023-03-25T16:00:00.000Z","updated":"2024-06-01T14:12:25.025Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue2/xiang-mu-zhong-yu-dao-de-wen-ti.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue2/xiang-mu-zhong-yu-dao-de-wen-ti.html","excerpt":"","text":"项目中遇到的问题对话框 之前在网上copy的，现在我自己也找不到人家原创的了，仅此记录index.js // 多行查看box框export function messageBoxMutiple(content, title, func) &#123; MessageBox.confirm(content, title, &#123; type: &quot;success&quot;, showConfirmButton: false, showCancelButton: false, dangerouslyUseHTMLString: true &#125;).then(function () &#123; func(); &#125;).catch(() =&gt; &#123; &#125;);&#125; 在需要引入的vue组件内引入使用 // 引入import &#123;messageBoxMutiple&#125; from &quot;@/utils&quot;;// 使用var str = &quot;&quot;;var msg = [`姓名:$&#123;this.user.name&#125;`,`性别:$&#123;this.user.gender&#125;`,];msg.forEach((item) =&gt; &#123;str += `&lt;div&gt;$&#123;item&#125;&lt;/div&gt;`;&#125;);messageBoxMutiple(str, &quot;查看用户信息&quot;, function () &#123;&#125;); 第二个，在网上找到的，博客 这里仅作记录，请前往该博客支持原创 创建组件Dialog.vue&lt;template&gt; &lt;div class=&quot;m-dialog-mask&quot; @click.self=&quot;onBlur&quot;&gt; &lt;div :class=&quot;[&#x27;m-dialog&#x27;, center ? &#x27;relative-hv-center&#x27; : &#x27;top-center&#x27;]&quot; :style=&quot;`width: $&#123;dialogWidth&#125;; height: $&#123;dialogHeight&#125;;`&quot;&gt; &lt;div class=&quot;m-dialog-content&quot; :class=&quot;&#123;loading: loading&#125;&quot;&gt; &lt;div class=&quot;m-spin-dot&quot; v-show=&quot;loading&quot;&gt; &lt;span class=&quot;u-dot-item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;u-dot-item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;u-dot-item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;u-dot-item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;svg @click=&quot;onFullScreen&quot; v-show=&quot;!fullScreen&amp;&amp;switchFullscreen&quot; class=&quot;u-screen&quot; viewBox=&quot;64 64 896 896&quot; data-icon=&quot;fullscreen&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot;&gt;&lt;path d=&quot;M290 236.4l43.9-43.9a8.01 8.01 0 0 0-4.7-13.6L169 160c-5.1-.6-9.5 3.7-8.9 8.9L179 329.1c.8 6.6 8.9 9.4 13.6 4.7l43.7-43.7L370 423.7c3.1 3.1 8.2 3.1 11.3 0l42.4-42.3c3.1-3.1 3.1-8.2 0-11.3L290 236.4zm352.7 187.3c3.1 3.1 8.2 3.1 11.3 0l133.7-133.6 43.7 43.7a8.01 8.01 0 0 0 13.6-4.7L863.9 169c.6-5.1-3.7-9.5-8.9-8.9L694.8 179c-6.6.8-9.4 8.9-4.7 13.6l43.9 43.9L600.3 370a8.03 8.03 0 0 0 0 11.3l42.4 42.4zM845 694.9c-.8-6.6-8.9-9.4-13.6-4.7l-43.7 43.7L654 600.3a8.03 8.03 0 0 0-11.3 0l-42.4 42.3a8.03 8.03 0 0 0 0 11.3L734 787.6l-43.9 43.9a8.01 8.01 0 0 0 4.7 13.6L855 864c5.1.6 9.5-3.7 8.9-8.9L845 694.9zm-463.7-94.6a8.03 8.03 0 0 0-11.3 0L236.3 733.9l-43.7-43.7a8.01 8.01 0 0 0-13.6 4.7L160.1 855c-.6 5.1 3.7 9.5 8.9 8.9L329.2 845c6.6-.8 9.4-8.9 4.7-13.6L290 787.6 423.7 654c3.1-3.1 3.1-8.2 0-11.3l-42.4-42.4z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg @click=&quot;onFullScreen&quot; v-show=&quot;fullScreen&amp;&amp;switchFullscreen&quot; class=&quot;u-screen&quot; viewBox=&quot;64 64 896 896&quot; data-icon=&quot;fullscreen-exit&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot;&gt;&lt;path d=&quot;M391 240.9c-.8-6.6-8.9-9.4-13.6-4.7l-43.7 43.7L200 146.3a8.03 8.03 0 0 0-11.3 0l-42.4 42.3a8.03 8.03 0 0 0 0 11.3L280 333.6l-43.9 43.9a8.01 8.01 0 0 0 4.7 13.6L401 410c5.1.6 9.5-3.7 8.9-8.9L391 240.9zm10.1 373.2L240.8 633c-6.6.8-9.4 8.9-4.7 13.6l43.9 43.9L146.3 824a8.03 8.03 0 0 0 0 11.3l42.4 42.3c3.1 3.1 8.2 3.1 11.3 0L333.7 744l43.7 43.7A8.01 8.01 0 0 0 391 783l18.9-160.1c.6-5.1-3.7-9.4-8.8-8.8zm221.8-204.2L783.2 391c6.6-.8 9.4-8.9 4.7-13.6L744 333.6 877.7 200c3.1-3.1 3.1-8.2 0-11.3l-42.4-42.3a8.03 8.03 0 0 0-11.3 0L690.3 279.9l-43.7-43.7a8.01 8.01 0 0 0-13.6 4.7L614.1 401c-.6 5.2 3.7 9.5 8.8 8.9zM744 690.4l43.9-43.9a8.01 8.01 0 0 0-4.7-13.6L623 614c-5.1-.6-9.5 3.7-8.9 8.9L633 783.1c.8 6.6 8.9 9.4 13.6 4.7l43.7-43.7L824 877.7c3.1 3.1 8.2 3.1 11.3 0l42.4-42.3c3.1-3.1 3.1-8.2 0-11.3L744 690.4z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg @click=&quot;onClose&quot; class=&quot;u-close&quot; viewBox=&quot;64 64 896 896&quot; data-icon=&quot;close&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot;&gt;&lt;path d=&quot;M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div class=&quot;m-dialog-header&quot;&gt; &lt;slot name=&quot;title&quot;&gt; &lt;div class=&quot;u-head&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;m-dialog-body&quot; :style=&quot;`height: calc($&#123;dialogHeight&#125; - $&#123;footer ? &#x27;158px&#x27;:&#x27;103px&#x27;&#125;);`&quot;&gt; &lt;slot&gt;&#123;&#123; content &#125;&#125;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;m-dialog-footer&quot; v-show=&quot;footer&quot;&gt; &lt;button class=&quot;u-cancel&quot; @click=&quot;onCancel&quot;&gt;&#123;&#123; cancelText &#125;&#125;&lt;/button&gt; &lt;button class=&quot;u-confirm&quot; @click=&quot;onConfirm&quot;&gt;&#123;&#123; okText &#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Dialog&#x27;, props: &#123; title: &#123; // 标题 string | slot type: String, default: &#x27;提示&#x27; &#125;, content: &#123; // 内容 string | slot type: String, default: &#x27;&#x27; &#125;, width: &#123; // 宽度，默认640 type: Number, default: 640 &#125;, height: &#123; // 高度，默认480 type: Number, default: 480 &#125;, switchFullscreen: &#123; // 是否允许切换全屏（允许后右上角会出现一个按钮） type: Boolean, default: false &#125;, cancelText: &#123; // 取消按钮文字 type: String, default: &#x27;取消&#x27; &#125;, okText: &#123; // 确认按钮文字 type: String, default: &#x27;确定&#x27; &#125;, footer: &#123; // 是否显示底部按钮，默认显示 type: Boolean, default: true &#125;, center: &#123; // 水平垂直居中：true 固定高度水平居中：false type: Boolean, default: true &#125;, loading: &#123; // 加载中 type: Boolean, default: false &#125; &#125;, data () &#123; return &#123; fullScreen: false &#125; &#125;, computed: &#123; dialogWidth () &#123; if (this.fullScreen) &#123; return &#x27;100%&#x27; &#125; else &#123; return this.width + &#x27;px&#x27; &#125; &#125;, dialogHeight () &#123; if (this.fullScreen) &#123; return &#x27;100vh&#x27; &#125; else &#123; return this.height + &#x27;px&#x27; &#125; &#125; &#125;, methods: &#123; onBlur () &#123; if (this.loading) &#123; this.$emit(&#x27;close&#x27;) &#125; &#125;, onFullScreen () &#123; this.fullScreen = !this.fullScreen &#125;, onClose () &#123; this.$emit(&#x27;close&#x27;) &#125;, onCancel () &#123; this.$emit(&#x27;cancel&#x27;) &#125;, onConfirm () &#123; this.$emit(&#x27;ok&#x27;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.flex-hv-center &#123; // 水平垂直居中方法①：弹性布局，随内容增大高度，并自适应水平垂直居中 display: flex; justify-content: center; align-items: center;&#125;.relative-hv-center &#123; // 水平垂直居中方法②：相对定位，随内容增大高度，并自适应水平垂直居中 position: relative; top: 50%; transform: translateY(-50%); -ms-transform: translateY(-50%);; /* IE 9 */ -webkit-transform: translateY(-50%); /* Safari and Chrome */&#125;.top-center &#123; // 相对定位，固定高度，始终距离视图顶端100px position: relative; top: 100px;&#125;.m-dialog-mask &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 10000; background: rgba(0,0,0,0.45); .m-dialog &#123; margin: 0 auto; transition: all .3s ease; .m-spin-dot &#123; // 绝对定位，并设置水平垂直居中 position: absolute; display: inline-block; right: 0; left: 0; top: 0; bottom: 0; margin: auto; width: 24px; height: 24px; transform: rotate(45deg); -ms-transform: rotate(45deg); /* Internet Explorer */ -moz-transform: rotate(45deg); /* Firefox */ -webkit-transform: rotate(45deg); /* Safari 和 Chrome */ -o-transform: rotate(45deg); /* Opera */ animation: rotate 1.2s linear infinite; -webkit-animation: rotate 1.2s linear infinite; @keyframes rotate &#123; 100% &#123;transform: rotate(405deg);&#125; &#125; .u-dot-item &#123; // 单个圆点样式 position: absolute; width: 8px; height: 8px; background: #1890ff; border-radius: 50%; opacity: .3; animation: spinMove 1s linear infinite alternate; -webkit-animation: spinMove 1s linear infinite alternate; @keyframes spinMove &#123; 100% &#123;opacity: 1;&#125; &#125; &#125; .u-dot-item:first-child &#123; top: 0; left: 0; &#125; .u-dot-item:nth-child(2) &#123; top: 0; right: 0; animation-delay: .4s; -webkit-animation-delay: .4s; &#125; .u-dot-item:nth-child(3) &#123; bottom: 0; right: 0; animation-delay: .8s; -webkit-animation-delay: .8s; &#125; .u-dot-item:last-child &#123; bottom: 0; left: 0; animation-delay: 1.2s; -webkit-animation-delay: 1.2s; &#125; &#125; .loading &#123; // 加载过程背景虚化 background: rgb(248, 248, 248) !important; pointer-events: none; // 屏蔽鼠标事件 &#125; .m-dialog-content &#123; position: relative; background: #fff; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,.1); .u-screen &#123; .u-close(); right: 64px; &#125; .u-close &#123; width: 16px; height: 16px; position: absolute; top: 19px; right: 24px; fill: rgba(0,0,0,.45); cursor: pointer; transition: fill .3s; &amp;:hover &#123; fill: rgba(0,0,0,.75); &#125; &#125; .m-dialog-header &#123; height: 22px; padding: 16px 24px; color: rgba(0,0,0,.65); border-radius: 4px 4px 0 0; border-bottom: 1px solid #e8e8e8; .u-head &#123; margin: 0; color: rgba(0,0,0,.85); font-weight: 500; font-size: 16px; line-height: 22px; word-wrap: break-word; &#125; &#125; .m-dialog-body &#123; padding: 24px; font-size: 16px; line-height: 1.5; word-wrap: break-word; overflow: auto; transition: all .3s; &#125; .m-dialog-footer &#123; padding: 10px 16px; text-align: right; border-top: 1px solid #e8e8e8; .u-cancel &#123; height: 32px; line-height: 32px; padding: 0 15px; font-size: 16px; border-radius: 4px; color: rgba(0,0,0,.65); background: #fff; border: 1px solid #d9d9d9; cursor: pointer; transition: all .3s cubic-bezier(.645,.045,.355,1); &amp;:hover &#123; color: #40a9ff; border-color: #40a9ff; &#125; &amp;:focus &#123; color: #096dd9; border-color: #096dd9; &#125; &#125; .u-confirm &#123; margin-left: 8px; height: 32px; line-height: 32px; padding: 0 15px; font-size: 16px; border-radius: 4px; background: #1890ff; border: 1px solid #1890ff; color: #fff; transition: all .3s cubic-bezier(.645,.045,.355,1); cursor: pointer; &amp;:hover &#123; color: #fff; background: #40a9ff; border-color: #40a9ff; &#125; &amp;:focus &#123; background: #096dd9; border-color: #096dd9; &#125; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 使用Dialog组件弹出对话框&lt;Dialog :title=&quot;title&quot; :width=&quot;720&quot; :height=&quot;480&quot; :content=&quot;content&quot; :footer=&quot;footer&quot; cancelText=&quot;取消&quot; okText=&quot;确认&quot; switchFullscreen @close=&quot;onClose&quot; @cancel=&quot;onCancel&quot; @ok=&quot;onConfirm&quot; :center=&quot;center&quot; :loading=&quot;loading&quot; v-show=&quot;visible&quot;&gt; &lt;template #title&gt; &lt;p class=&quot;u-title&quot;&gt;Title&lt;/p&gt; &lt;/template&gt; &lt;p&gt;Bla bla ...&lt;/p&gt; &lt;p&gt;Bla bla ...&lt;/p&gt; &lt;p&gt;Bla bla ...&lt;/p&gt;&lt;/Dialog&gt;import Dialog from &#x27;@/components/Dialog&#x27;components: &#123; Dialog&#125;,data () &#123; return &#123; visible: false, content: &#x27;&#x27; &#125;&#125;,methods: &#123; onDialog (content) &#123; // 调用Dialog弹出对话框 this.content = &#x27;Some descriptions ...&#x27; this.visible = true &#125;, onClose () &#123; // 关闭dialog this.visible = false &#125;, onCancel () &#123; // “取消”按钮回调 this.visible = false &#125;, onConfirm () &#123; // “确定”按钮回调 this.visible = false &#125;&#125; 更改每一行的数据 在表格内更改每一行的数据 &lt;el-table-column prop=&quot;phone&quot; header-align=&quot;center&quot; align=&quot;center&quot; label=&quot;手机号&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag type=&quot;info&quot;&gt;&#123;&#123;scope.row.phone&#125;&#125;&lt;/el-tag&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;seeDialog(scope.row.phone)&quot;&gt;手机号&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 选择器&lt;el-form-item label=&quot;用户类型&quot; prop=&quot;gender&quot;&gt; &lt;el-select v-model=&quot;dataForm.gender&quot; placeholder=&quot;请选择接种人性别&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/el-form-item&gt;&lt;!-- data --&gt;options:[&#123; value:&quot;1&quot;, label:&quot;男&quot;&#125;,&#123; value:&quot;0&quot;, label:&quot;女&quot;&#125;], Can’t resolve ‘less-loader’// 安装npm install --save-dev less-loader less// 若继续报错// UnhandledPromiseRejectionWarning: TypeError: loaderContext.getResolve is not …// 执行以下命令，在版本位置处选择合适的版本npm install less-loader@5.0.0 -D 修改store内的数据this.$store.dispatch(&#x27;asyncUpdateUser&#x27;,&#123; email:this.email&#125;)","categories":[{"name":"vue需求","slug":"vue需求","permalink":"https://isunderachiever.github.io/categories/vue%E9%9C%80%E6%B1%82/"}],"tags":[{"name":"vue需求","slug":"vue需求","permalink":"https://isunderachiever.github.io/tags/vue%E9%9C%80%E6%B1%82/"}]},{"title":"hbuilder配置","slug":"系统配置/编程配置/环境配置/Hbuilder/hbuilder配置","date":"2023-03-24T16:00:00.000Z","updated":"2024-06-01T14:32:53.520Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/hbuilder/hbuilder-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/hbuilder/hbuilder-pei-zhi.html","excerpt":"","text":"hbuilder配置关闭更新提示 工具 设置 常用配置（拉到最下面） 运行到谷歌浏览器失败链接：https://pan.baidu.com/s/178gTB9MOQXGMaC_m7QXFdQ?pwd=1234提取码：1234","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"jsp复习","slug":"编程语言/模板语言/Jsp/Jsp","date":"2023-03-23T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/mo-ban-yu-yan/jsp/jsp.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/mo-ban-yu-yan/jsp/jsp.html","excerpt":"","text":"Servlet 项目创建删掉pom.xml点击运行即可因为没有页面在WEB-INF下新建lib包，在lib下存放jar包此时依赖还没完全导入，还需如下操作选择lib，此时就算导入成功了网上copy一个jdbc的工具包 package com.example.util;import org.apache.commons.beanutils.BeanUtils;import java.lang.reflect.Field;import java.sql.*;import java.util.ArrayList;import java.util.List;public class JDBCUtil &#123; //1.加载驱动 static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //2.获取连接 public static Connection getConnection() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/xiaoy&quot;, &quot;root&quot;, &quot;mysql&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; //3.关闭连接 public static void close(Connection conn, Statement st, ResultSet rs) &#123; //关闭连接 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //关闭statement if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //关闭结果集 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //-------------------------------封装sql操作------------------------------ //查询返回List集合 public static &lt;T&gt; List&lt;T&gt; getList(Class&lt;T&gt; cls, String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i &lt;= obj.length; i++) &#123; //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); &#125; //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //4.遍历结果集 //遍历之前准备：因为封装不知道未来会查询多少列，所以我们需要指定有多少列 //获取ResultSet对象的列编号、类型和属性 ResultSetMetaData date = rs.getMetaData(); //获取列数 int column = date.getColumnCount(); //获取本类所有的属性 Field[] fields = cls.getDeclaredFields(); //创建一个list集合对象来存储查询数据 List&lt;T&gt; list = new ArrayList&lt;T&gt;(); //开始遍历结果集 while (rs.next()) &#123; //创建类类型实例 T t = cls.newInstance(); for (int i = 1; i &lt;= column; i++) &#123; //每一列的值 Object value = rs.getObject(i); /** *String columnName = date.getColumnName(i);//获取每一列名称 * 关于获取每一列名称，如果列取了别名的话，则不能用上面的方法取列的名称 * 用下面的方法 */ String columnName = date.getColumnLabel(i);//获取每一列名称（别名） //遍历所有属性对象 for (Field field : fields) &#123; //获取属性名 String name = field.getName(); field.setAccessible(true);//打破封装，忽略对封装修饰符的检测 /*if (name.equals(columnName)) &#123; //获取列类型名称 String string = date.getColumnTypeName(i); //如果列类型是Date类型，转换成字符串表现形式 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String d = sdf.format(value); //赋值：将数据库中查询的字段赋值给对应名称的属性 field.set(t, d); &#125;else&#123; field.set(t, value); &#125;*/ if (name.equals(columnName)) &#123; BeanUtils.copyProperty(t, name, value); break;//增加效率，避免不必要的循环 &#125; &#125; &#125; list.add(t); &#125; return list; //5.关闭连接 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtil.close(conn, ps, rs); &#125; return null; &#125; /** * 增加、删除、修改 * * @param sql sql语句 * @param obj 参数 */ public static boolean getDML(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = getConnection(); ps = conn.prepareStatement(sql); for (int i = 1; i &lt;= obj.length; i++) &#123; ps.setObject(i, obj[i - 1]); &#125; System.out.println(sql); int update = ps.executeUpdate(); if (update &gt; 0) &#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; close(conn, ps, null); &#125; return false; &#125; //查询返回单个对象 public static &lt;T&gt; T getOneObject(Class&lt;T&gt; cls, String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i &lt;= obj.length; i++) &#123; //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); &#125; //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //4.遍历结果集 //遍历之前准备：因为封装不知道未来会查询多少列，所以我们需要指定有多少列 //获取ResultSet对象的列编号、类型和属性 ResultSetMetaData date = rs.getMetaData(); //获取列数 int column = date.getColumnCount(); //获取本类所有的属性 Field[] fields = cls.getDeclaredFields(); //开始遍历结果集 if (rs.next()) &#123; //创建类类型实例 T t = cls.newInstance(); for (int i = 1; i &lt;= column; i++) &#123; //每一列的值 Object value = rs.getObject(i); //获取每一列名称 String columnName = date.getColumnName(i); //遍历所有属性对象 for (Field field : fields) &#123; //获取属性名 String name = field.getName(); //打破封装，忽略对封装修饰符的检测 field.setAccessible(true); if (name.equals(columnName)) &#123; BeanUtils.copyProperty(t, name, value); &#125; &#125; &#125; return t; &#125; //5.关闭连接 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtil.close(conn, ps, rs); &#125; return null; &#125; //查询总记录数 public static Integer getCount(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1.获取连接 conn = getConnection(); //2.获取预处理对象 ps = conn.prepareStatement(sql); //循环参数，如果没有就不走这里 for (int i = 1; i &lt;= obj.length; i++) &#123; //注意：数组下标从0开始，预处理参数设置从1开始 ps.setObject(i, obj[i - 1]); &#125; //3.执行SQL语句 System.out.println(sql); rs = ps.executeQuery(); //开始遍历结果集 if (rs.next()) &#123; return rs.getInt(1); &#125; //5.关闭连接 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtil.close(conn, ps, rs); &#125; return null; &#125;&#125; BeanUtils需要导包，commons-beanutils-1.9.4.jar &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 如果需要连接oracle，则jdbcUtil需要改改配置 导入jquery，使用ajax，下载网址配置webservlet 我这里@WebServlet注解爆红，导入javax.servlet-api-3.1.0.jar包后解决看到有博客说servlet.jar也可以，不过我就导入了javax.servlet-api-3.1.0.jar就已解决注释掉SubHandle内的super.doPost(req, resp);即可，记得重启服务 前端之前一直接受不到数据既不执行success也不执行error，是因为后端的返回格式不是json","categories":[{"name":"jsp","slug":"jsp","permalink":"https://isunderachiever.github.io/categories/jsp/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"https://isunderachiever.github.io/tags/jsp/"}]},{"title":"创建Vue项目","slug":"编程语言/Vue/Vue2/创建vue项目","date":"2023-03-21T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/vue/vue2/chuang-jian-vue-xiang-mu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/vue/vue2/chuang-jian-vue-xiang-mu.html","excerpt":"","text":"创建Vue项目Vue脚手架的安装与卸载 安装、卸载vue-cli2命令 npm install vue-cli -gnpm uninstall vue-cli -g 安装、卸载vue-cli3命令 npm install @vue/cli -gnpm uninstall @vue/cli -g Vue项目创建# 创建一个名为demo-vue的项目vue create demo-vue Element-UI# 安装# npm i element-ui -Svue add element# 引入Elementimport Vue from &#x27;vue&#x27;;import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;import App from &#x27;./App.vue&#x27;;Vue.use(ElementUI);new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;); axiosnpm install axios -s// 配置request.js-------------------------import axios from &#x27;axios&#x27;const request = axios.create(&#123; // baseURL: &#x27;/api&#x27;, // 注意！！ 这里是全局统一加上了 &#x27;/api&#x27; 前缀，也就是说所有接口都会加上&#x27;/api&#x27;前缀在，页面里面写接口的时候就不要加 &#x27;/api&#x27;了，否则会出现2个&#x27;/api&#x27;，类似 &#x27;/api/api/user&#x27;这样的报错，切记！！！ timeout: 5000&#125;)// request 拦截器// 可以自请求发送前对请求做一些处理// 比如统一加token，对请求参数统一加密request.interceptors.request.use(config =&gt; &#123; config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=utf-8&#x27;; // config.headers[&#x27;token&#x27;] = user.token; // 设置请求头 return config&#125;, error =&gt; &#123; return Promise.reject(error)&#125;);// response 拦截器// 可以在接口响应后统一处理结果request.interceptors.response.use( response =&gt; &#123; let res = response.data; // 如果是返回的文件 if (response.config.responseType === &#x27;blob&#x27;) &#123; return res &#125; // 兼容服务端返回的字符串数据 if (typeof res === &#x27;string&#x27;) &#123; res = res ? JSON.parse(res) : res &#125; return res; &#125;, error =&gt; &#123; console.log(&#x27;err&#x27; + error) // for debug return Promise.reject(error) &#125;)export default request// 配置vue.config.js------------------------------------// 跨域配置module.exports = &#123; devServer: &#123; //记住，别写错了devServer//设置本地默认端口 选填 port: 9876, proxy: &#123; //设置代理，必须填 &#x27;/api&#x27;: &#123; //设置拦截器 拦截器格式 斜杠+拦截器名字，名字可以自己定 target: &#x27;http://localhost:9999&#x27;, //代理的目标地址 changeOrigin: true, //是否设置同源，输入是的 pathRewrite: &#123; //路径重写 &#x27;^/api&#x27;: &#x27;&#x27; //选择忽略拦截器里面的内容 &#125; &#125; &#125; &#125;&#125; qsnpm install qs// 在main.js中配置import qs from &#x27;qs&#x27;Vue.prototype.qs=qs vue-cookienpm install vue-cookie --save// main.js lodashnpm i -save lodash // 全局安装import cloneDeep from &#x27;lodash/cloneDeep&#x27; mockjsnpm install mockjs -D vuex-persistedstate参考博客1参考博客2 npm i vuex-persistedstate --save","categories":[{"name":"vue","slug":"vue","permalink":"https://isunderachiever.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://isunderachiever.github.io/tags/vue/"}]},{"title":"SpringMVC","slug":"编程语言/Java/学习/框架/SpringMVC/SpringMVC","date":"2023-03-19T10:00:00.000Z","updated":"2024-06-01T14:32:53.451Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springmvc/springmvc.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springmvc/springmvc.html","excerpt":"","text":"SpringMVC spring-mvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- SpringMVC只扫描controller包即可 --&gt; &lt;context:component-scan base-package=&quot;com.example.controller&quot;/&gt; &lt;!-- 解决静态资源访问问题，如果不加mvc:annotation-driven会导致无法访问handler--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--解决响应乱码--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;utf-8&quot;/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 为DispatcherServlet提供初始化参数的 设置springmvc配置文件的路径 name是固定的，必须是contextConfigLocation value指的是SpringMVC配置文件的位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 指定项目启动就初始化DispatcherServlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- / 表示当前servlet映射除jsp之外的所有请求（包含静态资源） *.do 表示.do结尾的请求路径才能被SpringMVC处理(老项目会出现) /* 表示当前servlet映射所有请求（包含静态资源,jsp），不应该使用其配置DispatcherServlet --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--乱码处理过滤器，由SpringMVC提供--&gt; &lt;!-- 处理post请求乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- name固定不变，value值根据需要设置 --&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;!-- 所有请求都设置utf-8的编码 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springmvc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--不能漏--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jsp依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springmvc依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;!-- &lt;build&gt;--&gt;&lt;!-- &lt;plugins&gt;--&gt;&lt;!-- &lt;plugin&gt;--&gt;&lt;!-- &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;2.2&lt;/version&gt;--&gt;&lt;!-- &lt;configuration&gt;--&gt;&lt;!-- &lt;port&gt;8000&lt;/port&gt;--&gt;&lt;!-- &lt;path&gt;/&lt;/path&gt;--&gt;&lt;!-- &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;--&gt;&lt;!-- &lt;/configuration&gt;--&gt;&lt;!-- &lt;/plugin&gt;--&gt;&lt;!-- &lt;/plugins&gt;--&gt;&lt;!-- &lt;/build&gt;--&gt;&lt;/project&gt; 指定请求参数 必须有code参数 @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testParams&quot;,method = RequestMethod.GET,params = &quot;code&quot;) public String testParams()&#123; System.out.println(&quot;testParams处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 不能有code参数 @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testParams&quot;,method = RequestMethod.GET,params = &quot;!code&quot;) public String testParams()&#123; System.out.println(&quot;testParams处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; code参数必须是某个值 @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testParams&quot;,method = RequestMethod.GET,params = &quot;code=sgct&quot;) public String testParams()&#123; System.out.println(&quot;testParams处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; code参数参数必须不是某个值 @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testParams&quot;,method = RequestMethod.GET,params = &quot;code!=sgct&quot;) public String testParams()&#123; System.out.println(&quot;testParams处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 指定请求头 请求头必须有deviceType @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testHeaders&quot;,method = RequestMethod.GET,headers = &quot;deviceType&quot;) public String testHeaders()&#123; System.out.println(&quot;testHeaders处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 请求头不能有deviceType @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testHeaders&quot;,method = RequestMethod.GET,headers = &quot;!deviceType&quot;) public String testHeaders()&#123; System.out.println(&quot;testHeaders处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 请求头中的deviceType必须为aaa @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testHeaders&quot;,method = RequestMethod.GET,headers = &quot;deviceType=aaa&quot;) public String testHeaders()&#123; System.out.println(&quot;testHeaders处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 请求头中的deviceType不能是aaa @Controller@RequestMapping(&quot;/test&quot;)public class TestController &#123; @RequestMapping(value = &quot;/testHeaders&quot;,method = RequestMethod.GET,headers = &quot;deviceType!=aaa&quot;) public String testHeaders()&#123; System.out.println(&quot;testHeaders处理了请求&quot;); return &quot;/success.jsp&quot;; &#125;&#125; 常用注解 PathVariable RequestBody RequestParam required @RequestParam(value &#x3D; “id”,required &#x3D; false) 代表是否必须，默认值为true也就是必须要有对应的参数。如果没有就会报错。 如果对应的参数可传可不传则可以把去设置为fasle例如： @RequestMapping(&quot;/testRquestParam&quot;)public String testRquestParam(@RequestParam(value = &quot;id&quot;,required = false) Integer uid,@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;likes&quot;)String[] likes)&#123; System.out.println(&quot;testRquestParam&quot;); System.out.println(uid); System.out.println(name); return &quot;/success.jsp&quot;;&#125; @RequestParam(value &#x3D; “id”,required &#x3D; false,defaultValue &#x3D; “777”) defaultValue 如果对应的参数没有，我们可以用defaultValue属性设置默认值。例如： @RequestMapping(&quot;/testRquestParam&quot;)public String testRquestParam(@RequestParam(value = &quot;id&quot;,required = false,defaultValue = &quot;777&quot;) Integer uid,@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;likes&quot;)String[] likes)&#123; System.out.println(uid); System.out.println(name); return &quot;/success.jsp&quot;;&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://isunderachiever.github.io/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://isunderachiever.github.io/tags/SpringMVC/"}]},{"title":"MyBatis","slug":"编程语言/Java/学习/框架/ORM/MyBatis","date":"2023-03-19T00:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/orm/mybatis.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/orm/mybatis.html","excerpt":"","text":"MyBatis 使用以下sql新建表(我使用的是oracle数据库，而非mysql) 使用之前提过的自动生成方式生成对应的实体类和mapper -- 创建用户表create table tb_people( id varchar2(50) primary key, name varchar2(30), gender number(1), age number(3) check ( age &gt; 0 ));-- 创建手机表create table tb_phone( id varchar2(50) primary key, name varchar2(20), brand varchar2(20), price number(10, 2));-- 创建 用户-手机详情表create table tb_people_phone_detail( people_id varchar2(50), phone_id varchar2(50), primary key (people_id, phone_id));commit;select *from tb_people;select *from tb_phone;select *from tb_people_phone_detail;-- 添加表注释comment on table tb_people is &#x27;用户表&#x27;;comment on table tb_phone is &#x27;手机表&#x27;;comment on table tb_people_phone_detail is &#x27;用户-手机详情表&#x27;;-- 添加字段注释comment on column tb_people.id is &#x27;用户主键&#x27;;comment on column tb_people.name is &#x27;用户姓名&#x27;;comment on column tb_people.gender is &#x27;用户性别&#x27;;comment on column tb_people.age is &#x27;用户年龄&#x27;;comment on column tb_phone.id is &#x27;手机主键&#x27;;comment on column tb_phone.name is &#x27;手机名称&#x27;;comment on column tb_phone.brand is &#x27;手机品牌&#x27;;comment on column tb_phone.price is &#x27;手机价格&#x27;;comment on column tb_people_phone_detail.people_id is &#x27;用户主键&#x27;;comment on column tb_people_phone_detail.phone_id is &#x27;手机主键&#x27;; 添加依赖 &lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt;&lt;/dependency&gt;&lt;!--oracle--&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;!--junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- hutool --&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt;&lt;/dependency&gt; # 数据库驱动：jdbc.driver=oracle.jdbc.driver.OracleDriver# 数据库连接地址jdbc.url=jdbc:oracle:thin:@localhost:1521:orcl# 数据库用户名&amp;密码：jdbc.username=rootjdbc.password=123456 # 控制台打印log4j.rootLogger=debug, stdoutlog4j.logger.org.mybatis.example.BlogMapper=TRACElog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n# 输出到文件log4j.appender.file=org.apache.log4j.ConsoleAppenderlog4j.appender.file.File=C:\\Users\\tong\\Desktop\\log4jlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置文件所在路径--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;settings&gt; &lt;!-- 打印sql日志 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!--别名配置--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.example.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--指定包--&gt; &lt;package name=&quot;com.example.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; public class ApplicationTest &#123; private SqlSession session; @Before public void init() throws IOException &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); session=sqlSessionFactory.openSession(); &#125; @After public void destory()&#123; // 提交事务，并释放资源 session.commit(); session.close(); &#125;&#125;#{}和${}的区别如果使用#{}，他是预编译的sq可以防止SQL注入攻击如果使用${}，他是直接把参数值拿来进行拼接，这样会有SQL注入的危险SQL片段抽取&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.PeopleMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.domain.People&quot;&gt; &lt;id column=&quot;ID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;GENDER&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;AGE&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; ID , NAME, GENDER, AGE &lt;/sql&gt; &lt;!-- 查询全部用户 --&gt; &lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;/select&gt;&lt;/mapper&gt;mapper.xml 标签 if trim where set foreach choose if &lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people where id = #&#123;id&#125; &lt;if test=&quot;name!=null&quot;&gt; and name = #&#123;name&#125; &lt;/if&gt;&lt;/select&gt; trim &lt;!-- 清除前缀 --&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;trim prefixOverrides=&quot;and|or&quot;&gt; and &lt;/trim&gt;&lt;/select&gt; &lt;!-- 清除后缀 --&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;trim suffixOverrides=&quot;like&quot;&gt; where 1=1 like &lt;/trim&gt;&lt;/select&gt; &lt;!-- 添加前缀 --&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;trim prefix=&quot;where&quot;&gt; 1=1 &lt;/trim&gt;&lt;/select&gt; &lt;!-- 添加后缀 --&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;trim prefix=&quot;1=1&quot;&gt; where &lt;/trim&gt;&lt;/select&gt; &lt;!-- 综合使用 --&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name = #&#123;name&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; where &lt;!--where 标签等价于 trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot;--&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt;select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;where&gt; &lt;if test=&quot;id!=null&quot;&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt; and name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; set &lt;!-- set 标签等价于 trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; --&gt;&lt;update id=&quot;updatePeople&quot;&gt; update people &lt;set&gt; &lt;if test=&quot;name!=null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;gender!=null&quot;&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; foreach select * from people where id in (?,?,?,?); &lt;!--ids 为接口内接收的参数名称--&gt;&lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;where&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; choose 类似于java的switch、case、default 如果id不为空，则通过id查询 如果id为空，名称不为空，则通过名称查询 如果id和名称都为空，则查询id为3的用户 &lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt; id = #&#123;id&#125; &lt;/when&gt; &lt;when test=&quot;name!=null&quot;&gt; name = #&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt; id = 3 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 字段映射问题 // 先插入几条数据@Testpublic void addPeople()&#123; PeopleMapper peopleMapper=session.getMapper(PeopleMapper.class); peopleMapper.insert(new People(IdUtil.simpleUUID(),&quot;李华&quot;,1,15)); peopleMapper.insert(new People(IdUtil.simpleUUID(),&quot;张三&quot;,1,25)); peopleMapper.insert(new People(IdUtil.simpleUUID(),&quot;王大锤&quot;,1,26)); peopleMapper.insert(new People(IdUtil.simpleUUID(),&quot;翠花&quot;,0,18));&#125;@Testpublic void addPhone()&#123; PhoneMapper phoneMapper = session.getMapper(PhoneMapper.class); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),&quot;k30&quot;,&quot;红米&quot;,BigDecimal.valueOf(3000))); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),&quot;note 11t&quot;,&quot;红米&quot;,BigDecimal.valueOf(4000))); phoneMapper.insert(new Phone(IdUtil.simpleUUID(),&quot;mate 50&quot;,&quot;华为&quot;,BigDecimal.valueOf(5000)));&#125;@Testpublic void addPeoplePhoneDetail()&#123; PeoplePhoneDetailMapper peoplePhoneDetailMapper=session.getMapper(PeoplePhoneDetailMapper.class); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(&quot;b0e11aed0db6412ebf342dc9676b5ba6&quot;,&quot;1cff22c9409c44fd8524ea9c4d6e3385&quot;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(&quot;b0e11aed0db6412ebf342dc9676b5ba6&quot;,&quot;639153d49e0d4d33af43e4d4534b1631&quot;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(&quot;6f226961637346ec82499567122e00ea&quot;,&quot;2b1edb7c93f04d7d91fc8200378a2c94&quot;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(&quot;672b002417de41d184d7d14f31660e9f&quot;,&quot;639153d49e0d4d33af43e4d4534b1631&quot;)); peoplePhoneDetailMapper.insert(new PeoplePhoneDetail(&quot;de32b418f26e475aa68ef2f692e58cb6&quot;,&quot;1cff22c9409c44fd8524ea9c4d6e3385&quot;));&#125; 如 数据库 people_id 字段无法映射到 java 里peopleId，即驼峰命名法解决方法1：在mybatis里开启驼峰命名的自动映射 &lt;settings &lt;!-- 打印sql日志 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;!-- 配置驼峰映射 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 解决方法2：在sql里配置别名 select people_id peopleId,phone_id phoneId from tb_people_phone_detail 解决方法3：自定义映射规则(继承映射规则)问题正确展示多表查询 一对一&gt; 可以看到这是一个一对多的关系，但是就以张三作为演示，张三的关系是一对一的&gt;&gt; 首先需要明确通过什么来查什么？&gt;&gt; 我们现在需要通过使用者来查询他的手机，所以需要在使用者的属性里新建一个手机&gt;&gt; 别忘了生成对应属性的get、set等方法哦#### 关联查询&gt; 先测试一下sql是否正确select tb_people.id &quot;id&quot;, tb_people.name &quot;name&quot;, tb_people.gender &quot;gender&quot;, tb_people.age &quot;age&quot;, tb_phone.id &quot;phone_id&quot;, tb_phone.name &quot;phone_name&quot;, tb_phone.brand &quot;phone_brand&quot;, tb_phone.price &quot;phone_price&quot;from tb_people, tb_people_phone_detail, tb_phonewhere tb_people.id = tb_people_phone_detail.people_id(+) and tb_people_phone_detail.phone_id = tb_phone.id(+) and tb_people.id = &#x27;6f226961637346ec82499567122e00ea&#x27;写法1写法2&gt; 以上两种写法都能查询到结果### 一对多&gt; 接下来测试一对多，将Phone phone 改成List&lt;Phone&gt; phones&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.PeopleMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.domain.People&quot;&gt; &lt;id column=&quot;ID&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;GENDER&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;AGE&quot; jdbcType=&quot;DECIMAL&quot; property=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; ID , NAME, GENDER, AGE &lt;/sql&gt; &lt;resultMap id=&quot;PeoplePhonesResultMap&quot; type=&quot;com.example.domain.People&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;collection property=&quot;phones&quot; ofType=&quot;com.example.domain.Phone&quot;&gt; &lt;id column=&quot;phone_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;phone_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;phone_brand&quot; property=&quot;brand&quot;/&gt; &lt;result column=&quot;phone_price&quot; property=&quot;price&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 根据用户id查询 --&gt; &lt;select id=&quot;selectPeopleWithPhones&quot; resultType=&quot;com.example.domain.People&quot;&gt; select tb_people.id &quot;id&quot;, tb_people.name &quot;name&quot;, tb_people.gender &quot;gender&quot;, tb_people.age &quot;age&quot;, tb_phone.id &quot;phone_id&quot;, tb_phone.name &quot;phone_name&quot;, tb_phone.brand &quot;phone_brand&quot;, tb_phone.price &quot;phone_price&quot; from tb_people, tb_people_phone_detail, tb_phone where tb_people.id = tb_people_phone_detail.people_id(+) and tb_people_phone_detail.phone_id = tb_phone.id(+) and tb_people.id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 查询全部用户 --&gt; &lt;select id=&quot;selectPeople&quot; resultType=&quot;com.example.domain.People&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from tb_people &lt;/select&gt;&lt;/mapper&gt;### 分步查询&gt; 分布查询也可以完成以上操作&gt;&gt; 我们分为两个select操作&gt;&gt; 1. 查找到对应的手机id(可能是多部)&gt; 2. 根据手机id查找到对应的手机&gt; 在方法上右键，选择copy reference将id作为参数传给findRoleByUserId方法&gt; 查看打印的日志&gt;&gt; 可以看到执行了两个sql分布查询里的按需加载&gt; 这里我们只打印输出了人的id，并没有涉及到手机的信息，所以只执行了一个sql语句分页查询&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;mybatis-test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--oracle--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--hutool--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--pagehelper--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; pagehelper的版本不要太高，否则匹配会出现问题 @Testpublic void test2()&#123;PeopleMapper peopleMapper = session.getMapper(PeopleMapper.class); // 设置分页查询参数 PageHelper.startPage(1,2); List&lt;People&gt; peopleList = peopleMapper.selectPeople(); PageInfo&lt;People&gt; pageInfo = new PageInfo&lt;&gt;(peopleList); // 总条数 long total = pageInfo.getTotal(); // 总页数 int pages = pageInfo.getPages(); // 当前页 int pageNum = pageInfo.getPageNum(); // 每页显示长度 int pageSize = pageInfo.getPageSize(); System.out.println(&quot;总条数:&quot;+total); System.out.println(&quot;总页数:&quot;+pages); System.out.println(&quot;当前页:&quot;+pageNum); System.out.println(&quot;每页显示长度:&quot;+pageSize);&#125; 分页查询可能出现的问题 在一对多的多表查询中，pagehelper可能会出现数据显示不全的问题，这种情况使用分布查询即可解决MyBatis缓存 一级缓存 一级缓存是默认开启的几种不会使用一级缓存的情况 调用相同方法但是传入的参数不同 调用相同方法参数也相同，但是使用的是另外一个SqISession 如果查询完后，对同一个表进行了增，删改的操作，都会清空这sqlSession上的缓存 如果手动调用SqlSession的clearCache方法清除缓存了，后面也使用不了缓存 二级缓存注意:只有close或者commit后的数据才会进入二级缓存。#### 开启二级缓存1. 全局开启 &gt; 在mybatis配置文件中配置 &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;2. 局部开启 &gt; 在mapper.xml里配置cache标签 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.PeopleMapper&quot;&gt; &lt;cache/&gt;&lt;/mapper&gt;需要注意的问题 一般不用二级缓存，一级缓存是session级，而二级缓存是mapper级，即便是一个新的sqlSession，也可以获取到之前缓存里的数据，可能导致数据更改后未更新的情况 mapper里的注释不要写在sql里","categories":[{"name":"ORM框架","slug":"ORM框架","permalink":"https://isunderachiever.github.io/categories/ORM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://isunderachiever.github.io/tags/MyBatis/"}]},{"title":"AOT学习","slug":"编程语言/Java/学习/框架/Spring/Spring6/AOT学习","date":"2023-03-16T10:00:00.000Z","updated":"2024-06-01T14:32:53.508Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/aot-xue-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/aot-xue-xi.html","excerpt":"","text":"AOT学习AOT学习 选自 尚硅谷Spring6教程 JIT just in time，动态编译(实时编译)，边运行边编译 在程序运行时候，动态生成代码 启动时比较慢，编译时需要占用运行时候资源 总结：程序运行过程中，把字节码转换成硬盘上直接运行的机器码，部署到环境的过程 AOT ahead of time，运行前编译，提前编译 可以把源代码直接转换成机器码，启动快，内存占用低 缺点:运行时不能优化，程序安装时间过长 总结：在程序运行之前，就把字节码转换成机器码 11.1.1、JIT与AOT的区别JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译（1）JIT， Just-in-time,动态(即时)编译，边运行边编译；在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。（2）AOT，Ahead Of Time，指运行前编译，预先编译。AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。简单来讲：JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 .java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据） （3）AOT的优点简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能，程序启动速度快运行产物只有机器码，打包体积小AOT的缺点由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。 11.1.2、GraalvmSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。GraalVM 具有以下特性：（1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源（2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能（3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销（4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。 11.1.3、Native Image目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C&#x2F;C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C&#x2F;C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。 11.2、演示Native Image构建过程11.2.1、GraalVM安装（1）下载GraalVM进入官网下载：https://www.graalvm.org/downloads/ （2）配置环境变量添加GRAALVM_HOME把JAVA_HOME修改为graalvm的位置把Path修改位graalvm的bin位置使用命令查看是否安装成功 （3）安装native-image插件使用命令 gu install native-image下载安装 11.2.2、安装C++的编译环境（1）下载Visual Studio安装软件https://visualstudio.microsoft.com/zh-hans/downloads/ （2）安装Visual Studio （3）添加Visual Studio环境变量配置INCLUDE、LIB和Path （4）打开工具，在工具中操作 11.2.3、编写代码，构建Native Image（1）编写Java代码public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125;&#125; （2）复制文件到目录，执行编译 （3）Native Image 进行构建 （4）查看构建的文件 （5）执行构建的文件可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C&#x2F;C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的： 如果报错如下原因，权限不够，以管理员权限启动即可环境配置 如果想像这样添加多行，那么在添加第一行的时候，加一个英文的分号，即 ; INCLUDED:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrtC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\umC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\shared LIBC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\um\\x64C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22000.0\\ucrt\\64D:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64 pathD:\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.35.32215\\bin\\Hostx64\\x64 java环境变量 从D:\\java\\jdk改为D:\\graalvm-ce-java17-22.3.0","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"}],"tags":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"}]},{"title":"Idea新建SSM项目","slug":"编程语言/Java/学习/框架/SSM/Idea新建SSM项目","date":"2023-03-15T10:00:00.000Z","updated":"2024-06-01T14:32:53.451Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/ssm/idea-xin-jian-ssm-xiang-mu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/ssm/idea-xin-jian-ssm-xiang-mu.html","excerpt":"","text":"idea新建ssm项目&gt; 打开project structure，选择web后点击ok&gt; 将web文件夹移入main下，并改名为webapp&gt; 修改pom文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Hutool--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--LomBok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring+SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;!-- Exclude Commons Logging in favor of SLF4j --&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 事务管理 --&gt; &lt;!-- Spring的jdbc模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 做jdbc的连接管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--分页查询--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis-Spring连接包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.4.5&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--commons文件上传，如果需要文件上传功能，需要添加本依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;测试&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mybatis_test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;mybatis_test Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Hutool--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--LomBok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring+SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;!-- Exclude Commons Logging in favor of SLF4j --&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 事务管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring的jdbc模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 做jdbc的连接管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis-Spring连接包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.13&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://isunderachiever.github.io/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://isunderachiever.github.io/tags/SSM/"}]},{"title":"拦截器","slug":"报错记录/SpringBoot/拦截器","date":"2023-03-14T12:30:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/springboot/lan-jie-qi.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/springboot/lan-jie-qi.html","excerpt":"","text":"拦截器 问题起因：明明已将放行过测试的路径了，页面也能正常获取到数据，拦截器里的sout却依然有两次输出输出了一下请求路径，发现如下参考博客至于为什么会请求error，应该是没有找到favicon.ico的请求解决方法如下 放过favicon.ico请求 static里增加一个图标即可","categories":[{"name":"拦截器","slug":"拦截器","permalink":"https://isunderachiever.github.io/categories/%E6%8B%A6%E6%88%AA%E5%99%A8/"}],"tags":[{"name":"拦截器","slug":"拦截器","permalink":"https://isunderachiever.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"Spring6学习04","slug":"编程语言/Java/学习/框架/Spring/Spring6/04_Spring6","date":"2023-03-14T10:00:00.000Z","updated":"2024-06-01T14:32:53.508Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/04-spring6.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/04-spring6.html","excerpt":"","text":"Spring6学习04手写IOC 实现过程 创建子模块 创建测试类 创建两个注解 @Bean(代替@Component) @Di(代替@Autowired) 创建Bean容器接口ApplicationContext，定义方法，返回对象 实现Bean容器接口 返回对象 根据包规则加载bean 规则:扫描当前包及其子包里的所有类，判断类上是否有@Bean注解，如果有，则把这个类通过反射实例化 第一步，搭建项目创建两个注解，@Bean、@Di import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125; 使用如下方式进行注入 @Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao;&#125; 新建ApplicationContext接口 public interface ApplicationContext &#123; Object getBean(Class&lt;?&gt; clazz);&#125; 对接口进行实例化 import java.util.HashMap;import java.util.Map;public class AnnotationApplicationContext implements ApplicationContext&#123; // 创建Map集合，用于存放Bean对象 private Map&lt;Class&lt;?&gt;,Object&gt; beanFactory=new HashMap&lt;&gt;(); /** * 返回bean对象 */ @Override public Object getBean(Class&lt;?&gt; clazz) &#123; return beanFactory.get(clazz); &#125; /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) &#123; // &#125;&#125; 为什么要写AnnotationApplicationContext的构造方法？ 我们先来看看原本Spring是怎么写的以下是暂时的项目结构 第二步，配置扫描规则 用法应该如下所示 public class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationApplicationContext(&quot;com.example&quot;); Object bean = context.getBean(UserDaoImpl.class); &#125;&#125; 将.替换成\\ （com.example）-&gt;（com\\example） 获取包的(带盘符的)对路径 （这里的绝对路径并非是当前类的绝对路径，而是编译后生成的target内的类路径） 由于转义字符的影响，所以得这么写 如果不放心，可以试着打印输出一下 String packagePath = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); public class AnnotationApplicationContext implements ApplicationContext &#123; // 创建Map集合，用于存放Bean对象 private Map&lt;Class&lt;?&gt;, Object&gt; beanFactory = new HashMap&lt;&gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class&lt;?&gt; clazz) &#123; return beanFactory.get(clazz); &#125; /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) &#123; // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); try &#123; // 2. 获取包的绝对路径 Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;); // 获取包前面的路径部分，字符串截取 rootPath=filePath.substring(0,filePath.length()-packagePath.length()); // 包扫描 loadBean(new File(filePath)); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 包扫描过程 * 实例化 */ private void loadBean(File file) &#123; // 1.判断当前是否是文件夹 // 2.获取文件夹里的所有内容(文件夹、文件) // 3.若文件夹里为空，直接返回 // 4.文件夹不为空，遍历文件夹所有内容 // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 // 4.4判断当前类型是否是.class // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.7把对象实例化之后，放到map集合beanFactory // 小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key &#125;&#125; 第三步，配置包扫描过程 步骤 判断当前是否是文件夹 获取文件夹里的所有内容(文件夹、文件) 若文件夹里为空，直接返回 文件夹不为空，遍历文件夹所有内容4.1 遍历得到每个File对象，递归判断文件夹里是否还有文件夹…4.2 遍历得到File对象不是文件夹，是文件4.3 得到【包路径+类名称】部分-字符串截取4.4 判断当前类型是否是.class4.5 如果是.class类型，就把\\替换成. 并 去掉后缀.class com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射4.6 判断类上是否有注解@Bean，如果有，实例化过程4.7 把对象实例化之后，放到map集合beanFactory小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key public class AnnotationApplicationContext implements ApplicationContext &#123; // 创建Map集合，用于存放Bean对象 private Map&lt;Class&lt;?&gt;, Object&gt; beanFactory = new HashMap&lt;&gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class&lt;?&gt; clazz) &#123; return beanFactory.get(clazz); &#125; /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) &#123; // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); try &#123; // 2. 获取包的绝对路径 Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;); // 获取包前面的路径部分，字符串截取 rootPath=filePath.substring(0,filePath.length()-packagePath.length()); // 包扫描 loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 包扫描过程 * 实例化 */ private void loadBean(File file) throws Exception &#123; // 1.判断当前是否是文件夹 if(file.isDirectory())&#123; // 2.获取文件夹里的所有内容(文件夹、文件) File[] childrenFiles = file.listFiles(); // 3.若文件夹里为空，直接返回 if(childrenFiles==null||childrenFiles.length==0)&#123; return; &#125; // 4.文件夹不为空，遍历文件夹所有内容 for(File child:childrenFiles)&#123; // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... if(child.isDirectory())&#123; // 递归 loadBean(child); &#125;else&#123; // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); // 4.4判断当前类型是否是.class if(pathWithClass.contains(&quot;.class&quot;))&#123; // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 String allName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.6.1获取类的class对象 Class&lt;?&gt; clazz = Class.forName(allName); // 4.6.2判断，如果不是接口，则实例化 if(!clazz.isInterface())&#123; // 4.6.3判断，类上是否有注解@Bean Bean annotation = clazz.getAnnotation(Bean.class); if(annotation!=null)&#123; // 类上@Bean有注解 // 4.6.4实例化 Object instance = clazz.getConstructor().newInstance(); // 4.7把对象实例化之后，放到map集合beanFactory // 4.7.1小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key if(clazz.getInterfaces().length&gt;0)&#123; beanFactory.put(clazz.getInterfaces()[0],instance); &#125;else&#123; beanFactory.put(clazz,instance); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 第四步，测试@Bean注解public interface UserDao &#123; void insert();&#125; @Beanpublic class UserDaoImpl implements UserDao &#123; @Override public void insert() &#123; System.out.println(&quot;userDao--insert&quot;); &#125;&#125; public interface UserService &#123; void add();&#125; @Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void add() &#123; System.out.println(&quot;service--add&quot;); // TODO 调用dao的方法 &#125;&#125; public class Main &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationApplicationContext(&quot;com.example&quot;); UserService userService = (UserService) context.getBean(UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 第五步，编写@Di注解属性注入逻辑 实例化对象在beanFactory的map集合里1.遍历beanFactory的map集合2.获取map集合每个对象(value)，每个对象的属性获取到3.遍历得到每个对象属性数组，得到每个属性4.属性上是否有@Di的注解(如果是私有属性，需要设置为【可以设置值】)5.如果有@Di的注解，把对象注入 public class AnnotationApplicationContext implements ApplicationContext &#123; // 创建Map集合，用于存放Bean对象 private Map&lt;Class&lt;?&gt;, Object&gt; beanFactory = new HashMap&lt;&gt;(); private String rootPath; /** * 返回bean对象 */ @Override public Object getBean(Class&lt;?&gt; clazz) &#123; return beanFactory.get(clazz); &#125; /** * 创建有参构造方法，传递包路径，设置包扫描规则 * 当前包及其子包，标注有@Bean注解，把这个类通过反射实例化 * * @param basePackage 包路径 */ public AnnotationApplicationContext(String basePackage) &#123; // com.example // 1. 将.替换成\\ String packagePath = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); try &#123; // 2. 获取包的绝对路径 Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath); // 遍历枚举对象 while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); // 斜杠会做url编码，所以要进行转码 String filePath = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;); // 获取包前面的路径部分，字符串截取 rootPath = filePath.substring(0, filePath.length() - packagePath.length()); // 包扫描 loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // 属性注入 loadDi(); &#125; /** * 属性注入 */ private void loadDi() &#123; // 实例化对象在beanFactory的map集合里 // 1.遍历beanFactory的map集合 Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = beanFactory.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; // 2.获取map集合每个对象(value)，每个对象的属性获取到 Object obj = entry.getValue(); // 获取对象class Class&lt;?&gt; clazz = obj.getClass(); // 获取每个对象中的属性 Field[] declaredFields = clazz.getDeclaredFields(); // 3.遍历得到每个对象属性数组，得到每个属性 for (Field field : declaredFields) &#123; // 4.属性上是否有@Di的注解(如果是私有属性，需要设置为【可以设置值】) Di annotation = field.getAnnotation(Di.class); if (annotation != null) &#123; // 属性上有@Di注解 // 如果是私有属性，需要设置为【可设置值】 field.setAccessible(true); // 5.如果有@Di的注解，把对象注入 System.out.println(&quot;类型:&quot;+field.getType()); try &#123; field.set(obj, beanFactory.get(field.getType())); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125; &#125; /** * 包扫描过程 * 实例化 */ private void loadBean(File file) throws Exception &#123; // 1.判断当前是否是文件夹 if (file.isDirectory()) &#123; // 2.获取文件夹里的所有内容(文件夹、文件) File[] childrenFiles = file.listFiles(); // 3.若文件夹里为空，直接返回 if (childrenFiles == null || childrenFiles.length == 0) &#123; return; &#125; // 4.文件夹不为空，遍历文件夹所有内容 for (File child : childrenFiles) &#123; // 4.1遍历得到每个File对象，递归判断文件夹里是否还有文件夹... if (child.isDirectory()) &#123; // 递归 loadBean(child); &#125; else &#123; // 4.2遍历得到File对象不是文件夹，是文件 // 4.3得到【包路径+类名称】部分-字符串截取 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); // 4.4判断当前类型是否是.class if (pathWithClass.contains(&quot;.class&quot;)) &#123; // 4.5如果是.class类型，就把\\替换成. 并 去掉后缀.class // com.example.service.UserServiceImpl 因为只有获取类全路径名才能使用反射 String allName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); // 4.6判断类上是否有注解@Bean，如果有，实例化过程 // 4.6.1获取类的class对象 Class&lt;?&gt; clazz = Class.forName(allName); // 4.6.2判断，如果不是接口，则实例化 if (!clazz.isInterface()) &#123; // 4.6.3判断，类上是否有注解@Bean Bean annotation = clazz.getAnnotation(Bean.class); if (annotation != null) &#123; // 类上@Bean有注解 // 4.6.4实例化 Object instance = clazz.getConstructor().newInstance(); // 4.7把对象实例化之后，放到map集合beanFactory // 4.7.1小细节:如果有接口，就放接口class作为key，如果没有，就让自己class作为key if (clazz.getInterfaces().length &gt; 0) &#123; beanFactory.put(clazz.getInterfaces()[0], instance); &#125; else &#123; beanFactory.put(clazz, instance); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; @Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void add() &#123; System.out.println(&quot;service--add&quot;); // 调用dao的方法 userDao.insert(); &#125;&#125;","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"}],"tags":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"}]},{"title":"Spring6学习03","slug":"编程语言/Java/学习/框架/Spring/Spring6/03_Spring6","date":"2023-03-13T10:00:00.000Z","updated":"2024-06-01T14:12:24.950Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/03-spring6.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/03-spring6.html","excerpt":"","text":"Spring6学习03注解开发 引入依赖 开启组件扫描 &lt;dependencies&gt; &lt;!--spring ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt;&lt;/beans&gt; 以上的基本组件扫描是最常用的 同时还有以下两种组件扫描的写法指定要排除的组件 &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 仅扫描指定组件&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt;&gt; 定义bean&gt;&gt; 此时将以前的&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;这种写法更换为一下写法import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.stereotype.Component;@Data// 不写则默认是首字母小写，即user@Component(&quot;userEntity&quot;)@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age;&#125;public class ApplicationTest &#123; @Test public void test1()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 此处应该写component中写的名称，即userEntity User userEntity = context.getBean(&quot;userEntity&quot;, User.class); System.out.println(userEntity); &#125;&#125;### Autowired&gt; 1. 属性注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;public interface UserService &#123; public void userService1();&#125;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void userService1() &#123; System.out.println(&quot;userService1方法执行了...&quot;); userDao.userDao1(); &#125;&#125;public interface UserDao &#123; void userDao1();&#125;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Override public void userDao1() &#123; System.out.println(&quot;userDao1方法执行了...&quot;); &#125;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name;&#125;&gt; 2. set方法注入@Controllerpublic class UserController &#123; private UserService userService; // set方法注入 @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;&gt; 3. 构造方法注入@Controllerpublic class UserController &#123; private UserService userService; @Autowired public UserController(UserService userService) &#123; this.userService = userService; &#125; @Autowired public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;&gt; 4. 形参注入@Controllerpublic class UserController &#123; private UserService userService; public UserController(@Autowired UserService userService) &#123; this.userService = userService; &#125; @Autowired public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;&gt; 5. 只有一个有参构造函数，注解可以省略@Controllerpublic class UserController &#123; private UserService userService; public UserController(UserService userService) &#123; this.userService = userService; &#125; @Autowired public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;&gt; 必须只有一个有参的构造函数，若多一个无参构造函数，则报错&gt; @Controller不能省略若省略@Controller，也报错&gt; 6. Autowired+Qualifier联合注解&gt; 接口有多个实现类，用Qualifier来指定bean名称@Controllerpublic class UserController &#123; @Autowired // 指定bean名称 @Qualifier(&quot;userServiceImpl&quot;) private UserService userService; public UserController(UserService userService) &#123; this.userService = userService; &#125; @Autowired public void userController1()&#123; System.out.println(&quot;userController1方法已执行...&quot;); userService.userService1(); &#125;&#125;### Resource@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？* @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)* @Autowired注解是Spring框架自己的。* @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。* @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。* @Resource注解用在属性上、setter方法上。* @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;全注解开发全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。 package com.atguigu.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)@ComponentScan(&quot;com.atguigu.spring6&quot;)public class Spring6Config &#123;&#125; 测试类 @Testpublic void testAllAnnotation()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;);&#125;","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"}],"tags":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"}]},{"title":"SpringBoot后端开发流程","slug":"编程语言/Java/学习/框架/SpringBoot/SpringBoot后端开发流程","date":"2023-03-13T03:00:00.000Z","updated":"2024-06-01T14:32:53.431Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/springboot-hou-duan-kai-fa-liu-cheng.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/springboot-hou-duan-kai-fa-liu-cheng.html","excerpt":"","text":"SpringBoot后端开发流程 jwt生成以及解析token、拦截器、全局异常处理、自定义参数解析、跨域、参数校验依赖 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springbootTest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootTest&lt;/name&gt; &lt;description&gt;springbootTest&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;jjwt.version&gt;0.9.1&lt;/jjwt.version&gt; &lt;fastjson.version&gt;1.2.72&lt;/fastjson.version&gt; &lt;mybatis-plus.version&gt;3.5.1&lt;/mybatis-plus.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--jsr303--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/cn.easyproject/orai18n --&gt; &lt;!-- 如果数据库选用mysql则不需要此依赖，oracle则需要此依赖，不然后面会报错 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.easyproject&lt;/groupId&gt; &lt;artifactId&gt;orai18n&lt;/artifactId&gt; &lt;version&gt;12.1.0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--jjwt--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;$&#123;jjwt.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--oracle--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; create table tb_user( id number(10) primary key, nickname varchar2(20), username varchar2(20), password varchar2(20));insert into tb_user (id, nickname, username, password) values (1,&#x27;哈哈&#x27;,&#x27;admin&#x27;,&#x27;123456&#x27;);insert into tb_user (id, nickname, username, password) values (2,&#x27;呵呵&#x27;,&#x27;abcd&#x27;,&#x27;456&#x27;);insert into tb_user (id, nickname, username, password) values (3,&#x27;嘿嘿&#x27;,&#x27;aan&#x27;,&#x27;1234&#x27;);commit;select * from tb_user; jwtpackage com.example.demo.util;import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; JsonDatapackage com.example.demo.util;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class JsonData &#123; /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() &#123; return new JsonData(0, null, null); &#125; // 成功，传入数据 public static JsonData buildSuccess(Object data) &#123; return new JsonData(0, data, null); &#125; // 失败，传入描述信息 public static JsonData buildError(String msg) &#123; return new JsonData(-1, null, msg); &#125; // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) &#123; return new JsonData(code, null, msg); &#125;&#125; Rimport com.alibaba.fastjson.JSON;import com.alibaba.fastjson.TypeReference;import org.springframework.http.HttpStatus;import java.util.HashMap;import java.util.Map;/** * @author:93879 * @date:2023/06/09/23:31 * @description: */public class R extends HashMap&lt;String, Object&gt; &#123; private static final long serialVersionUID = 1L; /** * 存元素 和setData的区别是 这个方法可以指定key的值 */ @Override public R put(String key, Object value) &#123; super.put(key, value); return this; &#125; public R setData(Object data) &#123; put(&quot;data&quot;,data); return this; &#125; /** * 获取数据 * 远程调用服务时，另一个服务也会返回R类型的数据，这个方法可以获取key为data的value值 * 利用fastjson进行反序列化 */ public &lt;T&gt; T getData(TypeReference&lt;T&gt; typeReference) &#123; Object data = get(&quot;data&quot;); //默认是map String jsonString = JSON.toJSONString(data);//转为json字符串 T t = JSON.parseObject(jsonString, typeReference);//转为对象 return t; &#125; /** * 利用fastjson进行反序列化 */ public &lt;T&gt; T getData(String key,TypeReference&lt;T&gt; typeReference) &#123; Object data = get(key); //默认是map //转为json字符串 String jsonString = JSON.toJSONString(data);//转为json字符串 //转成需要的对象 T t = JSON.parseObject(jsonString, typeReference);//转为对象 return t; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; //无参构造 public R() &#123; put(&quot;code&quot;, 200); put(&quot;msg&quot;, &quot;success&quot;); &#125; //返回错误码500的错误，错误内容：未知异常，请联系管理员 public static R error() &#123; return error(HttpStatus.INTERNAL_SERVER_ERROR.value(), &quot;未知异常，请联系管理员&quot;); &#125; //返回错误码500的错误，错误内容需要自己传入 public static R error(String msg) &#123; return error(HttpStatus.INTERNAL_SERVER_ERROR.value(), msg); &#125; //返回自定义错误码，自定义错误内容 public static R error(int code, String msg) &#123; R r = new R(); r.put(&quot;code&quot;, code); r.put(&quot;msg&quot;, msg); return r; &#125; //返回正常，内容需要自己传入 public static R ok(String msg) &#123; R r = new R(); r.put(&quot;msg&quot;, msg); return r; &#125; //存入多条返回消息 public static R ok(Map&lt;String, Object&gt; map) &#123; R r = new R(); r.putAll(map); return r; &#125; //默认返回 0 success public static R ok() &#123; return new R(); &#125; //获取code（状态码）的值 public Integer getCode() &#123; return (Integer) this.get(&quot;code&quot;); &#125;&#125; 拦截器package com.example.demo.interceptor;import com.example.demo.util.JwtUtil;import io.jsonwebtoken.Claims;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 自定义拦截器 * * @author tong * @date 2023/03/13 */@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 先获取请求头里的token String token = request.getHeader(&quot;token&quot;); // token判空 if(StringUtils.isEmpty(token))&#123; System.out.println(&quot;这次的请求是：&quot;+request.getServletPath()); throw new RuntimeException(&quot;未登录，请登录后重试!&quot;); &#125; // token解析是否成功，若成功，则放行；否则，不放行 try &#123; Claims claims = JwtUtil.parseJWT(token); String subject = claims.getSubject(); System.out.println(&quot;sub:&quot;+subject); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;token解析错误，请稍后重试!&quot;); &#125; // 返回值代表是否放行 return true; &#125;&#125; package com.example.demo.config;import com.example.demo.interceptor.MyInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 拦截器配置 * * @author tong * @date 2023/03/13 */@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 添加拦截器 registry.addInterceptor(myInterceptor) // 添加拦截路径 .addPathPatterns(&quot;/**&quot;) // 配置排除路径 .excludePathPatterns(&quot;/user/login&quot;,&quot;/favicon.ico&quot;); &#125;&#125; 异常处理package com.example.demo.handler;import com.example.demo.util.JsonData;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvicepublic class AdviceController &#123; @ExceptionHandler(RuntimeException.class) public Object handlerException(Exception e)&#123; // 获取异常信息，并返回 return JsonData.buildError(e.getMessage()); &#125;&#125; 自定义参数解析 许多的请求都需要获取到请求头里的token进行解析，在每个请求里都写解析的代码吗？ 选用以下的自定义参数解析会好很多 package com.example.demo.resolver;import java.lang.annotation.*;/** * 自定义注解 * * @author tong * @date 2023/03/13 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.PARAMETER &#125;)public @interface CurrentUserId &#123;&#125; package com.example.demo.resolver;import com.example.demo.util.JwtUtil;import io.jsonwebtoken.Claims;import org.springframework.core.MethodParameter;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.bind.support.WebDataBinderFactory;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.ModelAndViewContainer;/** * 用户id参数解析器 * * @author tong * @date 2023/03/13 */@Componentpublic class UserIdArgumentResolver implements HandlerMethodArgumentResolver &#123; /** * 是否能使用当前的参数解析器进行解析 * @return 是否进行解析 */ @Override public boolean supportsParameter(MethodParameter parameter) &#123; // 如果参数上有CurrentUserId注解，则可以被解析，如果不包含，则不能被解析 return parameter.hasParameterAnnotation(CurrentUserId.class); &#125; /** * 进行参数解析的方法，可以在方法中获取对应的数据，然后把数据作为返回值返回，方法的返回值就会赋值给对应的方法参数 */ @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; // 获取请求头中的token String token = webRequest.getHeader(&quot;token&quot;); if(StringUtils.hasText(token))&#123; // 解析token Claims claims = JwtUtil.parseJWT(token); return Integer.valueOf(claims.getSubject()); &#125; return null; &#125;&#125; package com.example.demo.config;import com.example.demo.resolver.UserIdArgumentResolver;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;/** * 参数解析器配置 * * @author tong * @date 2023/03/13 */@Configurationpublic class ArgumentResolverConfig implements WebMvcConfigurer &#123; @Autowired private UserIdArgumentResolver userIdArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; resolvers.add(userIdArgumentResolver); &#125;&#125; 测试 @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @PostMapping(&quot;/login&quot;) public Object checkLogin(@RequestBody LoginVo loginVo)&#123; return userService.checkLogin(loginVo); &#125; @PostMapping(&quot;/test1&quot;) public Object test1(@CurrentUserId Integer userId)&#123; return JsonData.buildSuccess(userId); &#125;&#125; &gt; 可以看到参数已经被解析成id了跨域package com.example.demo.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 跨域配置 * * @author tong * @date 2023/03/13 */@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域的域名 .allowedOrigins(&quot;*&quot;) //是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;,&quot;POST&quot;,&quot;DELETE&quot;,&quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; 参数校验 oracle实现id自增和mysql有点区别新建分组 public interface AddGroup &#123;&#125; public interface DeleteGroup &#123;&#125; public interface UserMapper extends BaseMapper&lt;User&gt; &#123; @Insert(&quot;INSERT INTO TB_USER (ID,NICKNAME,USERNAME,PASSWORD) VALUES ((SELECT MAX(ID)+1 FROM TB_USER),#&#123;nickname&#125;,#&#123;username&#125;,#&#123;password&#125;)&quot;) boolean insertUser(User user);&#125; @Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; @Override public Object checkLogin(LoginVo loginVo) &#123; User user = baseMapper.selectOne( new QueryWrapper&lt;User&gt;() .eq(&quot;USERNAME&quot;, loginVo.getUsername()) .eq(&quot;PASSWORD&quot;, loginVo.getPassword())); if(user==null)&#123; return JsonData.buildError(&quot;用户不存在&quot;); &#125;else&#123; return JsonData.buildSuccess(JwtUtil.createJWT(user.getId().toString())); &#125; &#125; @Override public boolean saveUser(User user) &#123; return baseMapper.insertUser(user); &#125;&#125; @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @PostMapping(&quot;/login&quot;) public Object checkLogin(@RequestBody LoginVo loginVo) &#123; return userService.checkLogin(loginVo); &#125; @PostMapping(&quot;/test1&quot;) public Object test1(@CurrentUserId Integer userId, @RequestBody User user) &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, userId); map.put(&quot;user&quot;, user); return JsonData.buildSuccess(map); &#125; @PostMapping(&quot;/add&quot;) // 指定分组 public Object addUser(@Validated(&#123;AddGroup.class&#125;) @RequestBody User user) &#123; if(userService.saveUser(user))&#123; User one = userService.getOne(new QueryWrapper&lt;User&gt;() .eq(&quot;USERNAME&quot;, user.getUsername()) .eq(&quot;PASSWORD&quot;, user.getPassword())); return JsonData.buildSuccess(one); &#125;else&#123; return JsonData.buildError(&quot;注册失败&quot;); &#125; &#125;&#125; @Data@TableName(value =&quot;TB_USER&quot;)public class User implements Serializable &#123; /** * id */ @Null(message = &quot;新增用户时，不能指定用户id&quot;,groups = &#123;AddGroup.class&#125;) @NotNull(message = &quot;删除用户时，必须指定用户id&quot;,groups = &#123;DeleteGroup.class&#125;) @TableId(value = &quot;ID&quot;,type = IdType.AUTO) private Integer id; /** * 昵称 */ @TableField(value = &quot;NICKNAME&quot;) private String nickname; /** * 用户名 */ @TableField(value = &quot;USERNAME&quot;) private String username; /** * 密码 */ @TableField(value = &quot;PASSWORD&quot;) private String password; @TableField(exist = false) private static final long serialVersionUID = 1L;&#125; 我们在日常开发中需要对程序内部的运行情况进行监控， 比如：健康度、运行指标、日志信息、线程状况等等 。而SpringBoot的监控Actuator就可以帮我们解决这些问题。 监控指标①添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; ②访问监控接口http://localhost:81/actuator③配置启用监控端点 management: endpoints: enabled-by-default: true #配置启用所有端点 web: exposure: include: &quot;*&quot; #web端暴露所有端点 常用端点 端点名称 描述 beans 显示应用程序中所有Spring Bean的完整列表。 health 显示应用程序运行状况信息。 info 显示应用程序信息。 loggers 显示和修改应用程序中日志的配置。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 图形化界面 SpringBoot Admin①创建SpringBoot Admin Server应用要求引入spring-boot-admin-starter-server依赖 &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt; 然后在启动类上加上@EnableAdminServer注解②配置SpringBoot Admin client应用在需要监控的应用中加上spring-boot-admin-starter-client依赖 &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt; 然后配置SpringBoot Admin Server的地址 spring: boot: admin: client: url: http://localhost:8888 #配置 Admin Server的地址","categories":[],"tags":[]},{"title":"Spring6学习02","slug":"编程语言/Java/学习/框架/Spring/Spring6/02_Spring6","date":"2023-03-11T10:00:00.000Z","updated":"2024-06-01T14:32:53.512Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/02-spring6.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/02-spring6.html","excerpt":"","text":"Spring6学习02引入外部文件 引入数据库相关依赖 创建外部属性文件，如properties，定义数据库连接信息(用户名、密码…) 创建spring配置文件，引入context命名空间来引入属性文件，使用表达式完成注入 public class ApplicationTest &#123; @Test public void test1() &#123; try (DruidDataSource dataSource = new DruidDataSource()) &#123; dataSource.setDriverClassName(&quot;oracle.jdbc.driver.OracleDriver&quot;); dataSource.setUrl(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); System.out.println(dataSource); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;出现异常&quot;, e); &#125; &#125;&#125; 使用spring改造以上的代码 jdbc.driver=oracle.jdbc.driver.OracleDriverjdbc.url=jdbc:oracle:thin:@localhost:1521:orcljdbc.username=rootjdbc.password=123456 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入属性 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt; &lt;!-- 完成数据库信息注入 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class ApplicationTest &#123; @Test public void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DruidDataSource dataSource = context.getBean(DruidDataSource.class); System.out.println(dataSource); &#125;&#125; bean的作用域在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 ——- ——————– request 在一个请求范围内有效 session 在一个会话范围内有效 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;user1&quot; class=&quot;com.example.domain.User&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;哈哈&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.example.domain.User&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;哈哈&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; @Setterpublic class User &#123; private Integer id; private String name;&#125; @Testpublic void test3() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user1_1 = context.getBean(&quot;user1&quot;, User.class); User user1_2 = context.getBean(&quot;user1&quot;, User.class); System.out.println(user1_1); System.out.println(user1_2);&#125; // 输出com.example.domain.User@121314f7com.example.domain.User@121314f7 这里可以看到 两个对象都是同一个地址，即同一个对象 @Testpublic void test4() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user1_1 = context.getBean(&quot;user2&quot;, User.class); User user1_2 = context.getBean(&quot;user2&quot;, User.class); System.out.println(user1_1); System.out.println(user1_2);&#125; // 输出com.example.domain.User@130c12b7com.example.domain.User@5e600dd5 这里显示对象的地址不同，即创建了多个对象 bean的生命周期 bean对象创建（调用无参构造器） 给bean对象设置属性 bean的后置处理器（初始化之前） bean对象初始化（需在配置bean时指定初始化方法） bean的后置处理器（初始化之后） bean对象就绪可以使用 bean对象销毁（需在配置bean时指定销毁方法） IOC容器关闭","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"}],"tags":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"}]},{"title":"Spring6学习01","slug":"编程语言/Java/学习/框架/Spring/Spring6/01_Spring6","date":"2023-03-11T02:00:00.000Z","updated":"2024-06-01T14:32:53.515Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/01-spring6.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring6/01-spring6.html","excerpt":"","text":"Spring6学习01&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Spring6&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring001&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--spring ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; xml配置 beans.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;/&gt;&lt;/beans&gt; log4j2.xml，配置log4j2的日志输出 其中log和RollingFile会将日志输出到文件中，如果文件夹不存在，会自动创建 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL trace：追踪，是最低的日志级别，相当于追踪程序的执行 debug：调试，一般在开发中，都将其设置为最低的日志级别 info：信息，输出重要的信息，使用较多 warn：警告，输出警告的信息 error：错误，输出错误信息 fatal：严重错误 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;spring6log&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;D:/spring6_log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息， 每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档--&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;D:/spring6_log/app.log&quot; filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;!-- DefaultRolloverStrategy属性如不设置， 则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt;&lt;/configuration&gt; 获取bean 根据id获取bean 根据类型获取bean 根据id和类型获取bean @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age;&#125; public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 1.根据id获取bean User user1 = (User) context.getBean(&quot;user&quot;); // 2.根据类型获取bean User user2 = context.getBean(User.class); // 3.根据id和类型获取bean User user3 = context.getBean(&quot;user&quot;, User.class); // 日志输出 logger.info(&quot;user1:&#123;&#125;&quot;,user1); logger.info(&quot;user2:&#123;&#125;&quot;,user2); logger.info(&quot;user3:&#123;&#125;&quot;,user3); &#125;&#125; 需要注意的是如果根据类型获取，要求IOC中指定类型的bean只能有一个 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;/&gt; &lt;bean id=&quot;user1&quot; class=&quot;com.example.domain.User&quot;/&gt;&lt;/beans&gt; public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 根据类型获取bean User user2 = context.getBean(User.class); // 日志输出 logger.info(&quot;user2:&#123;&#125;&quot;,user2); &#125;&#125; 报错信息如下 org.springframework.beans.factory.NoUniqueBeanDefinitionException:No qualifying bean of type &#x27;com.example.domain.User&#x27; available: expected single matching bean but found 2: user,user1 UserDao userDao&#x3D;new UserDaoImpl(); bean配置能否实现如上效果？如果有多个Impl的实现类呢？ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.example.dao.impl.UserDaoImpl&quot;/&gt;&lt;/beans&gt; public interface UserDao &#123; void testDao();&#125; public class UserDaoImpl implements UserDao &#123; @Override public void testDao() &#123; System.out.println(&quot;这里是userDaoImpl&quot;); &#125;&#125; public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserDao userDao = context.getBean(UserDao.class); logger.info(&quot;userDao:&#123;&#125;&quot;,userDao); userDao.testDao(); &#125;&#125; 可以通过类型直接获取到 但是当新建第二个impl实现类时，无法根据类型获取到，报错和之前一样可以根据bean的名称获取到、也可以根据bean的名称+类型获取到 结论 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系 public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; UserDaoImpl userDaoImpl = new UserDaoImpl(); System.out.println(userDaoImpl instanceof UserDao); &#125;&#125;// 结果为 true 依赖注入-setter注入&amp;&amp;构造器注入public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; // set方法 User user1 = new User(); user1.setUid(1); user1.setName(&quot;哈哈&quot;); user1.setGender(&quot;男&quot;); user1.setAge(15); // 构造器 User user2 = new User(1, &quot;哈哈&quot;, &quot;男&quot;, 15); System.out.println(&quot;user1:&quot;+user1); System.out.println(&quot;user2:&quot;+user2); &#125;&#125; user1:User(uid=1, name=哈哈, gender=男, age=15)user2:User(uid=1, name=哈哈, gender=男, age=15) 这里想测试一下这两个user对象是否相等 预想的情况应该是 false，false 因为Object里的equals方法就是 &#x3D;&#x3D; System.out.println(&quot;user1 &amp;&amp; user2是否相等:&quot;+user1.equals(user2));System.out.println(&quot;user1 &amp;&amp; user2是否相等:&quot;+(user1==user2)); 但答案是 true，false，我猜是@Data的问题 我一直以为@Data&#x3D;get+set+toString 但其实@Data &#x3D;get、set、equals、hashCode、toString setter注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;user1&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 构造器注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;constructor-arg name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 前提使用setter注入，需要提前生成set方法使用构造器注入，需要提前生成全参数的构造方法 特殊值处理null&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;constructor-arg name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;&quot;/&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User bean = context.getBean(User.class); System.out.println(bean.getName() == null); System.out.println(Objects.equals(bean.getName(), &quot;&quot;)); &#125;&#125; 结果是 false，true 此时name的值并不是null，是空字符串，如果希望它的值就是null，那么xml应该如下配置（set同理） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;constructor-arg name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;name&quot;&gt; &lt;null/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 特殊符号 写法1 &lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt; 写法2 &lt;property name=&quot;expression&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt; 实体 方法1 外部引入 @Data@AllArgsConstructor@NoArgsConstructorpublic class Phone &#123; private Integer pid; private String name; private Float price;&#125; @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; // 包含了phone类 private Phone phone;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;!-- ref 关联 phone --&gt; &lt;property name=&quot;phone&quot; ref=&quot;phone&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class ApplicationTest &#123; private final Logger logger= LoggerFactory.getLogger(ApplicationTest.class); @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User bean = context.getBean(User.class); System.out.println(bean); &#125;&#125; 方法2 内部bean &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;!-- 不填写value或ref，将bean写在property内 --&gt; &lt;property name=&quot;phone&quot;&gt; &lt;bean class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 方法3 级联属性赋值 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phone&quot; ref=&quot;phone&quot;/&gt; &lt;!-- 会将price的值进行覆盖 --&gt; &lt;property name=&quot;phone.price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 总结： 以上都是set注入的写法，构造器注入的写法是一样的 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;constructor-arg name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;constructor-arg name=&quot;phone&quot; ref=&quot;phone&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;constructor-arg name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 数组@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; private String[] hobby; private Phone phone;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;hobby&quot;&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;phone&quot; ref=&quot;phone&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 集合List@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; // 实体对象集合 private List&lt;Phone&gt; phones;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phones&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;phone&quot;/&gt; &lt;ref bean=&quot;phone1&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 上面演示的是 实体对象集合，如果是字符串集合，可使用value，而不是ref @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; // 字符串集合 private List&lt;String&gt; phones;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phones&quot;&gt; &lt;list&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Map@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; private Map&lt;String,Phone&gt; phoneMap;&#125; 写法1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phoneMap&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;phone&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 写法2 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phoneMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;第一部手机&quot; value-ref=&quot;phone&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 以上的map集合里只有一个值，多个值的写法一样 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;phoneMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;第一部手机&quot; value-ref=&quot;phone&quot;/&gt; &lt;entry key=&quot;第二部手机&quot; value-ref=&quot;phone1&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;phone&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 引用集合类型的bean util命令空间&amp;&amp;p命名空间@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age; private List&lt;Lesson&gt; lessons; private Map&lt;String,Phone&gt; phoneMap;&#125; @Data@AllArgsConstructor@NoArgsConstructorpublic class Lesson &#123; private Integer lid; private String name;&#125; @Data@AllArgsConstructor@NoArgsConstructorpublic class Phone &#123; private Integer pid; private String name; private Float price;&#125; 使用之前的写法 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;lessons&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;lesson1&quot;/&gt; &lt;ref bean=&quot;lesson2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;phoneMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;第一部手机&quot; value-ref=&quot;phone1&quot;/&gt; &lt;entry key=&quot;第二部手机&quot; value-ref=&quot;phone2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- lesson1 --&gt; &lt;bean id=&quot;lesson1&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;java开发&quot;/&gt; &lt;/bean&gt; &lt;!-- lesson2 --&gt; &lt;bean id=&quot;lesson2&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;python开发&quot;/&gt; &lt;/bean&gt; &lt;!-- phone1 --&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;!-- phone2 --&gt; &lt;bean id=&quot;phone2&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第二种写法 这里需要更改xml上面的命名空间 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;lessons&quot; ref=&quot;lessonList&quot;/&gt; &lt;property name=&quot;phoneMap&quot; ref=&quot;phoneMap&quot;/&gt; &lt;/bean&gt; &lt;util:list id=&quot;lessonList&quot;&gt; &lt;ref bean=&quot;lesson1&quot;/&gt; &lt;ref bean=&quot;lesson2&quot;/&gt; &lt;/util:list&gt; &lt;util:map id=&quot;phoneMap&quot;&gt; &lt;entry key=&quot;第一部手机&quot; value-ref=&quot;phone1&quot;/&gt; &lt;entry key=&quot;第二部手机&quot; value-ref=&quot;phone2&quot;/&gt; &lt;/util:map&gt; &lt;!-- lesson1 --&gt; &lt;bean id=&quot;lesson1&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;java开发&quot;/&gt; &lt;/bean&gt; &lt;!-- lesson2 --&gt; &lt;bean id=&quot;lesson2&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;python开发&quot;/&gt; &lt;/bean&gt; &lt;!-- phone1 --&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;!-- phone2 --&gt; &lt;bean id=&quot;phone2&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三种写法 p命名空间注入 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.example.domain.User&quot; p:uid=&quot;1&quot; p:name=&quot;马小跳&quot; p:gender=&quot;男&quot; p:age=&quot;15&quot; p:lessons-ref=&quot;lessonList&quot; p:phoneMap-ref=&quot;phoneMap&quot;/&gt; &lt;util:list id=&quot;lessonList&quot;&gt; &lt;ref bean=&quot;lesson1&quot;/&gt; &lt;ref bean=&quot;lesson2&quot;/&gt; &lt;/util:list&gt; &lt;util:map id=&quot;phoneMap&quot;&gt; &lt;entry key=&quot;第一部手机&quot; value-ref=&quot;phone1&quot;/&gt; &lt;entry key=&quot;第二部手机&quot; value-ref=&quot;phone2&quot;/&gt; &lt;/util:map&gt; &lt;!-- lesson1 --&gt; &lt;bean id=&quot;lesson1&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;java开发&quot;/&gt; &lt;/bean&gt; &lt;!-- lesson2 --&gt; &lt;bean id=&quot;lesson2&quot; class=&quot;com.example.domain.Lesson&quot;&gt; &lt;property name=&quot;lid&quot; value=&quot;0002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;python开发&quot;/&gt; &lt;/bean&gt; &lt;!-- phone1 --&gt; &lt;bean id=&quot;phone1&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;001&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;不锈钢手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;4999.9&quot;/&gt; &lt;/bean&gt; &lt;!-- phone2 --&gt; &lt;bean id=&quot;phone2&quot; class=&quot;com.example.domain.Phone&quot;&gt; &lt;property name=&quot;pid&quot; value=&quot;002&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;塑料手机&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;3999.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"}],"tags":[{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"}]},{"title":"Spring连接oracle连接Oracle实现CRUD操作","slug":"编程语言/Java/学习/Oracle/02_Spring连接oracle","date":"2023-03-10T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/oracle/02-spring-lian-jie-oracle.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/oracle/02-spring-lian-jie-oracle.html","excerpt":"","text":"Spring连接oracle使用过的jar包在文章结尾处，而且建议还是使用maven项目的结构，我这个结构不标准 新建lib包，在lib下导入jar包 如果发现无法使用jar包注解等，请在project structure-&gt;modules-&gt;dependencies中添加lib包这个是新建maven项目导入spring-context依赖后的图片这个是普通java项目手动导入jar包此时已经可以新建spring-xml了 测试lombokimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private String gender; private Integer age;&#125; public class ApplicationTest &#123; public static void main(String[] args) &#123; User user = new User(1, &quot;马小跳&quot;, &quot;男&quot;, 15); System.out.println(user); &#125;&#125; 测试成功 测试Spring&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;src.com.example.domain.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;马小跳&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class ApplicationTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;src/applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user); &#125;&#125; 运行后报错，继续导入该jar包导入jar包后继续运行这里需要注意applicationContext.xml的位置如果在src下，需要写src/applicationContext.xml如果和src同级，需要写applicationContext.xml 配置Oracle # 数据库驱动：spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver# 数据库连接地址spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:src/jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;spring.datasource.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;spring.datasource.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;spring.datasource.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class ApplicationTest &#123; @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;src/applicationContext.xml&quot;); DruidDataSource dataSource = context.getBean(&quot;dataSource&quot;, DruidDataSource.class); &#125;&#125; ![image-20230311224204289](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303112242465.png) > 可以看到已经配置成功 > > 接下来测试一下sql @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String nickname; private String username; private String password;&#125; public class ApplicationTest &#123; @Test public void test1() throws Exception &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;src/applicationContext.xml&quot;); DruidDataSource dataSource = context.getBean(&quot;dataSource&quot;, DruidDataSource.class); DruidPooledConnection connection = dataSource.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from tb_user&quot;); ResultSet resultSet = preparedStatement.executeQuery(); // User列表 List&lt;User&gt; list = new ArrayList&lt;&gt;(); while(resultSet.next())&#123; User user = new User( resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;nickname&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;)); list.add(user); &#125; list.forEach(System.out::println); &#125;&#125; 三月 11, 2023 10:56:36 下午 com.alibaba.druid.pool.DruidAbstractDataSource warn警告: oracle.jdbc.driver.OracleDriver is deprecated.Having use oracle.jdbc.OracleDriver.三月 11, 2023 10:56:36 下午 com.alibaba.druid.pool.DruidDataSource info信息: &#123;dataSource-1&#125; initedUser(id=1, nickname=哈哈, username=admin, password=123456)User(id=2, nickname=呵呵, username=abcd, password=456)User(id=3, nickname=嘿嘿, username=aan, password=1234)Process finished with exit code 0 ![image-20230311230401198](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303112304328.png) [项目](https://www.123pan.com/s/tMU0Vv-K2iUd.html)、[lib包](https://www.123pan.com/s/tMU0Vv-u2iUd.html)","categories":[{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/categories/java-oracle/"}],"tags":[{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/tags/java-oracle/"}]},{"title":"JDBC连接Oracle实现CRUD操作","slug":"编程语言/Java/学习/Oracle/01_Jdbc连接oracle","date":"2023-03-09T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/oracle/01-jdbc-lian-jie-oracle.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/oracle/01-jdbc-lian-jie-oracle.html","excerpt":"","text":"JDBC连接Oracle实现CRUD操作 下面是项目的结构 lib下存放的是oracle的连接包，ojdbc6-11.2.0.4.jar D:.├─.idea│ └─inspectionProfiles├─lib└─src └─com └─example ├─config ├─domain └─mapper └─impl -- 建表create table tb_user( id number(10) primary key, nickname varchar2(20), username varchar2(20), password varchar2(20));-- 插入测试数据insert into tb_user (id, nickname, username, password) values (1,&#x27;哈哈&#x27;,&#x27;admin&#x27;,&#x27;123456&#x27;);insert into tb_user (id, nickname, username, password) values (2,&#x27;呵呵&#x27;,&#x27;abcd&#x27;,&#x27;456&#x27;);insert into tb_user (id, nickname, username, password) values (3,&#x27;嘿嘿&#x27;,&#x27;aan&#x27;,&#x27;1234&#x27;);commit;-- 查询表select * from tb_user; public class User &#123; private Integer id; private String nickname; private String username; private String password; public User(Integer id, String nickname, String username, String password) &#123; this.id = id; this.nickname = nickname; this.username = username; this.password = password; &#125; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, nickname=&#x27;&quot; + nickname + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; import java.sql.*;public class OracleConfig &#123; public static Connection getConnection() &#123; Connection connection = null; try &#123; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); connection = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521/orcl&quot;, &quot;root&quot;, &quot;123456&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return connection; &#125; public static void close(Connection connection, Statement statement, PreparedStatement preparedStatement, ResultSet resultSet)&#123; try &#123; resultSet.close(); preparedStatement.close(); connection.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; public interface UserMapper &#123; List&lt;User&gt; selectUsers();&#125; import src.com.example.config.OracleConfig;import src.com.example.domain.User;import src.com.example.mapper.UserMapper;import java.sql.*;import java.util.ArrayList;import java.util.List;public class UserMapperImpl implements UserMapper &#123; @Override public List&lt;User&gt; selectUsers() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); // 建立连接 Connection connection = OracleConfig.getConnection(); PreparedStatement preparedStatement =null; ResultSet resultSet =null; try &#123; preparedStatement = connection.prepareStatement(&quot;select * from tb_user&quot;); resultSet = preparedStatement.executeQuery(); while (resultSet.next())&#123; // 创建对象 User user=new User( resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;nickname&quot;), resultSet.getString(&quot;username&quot;), resultSet.getString(&quot;password&quot;)); list.add(user); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; // 关闭资源 OracleConfig.close(connection,null,preparedStatement,resultSet); return list; &#125; static class MyTest&#123; public static void main(String[] args) &#123; UserMapperImpl userMapper = new UserMapperImpl(); List&lt;User&gt; list = userMapper.selectUsers(); list.forEach(System.out::println); &#125; &#125;&#125; > 下图是演示结果 ![image-20230310224210463](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303102242670.png) ### 关于在lib内导入jar包的操作 > 如果以上操作`依然无法连接到oracle`，请查看第二张图片内选择的模块是否正确 ### 可能出现的报错信息 1. 表或视图不存在 1. sql和数据库对不上 2. 在数据库插入数据后执行以下commit操作`(非常重要！！！)` 2. sql语句错误 1. sql语句写错了 2. sql语句内的末尾的分号去掉`(去掉;)`","categories":[{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/categories/java-oracle/"}],"tags":[{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/tags/java-oracle/"}]},{"title":"常用配置、工具类","slug":"编程语言/Java/学习/基础/008_常用配置、工具类","date":"2023-03-05T10:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/008-chang-yong-pei-zhi-gong-ju-lei.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/008-chang-yong-pei-zhi-gong-ju-lei.html","excerpt":"","text":"返回对象工具类import java.io.Serializable;public class Result&lt;T&gt; implements Serializable &#123;//返回的结果集类 //服务器响应的状态 不是http状态 private Integer code; //备注 private String msg; //返回的数据 private T data; public Result() &#123; &#125; public Result(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public Result&lt;?&gt; setCode(Integer code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public Result&lt;?&gt; setMsg(String msg) &#123; this.msg = msg; return this; &#125; public T getData() &#123; return data; &#125; public Result&lt;?&gt; setData(T data) &#123; this.data = data; return this; &#125; @Override public String toString() &#123; return &quot;Result&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&#x27;&quot; + msg + &#x27;\\&#x27;&#x27; + &quot;, data=&quot; + data + &#x27;&#125;&#x27;; &#125; public Result&lt;?&gt; setCode(ResultEnum resultEnum) &#123; this.code = resultEnum.code; return this; &#125;&#125; /** * 结果枚举 * * @author tong * @date 2023/03/04 */public enum ResultEnum &#123; /** * 成功 */ SUCCESS(200, &quot;操作成功&quot;), /** * 对象创建成功 */ CREATED(201, &quot;对象创建成功&quot;), /** * 请求已经被接受 */ ACCEPTED(202, &quot;请求已经被接受&quot;), /** * 操作已经执行成功，但是没有返回数据 */ NO_CONTENT(204, &quot;操作已经执行成功，但是没有返回数据&quot;), /** * 资源已被移除 */ MOVED_PERM(301, &quot;资源已被移除&quot;), /** * 重定向 */ SEE_OTHER(303, &quot;重定向&quot;), /** * 资源没有被修改 */ NOT_MODIFIED(304, &quot;资源没有被修改&quot;), /** * 参数列表错误（缺少，格式不匹配） */ BAD_REQUEST(400, &quot;操作失败&quot;), /** * 未授权 */ UNAUTHORIZED(401, &quot;未授权&quot;), /** * 访问受限，授权过期 */ FORBIDDEN(403, &quot;访问受限，授权过期&quot;), /** * 资源、服务未找到 */ NOT_FOUND(404, &quot;资源，服务未找到&quot;), /** * 不允许的http方法 */ BAD_METHOD(405, &quot;不允许的http方法&quot;), /** * 资源冲突，或者资源被锁 */ CONFLICT(409, &quot;资源冲突，或者资源被锁&quot;), /** * 不支持的数据、媒体类型 */ UNSUPPORTED_TYPE(415, &quot;不支持的数据、媒体类型&quot;), /** * 服务器内部错误 */ ERROR(500, &quot;服务器内部错误&quot;), /** * 接口未实现 */ NOT_IMPLEMENTED(501, &quot;接口未实现&quot;); public final Integer code; public final String msg; ResultEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125;&#125; /** * 返回结果工具类 * * @author tong * @date 2023/03/04 */public class ResultUtil &#123; public static &lt;T&gt; Result&lt;T&gt; defineSuccess(Integer code, T data) &#123; Result result = new Result&lt;&gt;(); return result.setCode(code).setData(data); &#125; public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; Result result = new Result(); result.setCode(ResultEnum.SUCCESS).setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; fail(String msg) &#123; Result result = new Result(); result.setCode(ResultEnum.BAD_REQUEST).setMsg(msg); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; defineFail(Integer code, String msg)&#123; Result result = new Result(); result.setCode(code).setMsg(msg); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; define(Integer code, String msg, T data)&#123; Result result = new Result(); result.setCode(code).setMsg(msg).setData(data); return result; &#125; public static Object defineSuccess(ResultEnum success, Object list) &#123; Result result=new Result(); result.setCode(success); result.setData(list); return result; &#125;&#125; 用法 @RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/id&quot;) public Object getUser() &#123; return ResultUtil.define( ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMsg(), userService.list() ); &#125;&#125; 其他返回工具类 @Data@AllArgsConstructor@NoArgsConstructorpublic class JsonData &#123; /** * 状态码 0 表示成功，1表示处理中，-1表示失败 */ private Integer code; /** * 数据 */ private Object data; /** * 描述 */ private String msg; // 成功，传入数据 public static JsonData buildSuccess() &#123; return new JsonData(0, null, null); &#125; // 成功，传入数据 public static JsonData buildSuccess(Object data) &#123; return new JsonData(0, data, null); &#125; // 失败，传入描述信息 public static JsonData buildError(String msg) &#123; return new JsonData(-1, null, msg); &#125; // 失败，传入描述信息,状态码 public static JsonData buildError(String msg, Integer code) &#123; return new JsonData(code, null, msg); &#125;&#125; /** * @Auther: Administrator * @Date: 2022/10/12/9:09 * @Description: */import java.io.Serializable;public class JsonResult&lt;T&gt; implements Serializable &#123; private Boolean success; private Integer errorCode; private String errorMsg; private T data; public JsonResult() &#123; &#125; public JsonResult(boolean success) &#123; this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : com.example.demo.util.ResultCode.COMMON_FAIL.getCode(); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : com.example.demo.util.ResultCode.COMMON_FAIL.getMessage(); &#125; public JsonResult(boolean success, com.example.demo.util.ResultCode resultEnum) &#123; this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode()); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage()); &#125; public JsonResult(boolean success, T data) &#123; this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : com.example.demo.util.ResultCode.COMMON_FAIL.getCode(); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : com.example.demo.util.ResultCode.COMMON_FAIL.getMessage(); this.data = data; &#125; public JsonResult(boolean success, com.example.demo.util.ResultCode resultEnum, T data) &#123; this.success = success; this.errorCode = success ? com.example.demo.util.ResultCode.SUCCESS.getCode() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getCode() : resultEnum.getCode()); this.errorMsg = success ? com.example.demo.util.ResultCode.SUCCESS.getMessage() : (resultEnum == null ? com.example.demo.util.ResultCode.COMMON_FAIL.getMessage() : resultEnum.getMessage()); this.data = data; &#125; public Boolean getSuccess() &#123; return success; &#125; public void setSuccess(Boolean success) &#123; this.success = success; &#125; public Integer getErrorCode() &#123; return errorCode; &#125; public void setErrorCode(Integer errorCode) &#123; this.errorCode = errorCode; &#125; public String getErrorMsg() &#123; return errorMsg; &#125; public void setErrorMsg(String errorMsg) &#123; this.errorMsg = errorMsg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; /** * @Auther: Administrator * @Date: 2022/10/12/9:09 * @Description: */public enum ResultCode &#123; /* 成功 */ SUCCESS(200, &quot;成功&quot;), /* 默认失败 */ COMMON_FAIL(999, &quot;失败&quot;), /* 参数错误：1000～1999 */ PARAM_NOT_VALID(1001, &quot;参数无效&quot;), PARAM_IS_BLANK(1002, &quot;参数为空&quot;), PARAM_TYPE_ERROR(1003, &quot;参数类型错误&quot;), PARAM_NOT_COMPLETE(1004, &quot;参数缺失&quot;), /* 用户错误 */ USER_NOT_LOGIN(2001, &quot;用户未登录&quot;), USER_ACCOUNT_EXPIRED(2002, &quot;账号已过期&quot;), USER_CREDENTIALS_ERROR(2003, &quot;密码错误&quot;), USER_CREDENTIALS_EXPIRED(2004, &quot;密码过期&quot;), USER_ACCOUNT_DISABLE(2005, &quot;账号不可用&quot;), USER_ACCOUNT_LOCKED(2006, &quot;账号被锁定&quot;), USER_ACCOUNT_NOT_EXIST(2007, &quot;账号不存在&quot;), USER_ACCOUNT_ALREADY_EXIST(2008, &quot;账号已存在&quot;), USER_ACCOUNT_USE_BY_OTHERS(2009, &quot;账号下线&quot;), /* 业务错误 */ NO_PERMISSION(3001, &quot;没有权限&quot;); private Integer code; private String message; ResultCode(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; /** * 根据code获取message * * @param code * @return */ public static String getMessageByCode(Integer code) &#123; for (ResultCode ele : values()) &#123; if (ele.getCode().equals(code)) &#123; return ele.getMessage(); &#125; &#125; return null; &#125;&#125; /** * @Auther: Administrator * @Date: 2022/10/12/9:10 * @Description: */public class ResultTool &#123; public static com.example.demo.util.JsonResult success() &#123; return new com.example.demo.util.JsonResult(true); &#125; public static &lt;T&gt; com.example.demo.util.JsonResult&lt;T&gt; success(T data) &#123; return new com.example.demo.util.JsonResult(true, data); &#125; public static com.example.demo.util.JsonResult fail() &#123; return new com.example.demo.util.JsonResult(false); &#125; public static com.example.demo.util.JsonResult fail(com.example.demo.util.ResultCode resultEnum) &#123; return new com.example.demo.util.JsonResult(false, resultEnum); &#125;&#125; Redis配置及工具类Redis配置import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; Redis工具类import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; JWT工具类import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 密码加密存储​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 /** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 加密解密工具类import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;// 加密、解密工具类public class CryptUtil &#123; private static final String AES = &quot;AES&quot;; private static int keysizeAES = 128; private static String charset = &quot;UTF-8&quot;; public static String parseByte2HexStr(final byte[] b) &#123; final StringBuilder stringBuffer = new StringBuilder(); for (byte value : b) &#123; String hex = Integer.toHexString(value &amp; 0xFF); if (hex.length() == 1) &#123; hex = &#x27;0&#x27; + hex; &#125; stringBuffer.append(hex.toUpperCase()); &#125; return stringBuffer.toString(); &#125; public static byte[] parseHexStr2Byte(final String hexStr) &#123; if (hexStr.length() &lt; 1) &#123; return null; &#125; final byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i &lt; hexStr.length() / 2; i++) &#123; int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); &#125; return result; &#125; private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final boolean bEncode) &#123; try &#123; final KeyGenerator g = KeyGenerator.getInstance(algorithm); if (keysize == 0) &#123; byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); g.init(new SecureRandom(keyBytes)); &#125; else if (key == null) &#123; g.init(keysize); &#125; else &#123; byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); random.setSeed(keyBytes); g.init(keysize, random); &#125; final SecretKey secretKey = g.generateKey(); final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); final Cipher cipher = Cipher.getInstance(algorithm); if (bEncode) &#123; cipher.init(Cipher.ENCRYPT_MODE, keySpec); final byte[] result = charset == null ? res.getBytes() : res.getBytes(charset); return parseByte2HexStr(cipher.doFinal(result)); &#125; else &#123; cipher.init(Cipher.DECRYPT_MODE, keySpec); return new String(cipher.doFinal(parseHexStr2Byte(res))); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static String AESencode(final String res) &#123; return keyGeneratorES(res, AES, &quot;aAll*-%&quot;, keysizeAES, true); &#125; public static String AESdecode(final String res) &#123; return keyGeneratorES(res, AES, &quot;aAll*-%&quot;, keysizeAES, false); &#125; public static void main(String[] args) &#123; System.out.println(&quot;加密后:&quot; + AESencode(&quot;123456&quot;)); System.out.println(&quot;解密后:&quot; + AESdecode(&quot;555B695B57E024EEA169EAE275B9D93B&quot;)); &#125;&#125; 常用pom依赖&lt;!--Swagger3.x--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis-plus自动生成--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--velocity--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--代码自动生成依赖--&gt;&lt;!--Json--&gt;&lt;dependency&gt; &lt;groupId&gt;com.vaadin.external.google&lt;/groupId&gt; &lt;artifactId&gt;android-json&lt;/artifactId&gt; &lt;version&gt;0.0.20131108.vaadin1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.22&lt;/version&gt;&lt;/dependency&gt; swagger配置 访问http://localhost:8090/swagger-ui/index.html即可查看接口文档 &lt;!--Swagger3.x--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; # ==========自定义swagger配置==========swagger.enable=trueswagger.application-name=$&#123;spring.application.name&#125;swagger.application-version=1.0swagger.application-description=1024shop api info#swagger.application-description=1024shop电商平台管理后端接口文档# 这里如果是中文，则会出现乱码，有以下两种解决方法# 1. 修改文件编码# 2. 使用yml格式 编码格式改为了ISO-8859-1，如果是配置yml文件，格式也需要更改 import io.swagger.annotations.ApiOperation;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.oas.annotations.EnableOpenApi;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;/** * @Auther: 温豪 * @Date: 2022/11/30/15:05 * @Description: */@Component@Data@ConfigurationProperties(&quot;swagger&quot;) // 映射到properties配置，省略前缀@EnableOpenApi // 开启规范public class SwaggerConfiguration &#123; /** * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量 */ private Boolean enable; /** * 项目应用名 */ private String applicationName; /** * 项目版本信息 */ private String applicationVersion; /** * 项目描述信息 */ private String applicationDescription; @Bean public Docket docket() &#123; return new Docket(DocumentationType.OAS_30) .pathMapping(&quot;/&quot;) // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭 .enable(enable) //配置api文档元信息 .apiInfo(apiInfo()) // 选择哪些接口作为swagger的doc发布 .select() //apis() 控制哪些接口暴露给swagger， // RequestHandlerSelectors.any() 所有都暴露 // RequestHandlerSelectors.basePackage(&quot;net.xdclass.*&quot;) 指定包位置 // withMethodAnnotation(ApiOperation.class)标记有这个注解 ApiOperation .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(applicationName) .description(applicationDescription) .contact(new Contact(&quot;深海火锅店&quot;, &quot;tongstyle.gitee.io&quot;, &quot;938798576@aliyun.com&quot;)) .version(applicationVersion) .build(); &#125;&#125; // 主要注解// 1.@Api()// 2.@ApiOperation()// 3.@ApiResponse()// 4.@ApiModel()// 5.@ApiModelProperty()@RestController@RequestMapping(&quot;/user&quot;)@Api(tags = &quot;用户模块&quot;, value = &quot;用户controller&quot;)// --------------------------------------------------@ApiOperation(&quot;用户登录&quot;)@ApiResponses(&#123; @ApiResponse(responseCode = &quot;404&quot;,description = &quot;找不到该页面&quot;), @ApiResponse(responseCode = &quot;403&quot;,description = &quot;权限不够&quot;)&#125;)@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;mobile&quot;, value = &quot;手机号码&quot;, dataType = &quot;string&quot;, paramType = &quot;query&quot;, example = &quot;13802780104&quot;, required = true), @ApiImplicitParam(name = &quot;user_name&quot;, value = &quot;登录账号&quot;, dataType = &quot;string&quot;, paramType = &quot;query&quot;, example = &quot;lihailin9073&quot;, required = true), &#125;)@PostMapping(&quot;/login&quot;)public Object login(@RequestBody User user) &#123; return userService.login(user);&#125;// --------------------------------------------------// 这里千万要给get、set方法或者Data注解@Data@ApiModel(value = &quot;User对象&quot;, description = &quot;用户模型&quot;)public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @TableId(value = &quot;id&quot;, type = IdType.AUTO) @ApiModelProperty(value = &quot;主键&quot;) private Integer id; @TableField(&quot;username&quot;) @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;admin&quot;) private String username; @TableField(&quot;password&quot;) @ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;123456&quot;) private String password;&#125; 不加@RequestBody的情景，可以直接在Parameters获取到加了@RequestBody的情景，显示No parameters，但Schema处可看到参数详情 MyBatis-plus配置&lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.72&lt;/version&gt;&lt;/dependency&gt;&lt;!--Swagger3.x--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--新版 mybatis-plus 自动生成器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- junit --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 自动生成import java.util.Collections;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;public class GeneratorTest &#123; public static void main(String[] args) &#123; // 配置相关的数据库连接 // TODO TODO FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;, &quot;123456&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;深海火锅店&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 // TODO TODO .outputDir(&quot;src\\\\main\\\\java\\\\&quot;) // 指定输出目录 .dateType(DateType.ONLY_DATE); &#125;).packageConfig(builder -&gt; &#123; // TODO TODO builder.parent(&quot;com.example.demo&quot;) // 设置父包名// .moduleName(&quot;&quot;) // 设置父包模块名 .entity(&quot;domain&quot;).controller(&quot;controller&quot;).mapper(&quot;mapper&quot;).service(&quot;service&quot;) .serviceImpl(&quot;service.impl&quot;) .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;src\\\\main\\\\resources\\\\mapper\\\\&quot;)); // 设置mapperXml生成路径 &#125;).strategyConfig(builder -&gt; &#123; // TODO TODO builder.addInclude(&quot;user&quot;)// 设置需要生成的表名 // TODO TODO// .addTablePrefix(&quot;tb_&quot;) // 设置过滤表前缀 .mapperBuilder() // 控制器controller配置 .controllerBuilder() // 开启生成@RestController 控制器 .enableRestStyle() // 开启驼峰转连字符 .enableHyphenStyle() // 开启父类// .superClass(&quot;com.example.demo.controller.BaseController&quot;) // 控制器统一后缀 .formatFileName(&quot;%sController&quot;) // service配置 .serviceBuilder() // service统一后缀 .formatServiceFileName(&quot;%sService&quot;) // serviceImpl统一后缀 .formatServiceImplFileName(&quot;%sServiceImpl&quot;) // mapper配置 .mapperBuilder() // 生成基础字段的map映射map .enableBaseResultMap() // 生成基础查询的sql .enableBaseColumnList() // 实体类配置 .entityBuilder() // 开启链式模型，开启lombok模型不需要开启这个// .enableChainModel() // 开启lombok模型 .enableLombok() // 开启表字段注解 .enableTableFieldAnnotation() // 逻辑删除字段 // TODO TODO .logicDeleteColumnName(&quot;is_deleted&quot;) // 数据库表映射到实体的命名策略 .naming(NamingStrategy.underline_to_camel) // 数据库表字段映射到实体的命名策略,驼峰命名，这个未设置会按照naming来配置// .columnNaming(NamingStrategy.underline_to_camel) // 指定实体类父类// .superClass(&quot;com.mybatisplus.generator.entity.BaseEntity&quot;) // 父类字段// .addSuperEntityColumns(&quot;id&quot;, &quot;create_id&quot;, &quot;modify_id&quot;, &quot;create_date&quot;, &quot;modify_date&quot;, &quot;is_deleted&quot;)// 开启 ActiveRecord 模式，即实体类继承Model类,自己提供CRUD操作,不建议使用,会和父类形成单继承冲突// .enableActiveRecord() // 表字段填充字段，对应数据库字段，插入的时候自动填充 .addTableFills(new Column(&quot;create_date&quot;, FieldFill.INSERT)) // 表字段填充字段，对应实体类字段，插入的时候自动填充 .addTableFills(new Property(&quot;createDate&quot;, FieldFill.INSERT)) // 表字段填充字段，对应数据库字段，更新的时候自动填充 .addTableFills(new Column(&quot;modify_date&quot;, FieldFill.UPDATE)) // 表字段填充字段，对应实体类字段，更新的时候自动填充 .addTableFills(new Property(&quot;modifyDate&quot;, FieldFill.UPDATE)) // 忽略的字段// .addIgnoreColumns(&quot;version&quot;) // id自增 .idType(IdType.AUTO); // 实体类统一后缀 &#125;).templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; # 应用名称 TODOspring.application.name=demo# 应用服务 WEB 访问端口server.port=8080# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址 TODOspring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC# 数据库用户名&amp;密码： TODOspring.datasource.username=rootspring.datasource.password=123456# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置最新全局配置文件#mybatis-plus.config-location=classpath:mybatis-config.xml# 配置mybatis-plus 包路径 TODOmybatis-plus.type-aliases-package=com.example.demo.domain# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto# 逻辑删除 （1为删除，0为未删除）#mybatis-plus.global-config.db-config.logic-delete-value=1#mybatis-plus.global-config.db-config.logic-not-delete-value=0# 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置#mybatis-plus.global-config.db-config.logic-delete-field=is_deleted // 配置分页插件@Configurationpublic class MyBatisPlusPaginationInnerConfig &#123; /** * 分页插件（官网最新） */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; // 分页测试@Testpublic void test1()&#123; // QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // wrapper.eq(&quot;weight&quot;,4); //第1页，每页2条 Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); IPage&lt;User&gt; UserIPage = userMapper.selectPage(page, null); System.out.println(&quot;总条数&quot;+UserIPage.getTotal()); System.out.println(&quot;总页数&quot;+UserIPage.getPages()); //获取当前数据 System.out.println(UserIPage.getRecords().toString());&#125; FastJsonfastjson jar包 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.72&lt;/version&gt;&lt;/dependency&gt; 用法 @Testpublic void returnJson() &#123; User user = new User(1, &quot;admin&quot;, &quot;123456&quot;, &quot;哈哈&quot;); System.out.println(&quot;user1:&quot; + user); // 对象转String System.out.println(&quot;user2:&quot; + JSON.toJSONString(user)); // 集合转json User user1 = new User(2, &quot;张三&quot;, &quot;123456&quot;, &quot;呵呵&quot;); User user2 = new User(2, &quot;李四&quot;, &quot;000&quot;, &quot;呵呵&quot;); List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(user1); users.add(user2); System.out.println(&quot;集合:&quot; + JSON.toJSONString(users)); // 解析json对象 System.out.println(&quot;解析:&quot; + JSON.parseObject(JSON.toJSONString(user)));&#125; 结果 user1:com.example.demo.domain.User@5b251fb9user2:&#123;&quot;id&quot;:1,&quot;nickName&quot;:&quot;哈哈&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;admin&quot;&#125;集合:[&#123;&quot;id&quot;:2,&quot;nickName&quot;:&quot;呵呵&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;张三&quot;&#125;,&#123;&quot;id&quot;:2,&quot;nickName&quot;:&quot;呵呵&quot;,&quot;password&quot;:&quot;000&quot;,&quot;username&quot;:&quot;李四&quot;&#125;]解析:&#123;&quot;password&quot;:&quot;123456&quot;,&quot;nickName&quot;:&quot;哈哈&quot;,&quot;id&quot;:1,&quot;username&quot;:&quot;admin&quot;&#125;","categories":[{"name":"常用配置、工具类","slug":"常用配置、工具类","permalink":"https://isunderachiever.github.io/categories/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"常用配置、工具类","slug":"常用配置、工具类","permalink":"https://isunderachiever.github.io/tags/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"Optional使用","slug":"编程语言/Java/学习/基础/007_Optional使用","date":"2023-03-05T09:00:00.000Z","updated":"2024-06-01T14:12:24.916Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/007-optional-shi-yong.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/007-optional-shi-yong.html","excerpt":"","text":"Optional使用安全的消费值/** * 得到用户对象 * * @return */public static User getUser() &#123; User user = new User(); user.setUid(1); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); return user;&#125;public static void main(String[] args) &#123; User user = getUser(); Optional&lt;User&gt; userOptional = Optional.ofNullable(user); // 如果user对象不为空，则执行ifPresent的lambda表达式；反之，不执行 userOptional.ifPresent(item -&gt; System.out.println(item.getUsername()));&#125; 安全的获取值 Optional对象的get方法(不推介) orElseGet()方法和orElseThrow()方法(推介) /** * 得到Optional&lt;User&gt;对象 * * @return */public static Optional&lt;User&gt; getUser() &#123; User user = new User(); user.setUid(1); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); return Optional.ofNullable(user);&#125;public static void main(String[] args) &#123; Optional&lt;User&gt; userEntity = getUser(); // 使用Optional对象的get方法来获取User值 System.out.println(userEntity.get());&#125; // 不推介使用Optional对象的get方法，如果user对象为空，会抛出以下异常Exception in thread &quot;main&quot; java.util.NoSuchElementException: No value present at java.util.Optional.get(Optional.java:135) at com.example.test.Test1.main(Test1.java:21) 推介使用orElseGet()方法和orElseThrow()方法 /** * 得到Optional&lt;User&gt;对象 * * @return */public static Optional&lt;User&gt; getUser() &#123; User user = new User(); user.setUid(1); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); return Optional.ofNullable(user);&#125;public static void main(String[] args) &#123; Optional&lt;User&gt; userEntity = getUser(); // 如果user对象为null，则会返回orElseGet内定义的默认值 User user = userEntity.orElseGet(() -&gt; new User(2, &quot;哈哈&quot;, &quot;123&quot;)); System.out.println(user);&#125; /** * 得到Optional&lt;User&gt;对象 * * @return */public static Optional&lt;User&gt; getUser() &#123; User user = new User(); user.setUid(1); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); return Optional.ofNullable(null);&#125;public static void main(String[] args) &#123; Optional&lt;User&gt; userEntity = getUser(); // 如果该值为空，则会抛出异常，可通过Spring的全局异常处理优雅的返回值 User user = userEntity.orElseThrow(() -&gt; new RuntimeException(&quot;该值不可为空&quot;)); System.out.println(user);&#125;","categories":[{"name":"Optional使用","slug":"Optional使用","permalink":"https://isunderachiever.github.io/categories/Optional%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Optional使用","slug":"Optional使用","permalink":"https://isunderachiever.github.io/tags/Optional%E4%BD%BF%E7%94%A8/"}]},{"title":"Spring Tools Suite安装及配置","slug":"系统配置/编程配置/环境配置/STS配置/STS安装及配置","date":"2023-03-04T15:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/sts-pei-zhi/sts-an-zhuang-ji-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/sts-pei-zhi/sts-an-zhuang-ji-pei-zhi.html","excerpt":"","text":"安装Spring Tools Suite 3 spring-tool-suite-3.9.18 遇到的问题如下解决方法装的jdk1.8，却显示17，这不是离谱吗？ java_home配置也没有问题，确实是1.8的路径原因出在oracle这里，将oracle一道java环境变量之下即可到这里还是依然报错，java版本不在11以上 网上说把ini文件的11改为1.8即可，但我的还是报错，还是直接配置3.9.11版本或者sts4吧 官网 spring-tool-suite-3.9.18（不推介） spring-tool-suite-3.9.11（推介） Spring Tools Suite 4spring-tool-suite-4-4.3.1 配置取消空格或分号自动补全 .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY 快捷键配置 这个是按照我的习惯配置的，如果不需要配置，请直接跳过复制整行，如idea的ctrl+d，我习惯配置alt+d这个是代码提示快捷键format 格式化代码快捷键 方法提取(Extract method) 全局查找(Find Text in File) 开启注解提示 配置maven 配置本地java 编码配置 配置Lombok插件lombok jar包 将lombok放在sts.exe文件处 双击jar包 配置字体 配置代码模板 自动导包 配置tomcatwindow》show view》other》servers 普通的java项目如何使用jar包","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":" Spring Tools Suite安装及配置","slug":"Spring-Tools-Suite安装及配置","permalink":"https://isunderachiever.github.io/tags/Spring-Tools-Suite%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"}]},{"title":"tomcat安装及配置","slug":"系统配置/编程配置/环境配置/Tomcat配置/tomcat配置","date":"2023-03-04T15:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tomcat-pei-zhi/tomcat-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/tomcat-pei-zhi/tomcat-pei-zhi.html","excerpt":"","text":"tomcat安装及配置tomcat-8.5.87安装 环境变量配置新建 CATALINA_HOME值：解压后的路径，如D:\\apache-tomcat-8.5.87path，新建%CATALINA_HOME%\\bin验证是否配置成功？cmd输入startup.bat打开localhost:8080 tomcat乱码","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"tomcat安装及配置","slug":"tomcat安装及配置","permalink":"https://isunderachiever.github.io/tags/tomcat%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"}]},{"title":"Elasticsearch基础","slug":"编程语言/Java/学习/框架/Elasticsearct/Elasticsearch文档操作","date":"2023-02-25T09:12:00.000Z","updated":"2024-06-01T14:32:53.438Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearch-wen-dang-cao-zuo.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/elasticsearct/elasticsearch-wen-dang-cao-zuo.html","excerpt":"","text":"Elasticsearch基础环境配置 ![image-20230224221154537](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202302242212916.png) ### 创建、查询、删除、修改 索引库 # Click the Variables button, above, to create your own variables.GET $&#123;exampleVariable1&#125; // _search&#123; &quot;query&quot;: &#123; &quot;$&#123;exampleVariable2&#125;&quot;: &#123;&#125; // match_all &#125;&#125;GET _analyze&#123; &quot;analyzer&quot;: &quot;pinyin&quot;, &quot;text&quot;: &quot;刘德华&quot;&#125;GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;我的字典里没有白嫖&quot;&#125;GET _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我的字典里没有白嫖&quot;&#125;# 创建索引库PUT /user&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, &quot;index&quot;:false &#125;, &quot;nick_name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;username&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;password&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125; &#125; &#125;&#125;# 查找索引库GET /user# 删除索引库DELETE /user# 修改索引库# 事实上，索引库创建后是不允许修改的# 修改字段时会导致原有的倒排索引失效# 禁止修改原有的字段，但可以添加新的字段# 一定要是一个全新的字段名，不能与原有的字段名相同# 修改索引库的本质是，添加新字段PUT /user/_mapping&#123; &quot;properties&quot;:&#123; &quot;新字段名&quot;:&#123; &quot;type&quot;:&quot;integer&quot; &#125; &#125;&#125; ### 文档的CRUD操作 # 插入文档POST /user/_doc/1&#123; &quot;nick_name&quot;:&quot;小美&quot;&#125;# 查询文档GET /user/_doc/1# 删除文档DELETE /user/_doc/1 #### 修改文档 ![image-20230224224312857](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202302242243003.png) # 全量修改文档PUT /user/_doc/1&#123; &quot;nick_name&quot;:&quot;小美&quot;&#125;# 新增# 由于不存在id为2的文档PUT /user/_doc/2&#123; &quot;nick_name&quot;:&quot;妹妹&quot;&#125;# 局部修改字段POST /user/_update/1&#123; &quot;doc&quot;:&#123; &quot;nick_name&quot;:&quot;小美&quot; &#125;&#125;","categories":[{"name":"elastic","slug":"elastic","permalink":"https://isunderachiever.github.io/categories/elastic/"}],"tags":[]},{"title":"表单校验+异常处理","slug":"编程语言/Java/学习/框架/SpringBoot/表单校验+异常处理","date":"2023-02-18T09:12:00.000Z","updated":"2024-06-01T14:32:53.429Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/biao-dan-xiao-yan-yi-chang-chu-li.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/biao-dan-xiao-yan-yi-chang-chu-li.html","excerpt":"","text":"表单校验JSR303 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 给Bean添加校验注解如@Email 标注的字段为邮箱、@NotNull 标注的字段不能为空、@Future 标注的字段必须是未来的时间、@Min标注最小值 // 若不写message，则返回默认信息@NotBlank(message = &quot;用户名不能为空&quot;)@TableField(value = &quot;username&quot;)private String username; 开启校验注解@Valid，告知spring方法需要开启校验这些字段，上面只是标注了校验规则，标注（@Valid） @PostMapping(&quot;/test&quot;)public String test(@Valid @RequestBody User user)&#123; return &quot;error1&quot;;&#125; 获取校验的结果，校验是否成功…，紧跟参数后面添加BindingResult result，示例如下： @PostMapping(&quot;/test&quot;)public Object test(@Valid @RequestBody User user, BindingResult result)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 如果校验出错 if (result.hasErrors())&#123; Map&lt;String, String&gt; error = new HashMap&lt;&gt;(); // 获取校验的错误结果 result.getFieldErrors().forEach((item)-&gt;&#123; // FieldError 获取到错误提示 String message = item.getDefaultMessage(); // 获取错误的属性名字 String field = item.getField(); error.put(field,message); &#125;); map.put(&quot;code&quot;,500); map.put(&quot;message&quot;,error); &#125;else&#123; // 校验未出错 map.put(&quot;code&quot;,200); map.put(&quot;message&quot;,user); &#125; return map;&#125; 自定义校验规则// regexp内写 正则表达式 @Pattern(regexp = &quot;/^[a-zA-Z0-9]$/&quot;,message = &quot;昵称必须是一个字母或数字&quot;)@TableField(value = &quot;nick_name&quot;)private String nick_name; 配置全局异常处理 类添加注解 @ControllerAdvice 如果需要返回json数据，则需要在方法上加上@ResponseBody @RestControllerAdvice，默认返回json数据，方法不需要加@ResponseBody 区别:参考@RestController和@Controller的 方法添加处理器 捕获全局异常，处理所有不可知异常 @ExceptionHandler(value&#x3D;Exception.class) import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@Slf4j@RestControllerAdvice(basePackages = &quot;com.example.exceptiontest.controller&quot;)public class UserExceptionControllerAdvice &#123; @ExceptionHandler(value = Exception.class) public Object handleValidException(Exception e)&#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;message&quot;,e.getMessage()); map.put(&quot;class&quot;,e.getClass().toString()); log.error(&quot;数据校验出现异常:&#123;&#125;，异常类型:&#123;&#125;&quot;,e.getMessage(),e.getClass()); return map; &#125;&#125; 既然要进行异常处理，那么上方配置的校验就需要抛出异常，去掉BindingResult即可 @PostMapping(&quot;/test2&quot;)public Object test2(@Valid @RequestBody User user)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,200); map.put(&quot;message&quot;,user); return map;&#125; 指定的异常类型需要更精确才行 @Slf4j@RestControllerAdvice(basePackages = &quot;com.example.exceptiontest.controller&quot;)public class UserExceptionControllerAdvice &#123; @ExceptionHandler(value = MethodArgumentNotValidException.class) public Object handleValidException(MethodArgumentNotValidException e)&#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); BindingResult bindingResult = e.getBindingResult(); map.put(&quot;code&quot;,&quot;400&quot;); bindingResult.getFieldErrors().forEach((item)-&gt;&#123; map.put(item.getField(),item.getDefaultMessage()); &#125;); map.put(&quot;msg&quot;,&quot;数据校验出现异常&quot;); log.error(&quot;数据校验出现异常:&#123;&#125;，异常类型:&#123;&#125;&quot;,e.getMessage(),e.getClass()); return map; &#125;&#125; 为了更加统一、方便地编写返回状态码，可创建一个枚举类 public enum BizCodeEnume &#123; /** * 系统未知异常 */ UNKNOWN_EXCEPTION(10000,&quot;系统未知异常&quot;), /** * 参数格式校验失败 */ VAILD_EXCEPTION(10001,&quot;参数格式校验失败&quot;); private final int code; private final String msg; BizCodeEnume(int code, String msg)&#123; this.code = code; this.msg = msg; &#125; /** * 获取状态码 * * @return int */ public int getCode() &#123; return code; &#125; /** * 获取信息 * * @return &#123;@link String&#125; */ public String getMsg() &#123; return msg; &#125;&#125; @Slf4j@RestControllerAdvice(basePackages = &quot;com.example.exceptiontest.controller&quot;)public class UserExceptionControllerAdvice &#123; @ExceptionHandler(value = MethodArgumentNotValidException.class) public Object handleValidException(MethodArgumentNotValidException e)&#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); BindingResult bindingResult = e.getBindingResult(); map.put(&quot;code&quot;, String.valueOf(BizCodeEnume.VAILD_EXCEPTION.getCode())); bindingResult.getFieldErrors().forEach((item)-&gt;&#123; map.put(item.getField(),item.getDefaultMessage()); &#125;); map.put(&quot;msg&quot;,BizCodeEnume.VAILD_EXCEPTION.getMsg()); log.error(&quot;数据校验出现异常:&#123;&#125;，异常类型:&#123;&#125;&quot;,e.getMessage(),e.getClass()); return map; &#125; /** * 处理最大的异常 * * @param e e * @return &#123;@link Object&#125; */ @ExceptionHandler(value = Throwable.class) public Object handleException(Throwable e)&#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,String.valueOf(BizCodeEnume.UNKNOWN_EXCEPTION.getCode())); map.put(&quot;msg&quot;,BizCodeEnume.UNKNOWN_EXCEPTION.getMsg()); return map; &#125;&#125; 自定义异常 注释掉之前写过的@NotBlank(message = &quot;用户名不能为空&quot;)…参数校验注解 public class UsernameOrPasswordNULLException extends RuntimeException &#123; public UsernameOrPasswordNULLException(String message) &#123; super(message); &#125;&#125; // 捕获UsernameOrPasswordNULLException异常@ExceptionHandler(value = UsernameOrPasswordNULLException.class)public Object usernameOrPasswordIsNull(UsernameOrPasswordNULLException e)&#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 获取状态码 map.put(&quot;code&quot;, &quot;501&quot;); // 获取信息 map.put(&quot;msg&quot;,&quot;用户名或密码为空&quot;); return map;&#125; @PostMapping(&quot;/test3&quot;)public Object test3(@RequestBody User user)&#123; String username=user.getUsername(); String password=user.getPassword(); if(username==null || &quot;&quot;.equals(username)||password==null ||&quot;&quot;.equals(password))&#123; throw new UsernameOrPasswordNULLException(&quot;用户名或密码不能为空&quot;); &#125; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,200); map.put(&quot;message&quot;,user); return map;&#125; 分组校验 各个业务场景下的参数校验规则可能是不一样的比如新增用户时，id字段自增，所以不需要填写，但删除用户时，id字段必须要填写 此时需要使用到分组校验功能给注解标明，何时使用A校验规则，何时使用B校验规则 // 指定组AddGroup，新建AddGroup接口，什么都不用写;DeleteGroup 也一样@Null(message = &quot;新增用户时，不能指定用户id&quot;,groups = &#123;AddGroup.class&#125;)@NotNull(message = &quot;删除用户时，必须指定用户id&quot;,groups = &#123;DeleteGroup.class&#125;)@TableId(value = &quot;id&quot;, type = IdType.AUTO)private Integer id; public interface AddGroup &#123;&#125;public interface DeleteGroup &#123;&#125; 将@Valid注解 改为 @Validated注解 @PostMapping(&quot;/save&quot;)public Object saveUser(@Validated(&#123;AddGroup.class&#125;) @RequestBody User user) &#123; boolean saveFlag = userService.save(user); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, 200); map.put(&quot;message&quot;, saveFlag ? &quot;保存成功&quot; : &quot;保存失败&quot;); return map;&#125;@DeleteMapping(&quot;/delete&quot;)public Object deleteUser(@Validated(&#123;DeleteGroup.class&#125;) @RequestBody User user) &#123; boolean saveFlag = userService.removeById(user.getId()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, 200); map.put(&quot;message&quot;, saveFlag ? &quot;删除成功&quot; : &quot;删除失败&quot;); return map;&#125; 若校验注解如@NotNull不指定group，那么在执行方法时，会校验吗？答案是不会校验，不标注分组的校验注解是不起作用的 自定义校验 若正则表达式无法满足业务需求，需要自定义校验逻辑 编写自定义校验注解 编写自定义校验器 关联校验器和注解，让校验器来校验注解标注的字段@NickValue(vals=&#123;&quot;喜羊羊&quot;,&quot;灰太狼&quot;&#125;)@TableField(value = &quot;nick_name&quot;)private String nick_name; import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;@Documented// 这里需要指定校验器，暂时先空着，等到后面再编写校验器@Constraint( validatedBy = &#123;&#125;)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface NickValue &#123; /** * 消息 * 这里写该注解的全类名 * 若校验失败，会前往ValidationMessages.properties来查询失败信息 * 所以我们需要自己配置一个ValidationMessages.properties * * @return &#123;@link String&#125; */ String message() default &quot;&#123;com.example.exceptiontest.valid.NickValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; String[] vals() default &#123;&#125;;&#125; com.example.exceptiontest.valid.NickValue.message=昵称必须为指定的值 编写自定义校验器import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;import java.util.HashSet;import java.util.Set;/** * 自定义昵称校验器 * ConstraintValidator&lt;NickValue,String&gt; 前面为注解，后面为校验的字段类型 * 如此时校验的字段是nickname，它的类型是String * * @author tong * @date 2023/02/18 */public class NickValueConstraintValidator implements ConstraintValidator&lt;NickValue,String&gt; &#123; private Set&lt;String&gt; set=new HashSet&lt;String&gt;(); /** * 初始化 * * @param constraintAnnotation 约束注释 */ @Override public void initialize(NickValue constraintAnnotation) &#123; String[] vals = constraintAnnotation.vals(); for (String val : vals) &#123; set.add(val); &#125; &#125; /** * 是否校验成功 * * @param s 昵称 * @param constraintValidatorContext 约束验证器上下文 * @return boolean */ @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123; if(set.contains(s))&#123; return true; &#125; return false; &#125;&#125; 别忘了在注解上添加对应的校验器 @Documented// 添加对应的校验器@Constraint( validatedBy = &#123;NickValueConstraintValidator.class&#125;)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface NickValue &#123; /** * 消息 * 这里写该注解的全类名 * 若校验失败，会前往ValidationMessages.properties来查询失败信息 * 所以我们需要自己配置一个ValidationMessages.properties * * @return &#123;@link String&#125; */ String message() default &quot;&#123;com.example.exceptiontest.valid.NickValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; String[] vals() default &#123;&#125;;&#125; 打印一下错误信息 @ExceptionHandler(value = Throwable.class)public Object handleException(Throwable e)&#123; // 打印错误信息 log.error(&quot;错误:&quot;,e); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 获取状态码 map.put(&quot;code&quot;,String.valueOf(BizCodeEnume.UNKNOWN_EXCEPTION.getCode())); // 获取信息 map.put(&quot;msg&quot;,BizCodeEnume.UNKNOWN_EXCEPTION.getMsg()); return map;&#125; 指定分组 @NickValue(vals=&#123;&quot;喜羊羊&quot;,&quot;灰太狼&quot;&#125;,groups = &#123;AddGroup.class, DeleteGroup.class&#125;)@TableField(value = &quot;nick_name&quot;)private String nick_name; 校验注解指定多个校验器 // 这里可以添加多个校验器@Constraint( validatedBy = &#123;NickValueConstraintValidator.class&#125;) 此步骤参考博客 按住ctrl+H可以看到存在很多校验器需要注意的问题如下UserUserController在修改用户的时候，我们是需要传入密码和昵称的 但是实际在个人主页修改个人昵称的时候，如果前端传递的user对象里只包含用户id和昵称而不包含密码，那么此时的校验无法通过因为在修改方法内并未传入密码但是也无法删除密码注解的UpdateGroup，否则修改密码的时候如果不传入密码也能通过校验 原因是修改昵称和修改密码调用的是同一个修改方法和同一个UpdateGroup 解决方法：修改方法分开编写，不要合并成同一个方法；同时创建一个新的修改分组，如UpdateNiceNameGroup","categories":[{"name":"表单校验+异常处理","slug":"表单校验-异常处理","permalink":"https://isunderachiever.github.io/categories/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"tags":[]},{"title":"Java环境变量配置","slug":"系统配置/编程配置/环境配置/Java环境变量配置/java环境变量配置","date":"2023-02-18T08:20:00.000Z","updated":"2024-06-01T14:12:24.894Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/java-huan-jing-bian-liang-pei-zhi/java-huan-jing-bian-liang-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/java-huan-jing-bian-liang-pei-zhi/java-huan-jing-bian-liang-pei-zhi.html","excerpt":"","text":"JDK下载jdk下载 Java环境变量配置JAVA_HOMED:\\java\\jdkPath编辑，新增%JAVA_HOME%\\bin%JAVA_HOME%\\jre\\bin","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"MySQL配置","slug":"系统配置/编程配置/环境配置/MySQL配置/MySQL配置","date":"2023-02-18T08:20:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/mysql-pei-zhi/mysql-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/mysql-pei-zhi/mysql-pei-zhi.html","excerpt":"","text":"MySQL安装 一直next剩下的默认即可，一直next mysql环境变量配置path添加D:\\MySQL\\MySQL Server 8.0\\bin MySQL时区配置打开mysql的安装目录，比如我的是D:\\MySQL\\MySQL Server 8.0打开my.ini，添加下面这句，重启服务 # [mysqld]# 永久更改时区，解决连接mysql时timeout的情况default-time_zone = &#x27;+8:00&#x27; # 查看时区是否设置成功show variables like &quot;%time_zone%&quot;; mysql&gt; show variables like &quot;%time_zone%&quot;;+------------------+--------+| Variable_name | Value |+------------------+--------+| system_time_zone | || time_zone | +08:00 |+------------------+--------+2 rows in set, 1 warning (0.01 sec) 若出现以上结果即可","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"PowerDesigner配置","slug":"系统配置/编程配置/环境配置/powerdesigner配置/PowerDesigner配置","date":"2023-02-18T08:20:00.000Z","updated":"2024-06-01T14:32:53.520Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/powerdesigner-pei-zhi/powerdesigner-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/powerdesigner-pei-zhi/powerdesigner-pei-zhi.html","excerpt":"","text":"PowerDesigner安装 PowerDesigner破解 复制pdflm16.dll破解文件至安装文件夹，替换掉原本的文件 注册表配置 安装PowerDesigner之后，右键新建又多出了超级多的文件，这一步就是删除掉这些这数量，是不是巨恐怖？ win+R输入regedit，回车 看一下文件后缀.BPM.CDM.DMM.EAM.FEM.LDM.OOM.PDM.RQM.XSM","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"踩坑","slug":"报错记录/SpringBoot/Alibaba版本冲突、Nacos、OpenFeign","date":"2023-01-20T13:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/springboot/alibaba-ban-ben-chong-tu-nacos-openfeign.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/springboot/alibaba-ban-ben-chong-tu-nacos-openfeign.html","excerpt":"","text":"之前一直在做谷粒商城，确实学到了不少知识点，还有黑马的一个微服务全栈课程（哔哩哔哩有）感觉学了不少，eruka、nacos、feign、rabbitmq、es但是吧，一直往下学，感觉之前学过的知识点又不太清晰了就准备了这个小项目试试水，结果…泪目了 springboot、springcloud、springcloud alibaba版本不匹配 这个错误仅代表其中一种，意思就是版本不匹配大部分的错误都是版本不匹配、冲突造成如java.lang.AbstractMethodError: null、等折磨了我半天在博客上找了好多所谓的“毕业版本依赖关系(推介使用)”然后就是不停的报java.lang.AbstractMethodError: null这个错网上说是由于版本不匹配造成，项目根本跑不起来github上有版本说明，详情查看 Spring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2021.0.4.0* Spring Cloud 2021.0.4 2.6.11 2021.0.1.0 Spring Cloud 2021.0.1 2.6.3 2021.1 Spring Cloud 2020.0.1 2.4.2 2.2.10-RC1* Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.9.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.8.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.7.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.6.RELEASE Spring Cloud Hoxton.SR9 2.3.2.RELEASE 2.2.1.RELEASE Spring Cloud Hoxton.SR3 2.2.5.RELEASE 2.2.0.RELEASE Spring Cloud Hoxton.RELEASE 2.2.X.RELEASE 2.1.4.RELEASE Spring Cloud Greenwich.SR6 2.1.13.RELEASE 2.1.2.RELEASE Spring Cloud Greenwich 2.1.X.RELEASE 2.0.4.RELEASE(停止维护，建议升级) Spring Cloud Finchley 2.0.X.RELEASE 1.5.1.RELEASE(停止维护，建议升级) Spring Cloud Edgware 1.5.X.RELEASE Spring Cloud Alibaba Version Sentinel Version Nacos Version ——————————————————— —————- ————- 2.2.10-RC1 1.8.6 2.2.0 2022.0.0.0-RC1 1.8.6 2.2.1-RC 2.2.9.RELEASE 1.8.5 2.1.0 2021.0.4.0 1.8.5 2.0.4 2.2.8.RELEASE 1.8.4 2.1.0 2021.0.1.0 1.8.3 1.4.2 2.2.7.RELEASE 1.8.1 2.0.3 2.2.6.RELEASE 1.8.1 1.4.2 2021.1 or 2.2.5.RELEASE or 2.1.4.RELEASE or 2.0.4.RELEASE 1.8.0 1.4.1 2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE 1.8.0 1.3.3 2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE 1.7.1 1.2.1 2.2.0.RELEASE 1.7.1 1.1.4 2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE 1.7.0 1.1.4 2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE 1.6.3 1.1.1 这里我用的是2.3.12.RELEASE的springboot、Hoxton.SR12的springcloud、2.2.9.RELEASE的springcloud alibaba，但是有个需要注意的地方，nacos的版本需要在2.1.0，我以前用的nacos是1.4.1，报错nacos版本不匹配，详情查看 com.alibaba.nacos.api.exception.NacosException: Request nacos server failed: 这里我找了好多博文，发现了这样一篇，原文连接 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 我一直以来并不是这种写法，而是如下写法 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 第一次发现还有这种写法，记录一下 nacos动态刷新–空指针 详情参考这篇博客在nacos中实现自动热部署用@RefreshScope出现空指针异常。今天使用nacos的时候发现了这个问题只有配置中心出现了问题 @RefreshScope@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Value(&quot;$&#123;app.user.name&#125;&quot;) private String name; @Value(&quot;$&#123;app.user.gender&#125;&quot;) private String gender; @Value(&quot;$&#123;app.user.age&#125;&quot;) private Integer age; @Autowired private UserService userService; @GetMapping(&quot;/list&quot;) public R listUser()&#123; return R.ok().put(&quot;data&quot;,userService.list()); &#125; @GetMapping(&quot;/&#123;id&#125;&quot;) private R getUser(@PathVariable(&quot;id&quot;) Integer id)&#123; return R.ok().put(&quot;data&quot;,userService.getOne(new QueryWrapper&lt;User&gt;().eq(&quot;id&quot;,id))); &#125; @GetMapping(&quot;/test1&quot;) private R test1()&#123; return R.ok().put(&quot;name&quot;,name).put(&quot;gender&quot;,gender).put(&quot;age&quot;,age); &#125;&#125; 就这么一个简单的controller，添加@RefreshScope注解之前都没问题加了之后user/&#123;id&#125;就开始报空指针了小泽不会Java大佬是这么解释的：@RefreshScope他的默认代理方式是CGLIB，但是spring中默认的代理也是CGLIB，就相当于它被代理了两次，这样可能就会导致数据消失解决方法1：将@RefreshScope改为@RefreshScope(proxyMode = ScopedProxyMode.DEFAULT) 解决方法2：不使用@RefreshScope，使用@ConfigurationProperties注解 注意：不是使用@ConfigurationProperties注解来替换@RefreshScope，详细请看下文 app.user.name=深海app.user.age=22app.user.gender=男 // 配置类@Data@Component@ConfigurationProperties(prefix = &quot;app.user&quot;)public class PatternProperties &#123; private String name; private String gender; private Integer age;&#125; @PropertySource(&quot;classpath:test.properties&quot;)@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private PatternProperties properties; @Autowired private UserService userService; @GetMapping(&quot;/test1&quot;) private R test1()&#123; return R.ok().put(&quot;name&quot;,properties.getName()).put(&quot;gender&quot;,properties.getGender()).put(&quot;age&quot;,properties.getAge()); &#125;&#125; 人人开源-代码生成–500 老实说，这些谷粒商城的视频里都有，时间太久，我有些记不清了在url地址栏输入localhost:80，之后回车，变成了localhost，报500看到了这样一篇博客和博主是一样的问题解决方法：http://localhost:/index.html 人人开源-代码生成–serviceimpl报错看到了一篇博客，说是导包的问题 我看了又看，包没有什么问题，并不是这个原因 接下来又看到了这篇博客的p17，是一个大佬记录自己的谷粒商城踩坑记录 第17条，serviceImpl 分页代码报错问题，那是因为你copy代码的时候去的是renrengenerator模块，应该去renrenfast 里面copy。 恍然大悟，确实是这样，解决方法就是去renren-fast里复制 以前没注意到这个问题，没踩过这个坑，现在终于补齐了… open feign返回值为null feign的调用是成功了一半，可以看到user服务已经查询到了，但奇怪的是vacc服务没接收到 上网搜了一下为null的情况，查看 对比了一下自己的代码，@EnableFeignClients、@EnableDiscoveryClient、@FeignClient(&quot;vaccine-user&quot;) 注解该在的都在，不是这个问题 返回数据中多对一实体中还包含了一对多的关系也会返回null，我之前数据库里确实有写一对多的数据本来是想试验一下来着，但仔细一看代码，不是这个问题 错误原因：返回值的问题，被调用的方法的返回值是renren-fast的R，但clients接口的返回值是User这个就是纯纯粗心了，太憨了 排除mybatis-plus相关依赖 这是由于导入了mybatis-plus相关依赖却没有配置数据库的原因但是网关服务本就不需要配置数据库所以解决方法就是把相关依赖排除在外 @EnableDiscoveryClient@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)public class VaccineGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(VaccineGatewayApplication.class, args); &#125;&#125;","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://isunderachiever.github.io/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://isunderachiever.github.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"Spring Project","slug":"编程语言/Java/学习/框架/Spring/SpringIOC+SpringAOP+MyBatis","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.946Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc-springaop-mybatis.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc-springaop-mybatis.html","excerpt":"","text":"Spring ProjectSpringIOCSpringAOP、MyBatis","categories":[{"name":"Spring","slug":"Spring","permalink":"https://isunderachiever.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://isunderachiever.github.io/tags/Spring/"}]},{"title":"10_多切面顺序问题","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/10_多切面顺序问题","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.965Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/10-duo-qie-mian-shun-xu-wen-ti.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/10-duo-qie-mian-shun-xu-wen-ti.html","excerpt":"","text":"10_多切面顺序问题 在实际项目中我们可能会存在配置了多个切面的情况。这种情况下我们很可能需要控制切面的顺序。我们在默认情况下Spring有它自己的排序规则。(按照类名排序)默认排序规则往往不符合我们的要求，我们需要进行特殊控制。如果是注解方式配置的AOP可以在切面类上加@Order注解来控制顺序。如果是XML方式配置的AOP,可以通过配置顺序来控制。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; @Servicepublic class DoService &#123; public void doService()&#123; System.out.println(&quot;doService&quot;); &#125;&#125; @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Log &#123;&#125; @Component@Aspect@Order(2)public class MyAspect &#123; @Pointcut(&quot;execution(* com.example.service..*.doService(..))&quot;) public void doService()&#123;&#125; @Around(&quot;doService()&quot;) public Object doAround(ProceedingJoinPoint pjp)&#123; Object result = null; try &#123; System.out.println(&quot;MyAspect增强&quot;); result=pjp.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return result; &#125;&#125; @Component@Aspect@Order(1)public class MyAspect2 &#123; @Pointcut(&quot;execution(* com.example.service..*.doService(..))&quot;) public void doService()&#123;&#125; @Around(&quot;doService()&quot;) public Object doAround(ProceedingJoinPoint pjp)&#123; Object result = null; try &#123; System.out.println(&quot;MyAspect2增强&quot;); result=pjp.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; return result; &#125;&#125; public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DoService bean = context.getBean(DoService.class); bean.doService(); &#125;&#125; // 执行结果MyAspect2增强MyAspect增强doService 总结 order越小，优先级越高","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"11_AOP原理-动态代理","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/11_AOP原理-动态代理","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.966Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/11-aop-yuan-li-dong-tai-dai-li.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/11-aop-yuan-li-dong-tai-dai-li.html","excerpt":"","text":"11_AOP原理-动态代理 实际上Spring的AOP其实底层就是使用动态代理来完成的。并且使用了两种动态代理分别是JDK的动态代理和Cglib动态代理。所以我们接下去来学习下这两种动态代理，理解下它们的不同点。 JDK动态代理 JDK的动态代理使用的java.lang.reflect.Proxy这个类来进行实现的。要求被代理（被增强)的类需要实现了接口。并且JDK动态代理也只能对接口中的方法进行增强。 public class Main &#123; public static void main(String[] args) &#123; AIControllerImpl aiController = new AIControllerImpl(); //String answer = aiController.getAnswer(&quot;张三很帅吗？&quot;); //System.out.println(answer); // 使用动态代理增强getAnswer方法 // 1.JDK动态代理 // 获取类加载器 ClassLoader classLoader = Main.class.getClassLoader(); // 被代理类所实现接口的字节码对象数组 Class&lt;?&gt;[] interfaces = AIControllerImpl.class.getInterfaces(); // 使用代理对象（proxy）时，会调用invoke AIController proxy = (AIController) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // proxy是代理对象 // method是当前被调用的方法封装的Method对象 // args是调用方法时传入的参数 // 调用被代理对象的对应方法 // 判断当前调用的是否是getAnswer方法 if (&quot;getAnswer&quot;.equals(method.getName())) &#123; System.out.println(&quot;已增强&quot;); &#125; Object ret = method.invoke(aiController, args); return ret; &#125; &#125;); String answer1 = proxy.getAnswer(&quot;张三很帅？&quot;); System.out.println(answer1); &#125;&#125; Cglib动态代理 使用的是org.springframework.cglib.proxy.Enhancer类进行实现的。已被spring中包含，pom导入ioc依赖即可 public class Demo &#123; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); // 设置父类的字节码对象。即enhancer生成的代理对象为AIControllerImpl的子对象 enhancer.setSuperclass(AIControllerImpl.class); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() &#123; // 使用代理对象执行方法时，都会调用到intercept方法中 @Override public Object intercept(Object o, Method method, Object[] objects /*传入参数的数组*/, MethodProxy methodProxy) throws Throwable &#123; // 判断当前调用的方法是不是getAnswer,若是，则进行增强 if(&quot;getAnswer&quot;.equals(method.getName())) &#123; System.out.println(&quot;方法已增强&quot;); &#125; // methodProxy.invokeSuper(); // 调用父类中对应的方法 return methodProxy.invokeSuper(o, objects); &#125; &#125;); // 生成代理对象 AIControllerImpl proxy = (AIControllerImpl) enhancer.create(); System.out.println(proxy.getAnswer(&quot;我帅吗&quot;)); &#125;&#125; 总结 JDK动态代理要求被代理（被增强）的类必须要实现接口，生成的代理对象相当于是被代理对象的兄弟。 Cglib的动态代理不要求被代理（被增强）的类要实现接口，生成的代理对象相当于被代理对象的子类对象。 Spring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"12_注解方式配置AOP如何切换动态代理类型","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/12_注解方式配置AOP如何切换动态代理类型","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.967Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/12-zhu-jie-fang-shi-pei-zhi-aop-ru-he-qie-huan-dong-tai-dai-li-lei-xing.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/12-zhu-jie-fang-shi-pei-zhi-aop-ru-he-qie-huan-dong-tai-dai-li-lei-xing.html","excerpt":"","text":"12_注解方式配置AOP如何切换动态代理类型 有的时候我们需要修改AOP的代理方式。我们可以使用以下方式修改:如果我们是采用注解方式配置AOP的话:设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 如果我们是采用xml方式配置AOP的话:设置aop:config标签的proxy-target-class属性为true,代理方式就会修改成Cglib &lt;aop:config proxy-target-class=&quot;true&quot;/&gt;","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"1_Spring整合Junit","slug":"编程语言/Java/学习/框架/Spring/Spring整合MyBatis、Junit及事务/1_Spring整合Junit","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.980Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/1-spring-zheng-he-junit.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/1-spring-zheng-he-junit.html","excerpt":"","text":"1_Spring整合Junit&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring_AOP_7_Junit&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring整合Junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写测试类 在测试类上加上@RunWith(SpringJUnit4ClassRunner.class)注解，指定让测试运行于Spring环境@ContextConfiguration注解，指定Spring容器创建需要的配置文件或者配置类 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:配置文件.xml&quot;&#125;)@ContextConfiguration(classes = spring配置类.class) @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MyTest &#123; @Autowired private DoService doService; @Test public void test1()&#123; System.out.println(doService.success(&quot;code&quot;)); &#125;&#125;","categories":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}]},{"title":"4_实现声明式事务","slug":"编程语言/Java/学习/框架/Spring/Spring整合MyBatis、Junit及事务/4_实现声明式事务","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:32:53.508Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/4-shi-xian-sheng-ming-shi-shi-wu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/4-shi-xian-sheng-ming-shi-shi-wu.html","excerpt":"","text":"4_实现声明式事务 这里会发生异常，用来模拟支付过程中的突发情况导致支付失败，如网络原因等 测试后发现，前者的余额已经增加，但后者的余额由于发生异常导致没有减少 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring_MyBatis_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring整合Junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis整合spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 注解实现&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置Druid连接池--&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--配置Mapper扫描器，扫描到的mapper对象会被注入Spring容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; id=&quot;mapperScannerConfigurer&quot;&gt; &lt;!--mapper.xml的路径--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.example.mapper&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--设置MyBatis配置文件的路径--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--把事务管理器注入Spring容器，需要配置一个连接池--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--开启事务注解驱动，配置使用的事务管理器--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;&lt;/beans&gt; @Servicepublic class CountServiceImpl implements CountService &#123; @Autowired private CountMapper countMapper; @Transactional @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) &#123; // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money); &#125;&#125; @Transactional可以加到方法上也可以加到类上，若在类上，则类中所有方法都被事务管理 XML实现&lt;!--把事务管理器注入Spring容器，需要配置一个连接池--&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; &lt;!--定义事务管理的通知类--&gt;&lt;tx:advice transaction-manager=&quot;txManager&quot; id=&quot;txAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!--针对transfer进行事务控制--&gt; &lt;tx:method name=&quot;transfer&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.example.service..*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointCut&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}]},{"title":"2_MyBatis复习","slug":"编程语言/Java/学习/框架/Spring/Spring整合MyBatis、Junit及事务/2_Spring整合MyBatis","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:32:53.508Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/2-spring-zheng-he-mybatis.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/2-spring-zheng-he-mybatis.html","excerpt":"","text":"2_MyBatis复习 目录结构 Spring_MyBatis ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ domain │ │ │ │ └─ User.java │ │ │ ├─ mapper │ │ │ │ └─ UserMapper.java │ │ │ └─ Demo.java │ │ └─ resources │ │ ├─ com │ │ │ └─ example │ │ │ └─ mapper │ │ │ └─ UserMapper.xml │ │ ├─ applicationContext.xml │ │ ├─ jdbc.properties │ │ └─ mybatis-config.xml │ └─ test │ └─ java └─ pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring_MyBatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; mybatis-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--设置文件所在路径--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--指定包--&gt; &lt;package name=&quot;com.example.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTCjdbc.username=rootjdbc.password=123456 UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.domain.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;gender&quot; column=&quot;gender&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;phone&quot; column=&quot;phone&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; id,name,gender, age,address,email, phone &lt;/sql&gt; &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.example.domain.User&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from user &lt;/select&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot;&gt; delete from user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id=&quot;insert&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.example.domain.User&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into user ( id,name,gender ,age,address,email ,phone) values (#&#123;id,jdbcType=INTEGER&#125;,#&#123;name,jdbcType=VARCHAR&#125;,#&#123;gender,jdbcType=VARCHAR&#125; ,#&#123;age,jdbcType=INTEGER&#125;,#&#123;address,jdbcType=VARCHAR&#125;,#&#123;email,jdbcType=VARCHAR&#125; ,#&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id=&quot;insertSelective&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.example.domain.User&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into user &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;name,&lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt;gender,&lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt;age,&lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt;address,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email,&lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt;phone,&lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;#&#123;id,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;#&#123;name,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt;#&#123;gender,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt;#&#123;age,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt;#&#123;address,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;#&#123;email,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt;#&#123;phone,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.example.domain.User&quot;&gt; update user &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt; gender = #&#123;gender,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age = #&#123;age,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;address != null&quot;&gt; address = #&#123;address,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.example.domain.User&quot;&gt; update user set name = #&#123;name,jdbcType=VARCHAR&#125;, gender = #&#123;gender,jdbcType=VARCHAR&#125;, age = #&#123;age,jdbcType=INTEGER&#125;, address = #&#123;address,jdbcType=VARCHAR&#125;, email = #&#123;email,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; UserMapper public interface UserMapper &#123; List&lt;User&gt; selectAll(); int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; User @Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; /** * 用户id */ private Integer id; /** * 用户名字 */ private String name; /** * 用户性别 */ private String gender; /** * 用户年龄 */ private Integer age; /** * 用户地址 */ private String address; /** * 用户邮箱 */ private String email; /** * 用户手机号 */ private String phone; private static final long serialVersionUID = 1L; @Override public boolean equals(Object that) &#123; if (this == that) &#123; return true; &#125; if (that == null) &#123; return false; &#125; if (getClass() != that.getClass()) &#123; return false; &#125; User other = (User) that; return (this.getId() == null ? other.getId() == null : this.getId().equals(other.getId())) &amp;&amp; (this.getName() == null ? other.getName() == null : this.getName().equals(other.getName())) &amp;&amp; (this.getGender() == null ? other.getGender() == null : this.getGender().equals(other.getGender())) &amp;&amp; (this.getAge() == null ? other.getAge() == null : this.getAge().equals(other.getAge())) &amp;&amp; (this.getAddress() == null ? other.getAddress() == null : this.getAddress().equals(other.getAddress())) &amp;&amp; (this.getEmail() == null ? other.getEmail() == null : this.getEmail().equals(other.getEmail())) &amp;&amp; (this.getPhone() == null ? other.getPhone() == null : this.getPhone().equals(other.getPhone())); &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((getId() == null) ? 0 : getId().hashCode()); result = prime * result + ((getName() == null) ? 0 : getName().hashCode()); result = prime * result + ((getGender() == null) ? 0 : getGender().hashCode()); result = prime * result + ((getAge() == null) ? 0 : getAge().hashCode()); result = prime * result + ((getAddress() == null) ? 0 : getAddress().hashCode()); result = prime * result + ((getEmail() == null) ? 0 : getEmail().hashCode()); result = prime * result + ((getPhone() == null) ? 0 : getPhone().hashCode()); return result; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(getClass().getSimpleName()); sb.append(&quot; [&quot;); sb.append(&quot;Hash = &quot;).append(hashCode()); sb.append(&quot;, id=&quot;).append(id); sb.append(&quot;, name=&quot;).append(name); sb.append(&quot;, gender=&quot;).append(gender); sb.append(&quot;, age=&quot;).append(age); sb.append(&quot;, address=&quot;).append(address); sb.append(&quot;, email=&quot;).append(email); sb.append(&quot;, phone=&quot;).append(phone); sb.append(&quot;, serialVersionUID=&quot;).append(serialVersionUID); sb.append(&quot;]&quot;); return sb.toString(); &#125;&#125; 测试MyBatis public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 定义mybatis配置文件的路径 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取UserMapper实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 调用方法测试 List&lt;User&gt; users = userMapper.selectAll(); System.out.println(users); // 释放资源 sqlSession.close(); &#125;&#125; 14_Spring整合MyBatis参考文档 MyBatis-String连接包版本对应 MyBatis-Spring MyBatis Spring Framework Spring Batch Java 3.0 3.5+ 6.0+ 5.0+ Java 17+ 2.1 3.5+ 5.x 4.x Java 8+ 2.0 3.5+ 5.x 4.x Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring_MyBatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring整合Junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis整合spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 往容器中注入整合相关对象 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置Druid连接池--&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--配置Mapper扫描器，扫描到的mapper对象会被注入Spring容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; id=&quot;mapperScannerConfigurer&quot;&gt; &lt;!--mapper.xml的路径--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.example.mapper&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--设置MyBatis配置文件的路径--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--别名配置--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.example.domain&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MyTest &#123; @Autowired private UserMapper userMapper; @Test public void test1()&#123; System.out.println(userMapper.selectAll()); &#125;&#125; MyBatis配置别名的作用 例子 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MyTest &#123; @Autowired private UserMapper userMapper; @Test public void test1()&#123; User user = new User(4,&quot;哈哈&quot;,&quot;男&quot;,12,&quot;湖南&quot;,&quot;xxx@qq.com&quot;,&quot;131xxxx5494&quot;); userMapper.insert(user); &#125;&#125; 测试结果： 在配置了别名后，可继续使用上面的全类名写法，也可以只写类名 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MyTest &#123; @Autowired private UserMapper userMapper; @Test public void test1()&#123; User user = new User(5,&quot;呵呵&quot;,&quot;女&quot;,15,&quot;湖南&quot;,&quot;xxx@qq.com&quot;,&quot;131xxxx5494&quot;); userMapper.insert(user); &#125;&#125; 它的作用是让Mapper.xml中的参数找到对应类,如下面parameterType&#x3D;”User”，如果没有配置别名，则要改为parameterType&#x3D;”com.example.domain.User”&gt;","categories":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}]},{"title":"3_事务","slug":"编程语言/Java/学习/框架/Spring/Spring整合MyBatis、Junit及事务/3_声明式事务","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:32:53.508Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/3-sheng-ming-shi-shi-wu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/3-sheng-ming-shi-shi-wu.html","excerpt":"","text":"3_事务 事务的概念 保证—组数据库的操作，要么同时成功，要么同时失败 如：A转账给B，A的钱减少，B的钱增加 事务的四大特性 隔离性多个事务之间要相互隔离，不能互相干扰 原子性指事务是一个不可分割的整体，类似一个不可分割的原子 —致性保障事务前后这组数据的状态是一致的。要么都是成功的，要么都是失败的。 持久性指事务一旦被提交，这组操作修改的数据就真的的发生变化了。即使接下来数据库故障也不应该对其有影响。 声明式事务 如果我们自己去对事务进行控制的话我们就需要值原来核心代码的基础上加上事务控制相关的代码。而在我们的实际开发中这种事务控制的操作也是非常常见的。所以Spring提供了声明式事务的方式让我们去控制事务。只要简单的加个注解(或者是xml配置)就可以实现事务控制，不需要事务控制的时候只需要去掉相应的注解即可。 转账案例-环境搭建 Spring_MyBatis_1 ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ domain │ │ │ │ └─ Count.java │ │ │ ├─ mapper │ │ │ │ └─ CountMapper.java │ │ │ ├─ service │ │ │ │ ├─ impl │ │ │ │ │ └─ CountServiceImpl.java │ │ │ │ └─ CountService.java │ │ │ └─ Main.java │ │ └─ resources │ │ ├─ com │ │ │ └─ example │ │ │ └─ mapper │ │ │ └─ CountMapper.xml │ │ ├─ applicationContext.xml │ │ ├─ jdbc.properties │ │ └─ mybatis-config.xml │ └─ test │ └─ java │ └─ com │ └─ example │ └─ test │ └─ MyTest.java └─ pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;Spring_MyBatis_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring整合Junit依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--ioc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis整合spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTCjdbc.username=rootjdbc.password=123456 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 打印sql日志 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;!--别名配置--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.example.domain&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.mapper.CountMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.domain.Count&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;money&quot; column=&quot;money&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; id ,name,money &lt;/sql&gt; &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from count where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot;&gt; delete from count where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id=&quot;insert&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.example.domain.Count&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into count (id, name, money) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;money,jdbcType=INTEGER&#125;) &lt;/insert&gt; &lt;insert id=&quot;insertSelective&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.example.domain.Count&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into count &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;name,&lt;/if&gt; &lt;if test=&quot;money != null&quot;&gt;money,&lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;id != null&quot;&gt;#&#123;id,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;#&#123;name,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;money != null&quot;&gt;#&#123;money,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.example.domain.Count&quot;&gt; update count &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;money != null&quot;&gt; money = #&#123;money,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.example.domain.Count&quot;&gt; update count set name = #&#123;name,jdbcType=VARCHAR&#125;, money = #&#123;money,jdbcType=INTEGER&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id=&quot;updateMoney&quot;&gt; update count set money = money + #&#123;updateMoney,jdbcType=INTEGER&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; @Datapublic class Count implements Serializable &#123; /** * 账户id */ private Integer id; /** * 账户名 */ private String name; /** * 余额 */ private Integer money; private static final long serialVersionUID = 1L; @Override public boolean equals(Object that) &#123; if (this == that) &#123; return true; &#125; if (that == null) &#123; return false; &#125; if (getClass() != that.getClass()) &#123; return false; &#125; Count other = (Count) that; return (this.getId() == null ? other.getId() == null : this.getId().equals(other.getId())) &amp;&amp; (this.getName() == null ? other.getName() == null : this.getName().equals(other.getName())) &amp;&amp; (this.getMoney() == null ? other.getMoney() == null : this.getMoney().equals(other.getMoney())); &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((getId() == null) ? 0 : getId().hashCode()); result = prime * result + ((getName() == null) ? 0 : getName().hashCode()); result = prime * result + ((getMoney() == null) ? 0 : getMoney().hashCode()); return result; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(getClass().getSimpleName()); sb.append(&quot; [&quot;); sb.append(&quot;Hash = &quot;).append(hashCode()); sb.append(&quot;, id=&quot;).append(id); sb.append(&quot;, name=&quot;).append(name); sb.append(&quot;, money=&quot;).append(money); sb.append(&quot;, serialVersionUID=&quot;).append(serialVersionUID); sb.append(&quot;]&quot;); return sb.toString(); &#125;&#125; public interface CountMapper &#123; int deleteByPrimaryKey(Long id); int insert(Count record); int insertSelective(Count record); Count selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(Count record); int updateByPrimaryKey(Count record); // 增加和减少都是update void updateMoney(@Param(&quot;id&quot;) Integer id,@Param(&quot;updateMoney&quot;) Integer updateMoney);&#125; public interface CountService &#123; void transfer(Integer outUserId, Integer inUserId, Integer money);&#125; @Servicepublic class CountServiceImpl implements CountService &#123; @Autowired private CountMapper countMapper; @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) &#123; // 增加 countMapper.updateMoney(inUserId, money); // 减少 countMapper.updateMoney(outUserId, -money); &#125;&#125; 测试方法 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MyTest &#123; @Autowired private CountService countService; @Test public void test1() &#123; countService.transfer(1,2,10); &#125;&#125; JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6f8e8894] will not be managed by Spring==&gt; Preparing: update count set money = money + ? where id = ?==&gt; Parameters: 10(Integer), 2(Integer)&lt;== Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65f8f5ae]Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f3187b0] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6f8e8894] will not be managed by Spring==&gt; Preparing: update count set money = money + ? where id = ?==&gt; Parameters: -10(Integer), 1(Integer)&lt;== Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6f3187b0]","categories":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}]},{"title":"5_事务传播行为","slug":"编程语言/Java/学习/框架/Spring/Spring整合MyBatis、Junit及事务/5_事务传播行为","date":"2023-01-20T00:00:00.000Z","updated":"2024-06-01T14:12:24.985Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/5-shi-wu-chuan-bo-xing-wei.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/spring-zheng-he-mybatis-junit-ji-shi-wu/5-shi-wu-chuan-bo-xing-wei.html","excerpt":"","text":"5_事务传播行为事务传播行为 propagation 当事务方法嵌套调用时，需要控制是否开启新事务，可以使用事务传播行为来控制。案例： @Servicepublic class CountServiceImpl implements CountService &#123; @Autowired private CountMapper countMapper; @Transactional @Override public void transfer(Integer outUserId, Integer inUserId, Integer money) &#123; // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money); &#125; @Transactional @Override public void log() &#123; System.out.println(&quot;记录日志&quot;); int i = 1/0; &#125;&#125; 测试方法 @Transactionalpublic void test()&#123; // 转账 countService.transfer(1,2,10); // 记录日志 countService.log();&#125; 假如：转账正常，而记录日志出现异常；则会导致两者都被回滚 属性值 行为 REQUIRED（必须要有） 外层方法有事务，内层方法就加入。外层没有，内层就新建 REQUIRES_NEW（必须要有新事务） 外层方法有事务，内层方法新建。外层没有，内层也新建 SUPPORTS（支持有） 外层方法有事务，内层方法就加入。外层没有，内层就也没有 NOT_SUPPORTED（支持没有） 外层方法有事务，内层方法没有。外层没有，内层也没有 MANDATORY（强制要求外层有） 外层方法有事务，内层方法加入。外层没有。内层就报错 NEVER(绝不允许有) 外层方法有事务，内层方法就报错。外层没有。内层就也没有 隔离级别 isolation@Transactional(propagation = Propagation.REQUIRES_NEW,isolation = Isolation.READ_COMMITTED)@Overridepublic void transfer(Integer outUserId, Integer inUserId, Integer money) &#123; // 增加 countMapper.updateMoney(inUserId, money); //System.out.println(1/0); // 减少 countMapper.updateMoney(outUserId, -money);&#125; 隔离级别 行为 Isolation.DEFAULT 使用数据库默认隔离级别 Isolation.READ_COMMITTED Isolation.READ_UNCOMMITTED Isolation.REPEATABLE_READ Isolation.SERIALIZABLE 只读 readOnly 如果事务中的操作都是读操作，没涉及到对数据的写操作可以设置readOnly为true。这样可以提高效率。 @Transactional(readOnly = true)public void log()&#123; System.out.println(&quot;打印日志&quot;); int i = 1/0;&#125; 注意：实际项目当中会将日志记录到数据库当中","categories":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"}]},{"title":"Idea配置","slug":"系统配置/编程配置/环境配置/Idea配置/idea配置","date":"2023-01-19T08:20:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-pei-zhi.html","excerpt":"","text":"Idea配置快捷键代码重排(reformat code)-&gt;(ctrl+k)run context configuration-&gt;(F5) # 可有可无delete line-&gt;(ctrl+d)代码提示(basic)-&gt;alt+?方法提取(Extract method)-&gt;(ctrl+alt+M)全局查找(Find in files)-&gt;(ctrl+H)向下复制(Duplicate Line or Selection)-&gt;(alt+D) 自动注释模板 /** * @Auther: $&#123;USER&#125; * @Date: $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;/$&#123;TIME&#125; * @Description: */ 修改编码 自动导包 忽视代码大小写 关闭自动更新 tab页多行显示设置 Java注释优化代码注释前空格格式 开启代码自动编译 去除idea自带的.iml文件，以及.idea文件夹 配置maven idea启动时展开项目列表 pom文件依赖报黄 配置YML模板 1.这种是直接添加new的文件2.这种才类似添加用户的模板 server: # 应用服务 WEB 访问端口 port: 8080spring: # 应用名称 TODO application: name: demo datasource: # 数据库驱动： driver-class-name: com.mysql.cj.jdbc.Driver # 数据源名称 name: defaultDataSource # 数据库连接地址 url: jdbc:mysql://localhost:3306/blue?serverTimezone=UTC # 数据库用户名&amp;密码： username: root password: 123456 spring: application: name: demo cloud: nacos: # 服务注册 discovery: server-addr: localhost:8848 # 服务配置 config: server-addr: localhost:8848 # 命名空间# namespace: # b6625ff9-0949-464b-bad3-fe4cf7858223# ext-config:# - data-id: # oss.yml# group: # DEFAULT_GROUP# refresh: true &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;groupId&gt;com.example.demo&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example.common&lt;/groupId&gt; &lt;artifactId&gt;demo-common&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;druid.version&gt;1.1.10&lt;/druid.version&gt; &lt;servlet-api.version&gt;2.3&lt;/servlet-api.version&gt; &lt;validation-api.version&gt;2.0.1.Final&lt;/validation-api.version&gt; &lt;httpcore.version&gt;4.4.15&lt;/httpcore.version&gt; &lt;commons-lang.version&gt;2.6&lt;/commons-lang.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;mybatis-plus.version&gt;3.5.1&lt;/mybatis-plus.version&gt; &lt;mysql.version&gt;8.0.30&lt;/mysql.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.9.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--参数校验--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;$&#123;validation-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpcore--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;$&#123;httpcore.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-lang--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--服务注册/发现--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--配置中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; # 应用名称 TODOspring.application.name=demo# 应用服务 WEB 访问端口server.port=8080# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/blue?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 数据源名称# spring.datasource.name=com.alibaba.druid.pool.DruidDataSourcespring.datasource.name=defaultDataSource# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置mybatis-plus 包路径 TODOmybatis-plus.type-aliases-package=com.example.demo.entity# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto# 1代表已经删除，0代表没有删除mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0 idea本地缓存异常 mybatis-plus xml报黄 类上注释报黄 找到java下的javadoc description,createDate &#x3D;&#x3D; @description @createDate description:,createDate: &#x3D;&#x3D; @description: @createDate: mapper层注入爆红，红色波浪线 Lombok requires enabled annotation processin ![image-20230120211525558](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202301202115626.png) ## lombok注解失效 > lombok注解失效，运行时提示找不到某个参数或方法 解决方法有以下三种可能（我个人是第三种）： 1. 更新lombok版本 2. mvn clean后重新导入 3. 加入 `-Djps.track.ap.dependencies=false` ![image-20230311100422978](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303111004136.png) ## pom文件变成灰色 > 原因，可能是之前创建项目后删除重建，所以idea排除了这个模块 > > Setting->Build Tools->Maven->Ignored Files `去掉勾选项即可` ![image-20230311100659882](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303111006961.png) ## 打开项目后没有显示项目结构 ![image-20230325120519766](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303251205970.png) > 选择import ![image-20230325120540273](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303251205358.png) ![image-20230325120619785](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303251206868.png) ![image-20230325120640914](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202303251206023.png) ## idea配置项目根目录 ![image-20230402220239326](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202304022202424.png)","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"配置nodejs","slug":"系统配置/编程配置/环境配置/Nvm配置nodejs/配置nodejs","date":"2023-01-19T08:20:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/nvm-pei-zhi-nodejs/pei-zhi-nodejs.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/nvm-pei-zhi-nodejs/pei-zhi-nodejs.html","excerpt":"","text":"nvm安装前往下载 默认就好，免得配置环境 在nvm文件夹下找到setting.txt，进行如下配置 ##当前操作系统的位数（32/64）arch: 64 ##是否需要代理proxy: none ##node的淘宝镜像node_mirror: http://npm.taobao.org/mirrors/node/##npm的淘宝镜像npm_mirror: https://npm.taobao.org/mirrors/npm/ ## nvm下载nodejsnvm install 14.17.2nvm use 14.17.2nvm install 16.13.2nvm use 16.13.2 ## 安装cnpm,将npm设置为淘宝镜像## 安装npm install -g cnpm --registry=https://registry.npm.taobao.org## 设置npm config set registry https://registry.npm.taobao.org## 安装vue/clicnpm install -g @vue/cli## 检查是否安装成功#vue -V 或者vue --version 创建一个vue项目试试vue create demo 选择manually select features 手动创建选择TypeScript、Router、Vuex，取消掉Linter&#x2F;Formatter选择3.X根据提示运行命令 cd demonpm run serve 安装nodejs网址一直默认即可（安装地址自定义）环境变量 path新建”D:\\nodejs”在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹 npm config set prefix &quot;D:\\nodejs\\node_global&quot;npm config set cache &quot;D:\\nodejs\\node_cache&quot; 环境变量 path新建”D:\\nodejs\\node_global” npm config get registrynpm config set registry https://registry.npm.taobao.org/npm config get registry","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"maven配置","slug":"系统配置/编程配置/环境配置/Maven配置/maven配置","date":"2023-01-19T08:20:00.000Z","updated":"2024-06-01T14:32:53.520Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/maven-pei-zhi/maven-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/maven-pei-zhi/maven-pei-zhi.html","excerpt":"","text":"maven下载maven官网 最新版 历史版 还是刚刚最新版的页面，往下拉，找到archives，或者点击链接前往 maven配置 新建环境变量MAVEN_HOME D:\\apache-maven-3.8.6 系统变量path新建%MAVEN_HOME%\\bin %MAVEN_HOME%\\bin cmd窗口查看版本 mvn -v 新建maven仓库repository【新建repository文件夹】配置setting.xml &lt;localRepository&gt;D:\\apache-maven-3.8.6\\repository&lt;/localRepository&gt;&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- java版本 --&gt;&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt;","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"09_使用xml的方式配置AOP","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/09_使用xml的方式配置AOP","date":"2023-01-19T00:00:00.000Z","updated":"2024-06-01T14:12:24.963Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/09-shi-yong-xml-de-fang-shi-pei-zhi-aop.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/09-shi-yong-xml-de-fang-shi-pei-zhi-aop.html","excerpt":"","text":"09_使用xml的方式配置AOP 定义切面类 目标类和切面类注入容器 配置AOP project.user.uid=2project.user.username=李四project.user.password=111111project.phone.number=13195868989project.phone.type=电信 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface InvokeLog &#123;&#125;@Componentpublic class MyAspect &#123; @Pointcut(&quot;execution(* com.example.service..*.*(..))&quot;) public void servicePointCut() &#123; &#125; public void before(JoinPoint point)&#123; MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(&quot;方法所在的全类名是:&quot;+signature.getDeclaringTypeName()); System.out.println(&quot;方法名称是:&quot;+signature.getName()); System.out.println(&quot;方法参数是:&quot;+ Arrays.toString(point.getArgs())); &#125; public void after(JoinPoint point)&#123; MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(&quot;方法所在的全类名是:&quot;+signature.getDeclaringTypeName()); System.out.println(&quot;方法名称是:&quot;+signature.getName()); System.out.println(&quot;方法参数是:&quot;+ Arrays.toString(point.getArgs())); &#125; public void afterReturning(JoinPoint point,Object result)&#123; MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(&quot;方法所在的全类名是:&quot;+signature.getDeclaringTypeName()); System.out.println(&quot;方法名称是:&quot;+signature.getName()); System.out.println(&quot;方法参数是:&quot;+ Arrays.toString(point.getArgs())); System.out.println(&quot;result:&quot;+result); &#125; public void afterThrowing(JoinPoint point,Throwable throwable)&#123; System.out.println(&quot;方法的异常对象是:&quot;+throwable); &#125; public Object around(ProceedingJoinPoint point) &#123; // 方法调用时传入的参数 Object[] args = point.getArgs(); // 被代理对象 Object target = point.getTarget(); // 获取被增强方法签名封装的对象 MethodSignature signature = (MethodSignature) point.getSignature(); Object proceed = null; try &#123; proceed = point.proceed(); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; return proceed; &#125;&#125;@Data@Componentpublic class User &#123; @Value(&quot;$&#123;project.user.uid&#125;&quot;) private Integer uid; @Value(&quot;$&#123;project.user.username&#125;&quot;) private String username; @Value(&quot;$&#123;project.user.password&#125;&quot;) private String password;&#125;@Servicepublic class UserService &#123; @InvokeLog public void addUser(User user) &#123; System.out.println(&quot;新增用户&quot;); &#125; @InvokeLog public void updateUser(User user) &#123; System.out.println(&quot;修改用户&quot;); &#125; @InvokeLog public void deleteUser(Integer id) &#123; System.out.println(&quot;删除用户&quot;); &#125; @InvokeLog public User getUserById(Integer id) &#123; System.out.println(&quot;查询用户&quot;); //List&lt;Integer&gt; num = null; //num.add(1); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); return context.getBean(User.class); &#125; @InvokeLog public void testUser()&#123; System.out.println(&quot;测试用户&quot;); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService service = context.getBean(UserService.class); User userById = service.getUserById(1); // 这里userById为null的原因，是因为这是前置通知，目标方法还未执行，所以没有返回值 System.out.println(&quot;返回值是:&quot;+userById); &#125;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:project.properties&quot;/&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--定义切点--&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;@annotation(com.example.aspect.InvokeLog)&quot;/&gt; &lt;aop:pointcut id=&quot;pointCut1&quot; expression=&quot;execution(* com.example.service..*.*(..))&quot;/&gt; &lt;!--配置通知方法--&gt; &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;myAspect&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointCut&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointCut&quot;/&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointCut&quot; returning=&quot;result&quot;/&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointCut&quot; throwing=&quot;throwable&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt;","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"07_环绕通知获取被增强方法的相关信息","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/07_环绕通知获取被增强方法的相关信息","date":"2023-01-18T00:00:00.000Z","updated":"2024-06-01T14:12:24.961Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/07-huan-rao-tong-zhi-huo-qu-bei-zeng-qiang-fang-fa-de-xiang-guan-xin-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/07-huan-rao-tong-zhi-huo-qu-bei-zeng-qiang-fang-fa-de-xiang-guan-xin-xi.html","excerpt":"","text":"07_环绕通知获取被增强方法的相关信息 直接在环绕通知方法中增加一个ProceedingJoinPoint类型的参数。这个参数封装了被增强方法的相关信息。该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。例如: @Around(&quot;servicePointCut()&quot;)public Object around(ProceedingJoinPoint point) &#123; // 方法调用时传入的参数 Object[] args = point.getArgs(); // 被代理对象 Object target = point.getTarget(); // 获取被增强方法签名封装的对象 MethodSignature signature = (MethodSignature) point.getSignature(); Object proceed = null; try &#123; proceed = point.proceed(); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; return proceed;&#125; 环绕通知注意事项 需要给环绕通知的方法返回值定义为Object对象，如果不希望更改目标方法的返回值，直接返回目标方法的原本返回值即可。一句话概括，将目标方法的返回值，作为通知方法的返回值进行返回，详情看上述代码 如果希望篡改目标方法的返回值，更改通知方法的返回值即可","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"06_获取被增强方法的返回值和异常对象","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/06_获取被增强方法的返回值和异常对象","date":"2023-01-18T00:00:00.000Z","updated":"2024-06-01T14:12:24.960Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/06-huo-qu-bei-zeng-qiang-fang-fa-de-fan-hui-zhi-he-yi-chang-dui-xiang.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/06-huo-qu-bei-zeng-qiang-fang-fa-de-fan-hui-zhi-he-yi-chang-dui-xiang.html","excerpt":"","text":"06_获取被增强方法的返回值和异常对象 获取方法返回值，由于前置通知是在目标方法执行之前，所以前置通知是无法获取到返回值的应该在@AfterReturning里获取，配置returning属性获取异常对象是在@AfterThrowing里获取，配置throwing属性示例如下： @AfterReturning(value = &quot;servicePointCut()&quot;,returning = &quot;ret&quot;)public void afterReturning(JoinPoint point,Object ret)&#123; System.out.println(&quot;方法的返回对象是:&quot;+ret);&#125;@AfterThrowing(value = &quot;servicePointCut()&quot;,throwing = &quot;throwable&quot;)public void afterReturning(JoinPoint point,Throwable throwable)&#123; System.out.println(&quot;方法的异常对象是:&quot;+throwable);&#125;","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"08_AOP案例","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/08_AOP案例","date":"2023-01-18T00:00:00.000Z","updated":"2024-06-01T14:12:24.962Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/08-aop-an-li.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/08-aop-an-li.html","excerpt":"","text":"08_AOP案例public class AIController &#123; // AI自动回答 public String getAnswer(String question) &#123; // AI核心代码 String str = question.replace(&quot;吗&quot;, &quot;&quot;); str = str.replace(&quot;？&quot;, &quot;！&quot;); str = str.replace(&quot;?&quot;, &quot;!&quot;); return str; &#125; // AI算命 public String fortuneTelling(String name) &#123; // AI核心代码 String[] strs = &#123;&quot;女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。&quot;, &quot;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。&quot;, &quot;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。&quot;&#125;; int index=name.hashCode()%3; return strs[index]; &#125;&#125; 需求：现在为了保证数据的安全性，传入加密后的参数给fortuneTelling方法，此时AOP进行解密后真正传给fortuneTelling方法，执行后的返回值再进行加密后返回 ps：后期也可能让其他方法进行加密处理 import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;// 加密、解密工具类public class CryptUtil &#123; private static final String AES = &quot;AES&quot;; private static int keysizeAES = 128; private static String charset = &quot;UTF-8&quot;; public static String parseByte2HexStr(final byte[] b) &#123; final StringBuilder stringBuffer = new StringBuilder(); for (byte value : b) &#123; String hex = Integer.toHexString(value &amp; 0xFF); if (hex.length() == 1) &#123; hex = &#x27;0&#x27; + hex; &#125; stringBuffer.append(hex.toUpperCase()); &#125; return stringBuffer.toString(); &#125; public static byte[] parseHexStr2Byte(final String hexStr) &#123; if (hexStr.length() &lt; 1) &#123; return null; &#125; final byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i &lt; hexStr.length() / 2; i++) &#123; int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); &#125; return result; &#125; private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final boolean bEncode) &#123; try &#123; final KeyGenerator g = KeyGenerator.getInstance(algorithm); if (keysize == 0) &#123; byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); g.init(new SecureRandom(keyBytes)); &#125; else if (key == null) &#123; g.init(keysize); &#125; else &#123; byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset); SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); random.setSeed(keyBytes); g.init(keysize, random); &#125; final SecretKey secretKey = g.generateKey(); final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); final Cipher cipher = Cipher.getInstance(algorithm); if (bEncode) &#123; cipher.init(Cipher.ENCRYPT_MODE, keySpec); final byte[] result = charset == null ? res.getBytes() : res.getBytes(charset); return parseByte2HexStr(cipher.doFinal(result)); &#125; else &#123; cipher.init(Cipher.DECRYPT_MODE, keySpec); return new String(cipher.doFinal(parseHexStr2Byte(res))); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static String AESencode(final String res) &#123; return keyGeneratorES(res, AES, &quot;aAll*-%&quot;, keysizeAES, true); &#125; public static String AESdecode(final String res) &#123; return keyGeneratorES(res, AES, &quot;aAll*-%&quot;, keysizeAES, false); &#125; public static void main(String[] args) &#123; System.out.println(&quot;加密后:&quot; + AESencode(&quot;123456&quot;)); System.out.println(&quot;解密后:&quot; + AESdecode(&quot;555B695B57E024EEA169EAE275B9D93B&quot;)); &#125;&#125; @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface EnCodeAndDeCode &#123;&#125;@Component@Aspectpublic class MyAOP &#123; @Pointcut(&quot;execution(* com.example.controller..*.fortuneTelling(..))&quot;) public void pointCut() &#123; &#125; @Pointcut(&quot;@annotation(com.example.aspect.EnCodeAndDeCode)&quot;) public void annotationPointCut() &#123; &#125; @Around(&quot;annotationPointCut()&quot;) public Object around(ProceedingJoinPoint point) &#123; Object proceed = null; Object[] args = point.getArgs(); System.out.println(&quot;明文参数是:&quot; + Arrays.toString(args)); for (int i = 0; i &lt; args.length; i++) &#123; args[i] = CryptUtil.AESdecode((String) args[i]); &#125; System.out.println(&quot;密文参数是:&quot; + Arrays.toString(args)); try &#123; proceed = point.proceed(args); System.out.println(&quot;明文返回值是:&quot; + proceed); System.out.println(&quot;密文返回值是:&quot; + CryptUtil.AESencode((String) proceed)); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return CryptUtil.AESencode((String) proceed); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AIController aiController = context.getBean(AIController.class); //String answer = aiController.getAnswer(&quot;我帅吗？&quot;); String result = aiController.fortuneTelling(CryptUtil.AESencode(&quot;赵子龙&quot;)); //System.out.println(answer); System.out.println(&quot;返回值解密是:&quot;+CryptUtil.AESdecode(result)); &#125;&#125; 执行结果： 明文参数是:[6F152DBC4B9D1B6B03EA4B858D6AE775]密文参数是:[赵子龙]明文返回值是:女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。密文返回值是:930617239D652C6E7BD9510B919BB44CAE3286191754B494FBB76F52FC370E2336813515381DDE2463A91F2588898E9CB9C4D31EBD2D09BCFFFBF593C675A13DC8A8FDEADC905A791A9E72D03F38E6B3C410C8EF7683A5130175E0670AC17210A6032F8A8CBC8256C8E0A70D65DE0148返回值解密是:女犯伤官把夫克，早地莲花栽不活，不是吃上两家饭，也要刷上三家锅。","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"05_JoinPoint案例","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/05_JoinPoint案例","date":"2023-01-16T00:00:00.000Z","updated":"2024-06-01T14:12:24.959Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/05-joinpoint-an-li.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/05-joinpoint-an-li.html","excerpt":"","text":"05_JoinPoint案例 需求：在调用方法时，输出**某某类中的某某方法被调用了，调用时传入的参数是哪些** &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:project.properties&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; project.user.uid=2project.user.username=李四project.user.password=111111project.phone.number=13195868989project.phone.type=电信 @Data@Componentpublic class Phone &#123; @Value(&quot;$&#123;project.phone.number&#125;&quot;) private String number; @Value(&quot;$&#123;project.phone.type&#125;&quot;) private String type;&#125;@Data@Componentpublic class User &#123; @Value(&quot;$&#123;project.user.uid&#125;&quot;) private Integer uid; @Value(&quot;$&#123;project.user.username&#125;&quot;) private String username; @Value(&quot;$&#123;project.user.password&#125;&quot;) private String password;&#125; @Servicepublic class PhoneService &#123; public void addPhone(Phone phone) &#123; System.out.println(&quot;新增手机&quot;); &#125; public void updatePhone(Phone phone) &#123; System.out.println(&quot;修改手机&quot;); &#125; public void deletePhone(String number) &#123; System.out.println(&quot;删除手机&quot;); &#125; public Phone getPhoneByNumber(String number) &#123; System.out.println(&quot;查询手机&quot;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); return context.getBean(Phone.class); &#125; public void testPhone()&#123; System.out.println(&quot;测试手机&quot;); &#125;&#125;@Servicepublic class UserService &#123; public void addUser(User user) &#123; System.out.println(&quot;新增用户&quot;); &#125; public void updateUser(User user) &#123; System.out.println(&quot;修改用户&quot;); &#125; public void deleteUser(Integer id) &#123; System.out.println(&quot;删除用户&quot;); &#125; public User getUserById(Integer id) &#123; System.out.println(&quot;查询用户&quot;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); return context.getBean(User.class); &#125; public void testUser()&#123; System.out.println(&quot;测试用户&quot;); &#125;&#125; @Component@Aspectpublic class MyAspect &#123; @Pointcut(&quot;@annotation(com.example.aspect.InvokeLog)&quot;) public void logPointCut() &#123;&#125; @Pointcut(&quot;execution(* com.example.service..*.*(..))&quot;) public void servicePointCut() &#123;&#125; @Before(&quot;servicePointCut()&quot;) public void before(JoinPoint point)&#123; MethodSignature signature = (MethodSignature) point.getSignature(); System.out.println(&quot;方法所在的全类名是:&quot;+signature.getDeclaringTypeName()); System.out.println(&quot;方法名称是:&quot;+signature.getName()); System.out.println(&quot;方法参数是:&quot;+ Arrays.toString(point.getArgs())); System.out.println(&quot;-------------------------------&quot;); &#125;&#125; @Componentpublic class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 对象 User user = context.getBean(User.class); Phone phone = context.getBean(Phone.class); // service UserService userService = context.getBean(UserService.class); userService.addUser(user); userService.deleteUser(1); userService.updateUser(user); userService.getUserById(1); userService.testUser(); PhoneService phoneService = context.getBean(PhoneService.class); phoneService.addPhone(phone); phoneService.deletePhone(&quot;1&quot;); phoneService.updatePhone(phone); phoneService.getPhoneByNumber(&quot;1&quot;); phoneService.testPhone(); &#125;&#125; @value获取不到值 static的属性使用@Value注解，因为Spring的类加载器是在jvm之后的，所以在jvm加载过程中@Value不起作用 使用@Value注解的类被Spring所管理，如@Component、@Service、@Controller等 new对象，Spring管理的对象，new出来，当然也获取不到","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"SpringAOP核心概念","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/02_AOP概念","date":"2023-01-16T00:00:00.000Z","updated":"2024-06-01T14:12:24.955Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/02-aop-gai-nian.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/02-aop-gai-nian.html","excerpt":"","text":"SpringAOP核心概念 Joinpoint(连接点)︰所谓连接点是指那些可以被增强到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut(切入点)︰所谓切入点是指被增强的连接点(方法) Advice(通知&#x2F;增强)︰所谓通知是指具体增强的代码 Target(目标对象)︰被增强的对象就是目标对象 Aspect(切面)︰是切入点和通知(引介)的结合 Proxy (代理)︰一个类被AOP增强后，就产生一个结果代理类 切点表达式// 返回值，某个类下某个方法，..代表任意参数，不加代表无参方法@Pointcut(&quot;execution(* com.example.service.*.sayHello(..))&quot;) 切点函数@annotation我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。写法:@annotation(注解的全类名)例如:定义注解如下 @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface InvokeLog &#123;&#125;@Pointcut(&quot;@annotation(com.example.myannotation.InvokeLog)&quot;)public void pointCut1()&#123;&#125;@Before(&quot;pointCut1()&quot;)public void before()&#123; System.out.println(&quot;拜拜咯您嘞&quot;);&#125;@InvokeLogpublic void sayBye()&#123; System.out.println(&quot;bye&quot;);&#125;phoneService.sayBye();","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"04_获取被增强方法的相关信息","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/04_获取被增强方法的相关信息","date":"2023-01-16T00:00:00.000Z","updated":"2024-06-01T14:12:24.957Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/04-huo-qu-bei-zeng-qiang-fang-fa-de-xiang-guan-xin-xi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/04-huo-qu-bei-zeng-qiang-fang-fa-de-xiang-guan-xin-xi.html","excerpt":"","text":"04_获取被增强方法的相关信息我们可以在除了环绕通知外的所有通知方法中增加一个JoinPoint类型的参数。这个参数封装了被增强方法的相关信息。我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。 // 获取传入参数joinPoint.getArgs();// 获得签名，签名可以用来获得详细信息joinPoint.getSignature();// 获得增强的方法名，StringjoinPoint.getSignature().getName();// 获得全类名，StringjoinPoint.getSignature().getDeclaringTypeName();// 获得类的Class对象joinPoint.getSignature().getDeclaringType(); 虽然签名Signature有一些有用的方法，但其实还不够多，所以选择MethodSignature来进行接收MethodSignature是Signature的子接口MethodSignature的方法更丰富 @Before(&quot;pointCut1()&quot;)public void before(JoinPoint joinPoint) &#123; System.out.println(&quot;before---&quot;); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); method.invoke(); System.out.println(joinPoint);&#125; DeBug debug模式的小计算器可以直接测试你希望测试的方法并显示返回值如上述的一些方法joinPoint.getArgs();、joinPoint.getSignature();","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"02_Before前置通知","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/03_通知分类","date":"2023-01-16T00:00:00.000Z","updated":"2024-06-01T14:12:24.956Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/03-tong-zhi-fen-lei.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/03-tong-zhi-fen-lei.html","excerpt":"","text":"02_Before前置通知 @Before:前置通知,在方法执行前执行 @AfterReturning:返回后通知，在目标方法执行后执行，如果出现异常不会执行 @After:后置通知，在目标方法返回结果之后执行，无论是否出现异常都会执行 @AfterThrowing:异常通知，在目标方法抛出异常后执行 @Around:环绕通知，围绕着方法执行public Object test()&#123; // @Before前置通知 beafore(); try &#123; // 目标方法调用 Object ret=目标方法(); // @AfterReturning返回后通知 afterReturn(); &#125;catch (Throwable throwable)&#123; throwable.printStackTrace(); // @AfterThrowing 异常通知 afterThrowing(); &#125;finally &#123; // @After 后置通知 after(); &#125; return ret;&#125; 04_AfterReturning返回后异常 若目标方法出现异常，不执行 System.out.println(1/0); 05_After后置通知 无论目标方法出现异常与否，都会执行 06_AfterThrowing异常通知 如果目标方法出现异常，则执行；反之不执行 07_Around环绕通知 围绕着目标方法执行 @Around(&quot;pointCut1()&quot;)public void around(ProceedingJoinPoint point) &#123; System.out.println(&quot;目标方法前---&quot;); try &#123; // 目标方法执行 point.proceed(); System.out.println(&quot;目标方法后---&quot;); &#125; catch (Throwable e) &#123; e.printStackTrace(); System.out.println(&quot;出现异常后---&quot;); &#125;finally &#123; System.out.println(&quot;finally中进行增强---&quot;); &#125;&#125; 总结 Around的功能更加强大，IDEA中@Around报黄，提示Join point return value will be lost 是因为可以返回一个Object对象","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"09_XML配置文件相关注解","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/09_XML配置文件相关注解","date":"2023-01-15T02:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/09-xml-pei-zhi-wen-jian-xiang-guan-zhu-jie.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/09-xml-pei-zhi-wen-jian-xiang-guan-zhu-jie.html","excerpt":"","text":"XML配置文件相关注解@Configuration 标注在类上，表示当前类是一个配置类。我们可以用注解类来完全替换掉xml配置文件。注意:如果使用配置类替换了xml配置，spring容器要使用:AnnotationConfigApplicationContext @ComponentScan 可以用来代替contexcomponent-scan标签来配置组件扫描。使用接下来的一个例子，来完全替换掉xml配置文件 // java配置类@Configuration@ComponentScan(basePackages = &#123;&quot;com.example&quot;&#125;)public class ApplicationConfig &#123;&#125;@Data@Component(&quot;userEntity&quot;)public class User &#123; @Value(&quot;1&quot;) private Integer uid; @Value(&quot;admin&quot;) private String username; @Value(&quot;123456&quot;) private String password;&#125;public class Application_11 &#123; public static void main(String[] args) &#123; // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); User userEntity = (User) context.getBean(&quot;userEntity&quot;); System.out.println(userEntity); &#125;&#125; 注意：这里使用AnnotationConfigApplicationContext而不是之前的ClassPathXmlApplicationContext @Bean 可以用来代替bean标签，主要用于第三方类的注入。比如Druid连接池，由于是第三方jar包，没办法添加@Component注解注入到Spring容器中这时候，可以使用@Bean注解 @Configuration@ComponentScan(basePackages = &#123;&quot;com.example&quot;&#125;)public class ApplicationConfig &#123; @Bean(&quot;dataSource&quot;) public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;1&quot;); dataSource.setUrl(&quot;2&quot;); dataSource.setUsername(&quot;3&quot;); dataSource.setPassword(&quot;4&quot;); return dataSource; &#125;&#125;public class Application_11 &#123; public static void main(String[] args) &#123; // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); //User userEntity = (User) context.getBean(&quot;userEntity&quot;); //System.out.println(userEntity); DruidDataSource dataSource = (DruidDataSource) context.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 这里其实还有一种更常用的写法，不配置Bean的id，直接通过字节码来获取Bean这里能这么使用是因为对应类型的Bean只有一个 @Configuration@ComponentScan(basePackages = &#123;&quot;com.example&quot;&#125;)public class ApplicationConfig &#123; // 没有指定Bean的id属性 @Bean public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;1&quot;); dataSource.setUrl(&quot;2&quot;); dataSource.setUsername(&quot;3&quot;); dataSource.setPassword(&quot;4&quot;); return dataSource; &#125;&#125;public class Application_11 &#123; public static void main(String[] args) &#123; // 创建注解容器，指定配置类(传入字节码对象) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class); // 这里写DruidDataSource.class或者DataSource.class都行 // 这里和config配置中的返回值类型相对应 DataSource bean = context.getBean(DruidDataSource.class); System.out.println(bean); &#125;&#125; @PropertySource 可以用来代替context:property-placeholder，让Spring读取指定的properties文件。然后可以使用@Value来获取读取到的值。 mysql.driverClassName=com.mysql.cj.jdbc.Drivermysql.url=jdbc:mysql://localhost/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaimysql.username=rootmysql.password=123456 @Configuration@ComponentScan(basePackages = &#123;&quot;com.example&quot;&#125;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class ApplicationConfig &#123; @Value(&quot;$&#123;mysql.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;mysql.url&#125;&quot;) private String url; @Value(&quot;$&#123;mysql.username&#125;&quot;) private String username; @Value(&quot;$&#123;mysql.password&#125;&quot;) private String password; @Bean public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125;","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"08_Spring注解开发","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/08_Spring注解开发","date":"2023-01-15T00:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/08-spring-zhu-jie-kai-fa.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/08-spring-zhu-jie-kai-fa.html","excerpt":"","text":"Spring注解开发&lt;bean class=&quot;com.example.entity.User&quot; id=&quot;userEntity&quot;/&gt; 等同于@Data@Component(&quot;userEntity&quot;)public class User &#123; private Integer uid; private String username; private String password;&#125;&gt; 注解开发的准备工作### 开启组件扫描如果要使用注解开发必须要开启组件扫描，这样加了注解的类才会被识别出来。Spring才能去解析其中的注解。&lt;!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类--&gt;&lt;context:component-scan base-package=&quot;com.example&quot;/&gt; 这里试一下连接数据库，查数据普通的jdbc的方法 &lt;!-- applicationContext --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;import resource=&quot;classpath:/mysql/jdbc.xml&quot;/&gt;&lt;/beans&gt; &lt;!-- jdbc.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:mysql/jdbc.properties&quot;/&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;spring.datasource.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;spring.datasource.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;spring.datasource.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spring.datasource.url= jdbc:mysql://localhost:3306/test?serverTimezone=UTCspring.datasource.username= rootspring.datasource.password= 123456spring.datasource.driver-class-name= com.mysql.cj.jdbc.Driverspring.datasource.name= com.alibaba.druid.pool.DruidDataSource public interface UserDao &#123; String selectUserById(Integer id); String updateUserStatusById(Integer id,String status);&#125;@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public String selectUserById(Integer id) &#123; return &quot;select * from user where uid=&quot;+id; &#125; @Override public String updateUserStatusById(Integer id,String status) &#123; return &quot;update user set status=&#x27;&quot;+status+&quot;&#x27; where uid=&quot;+id; &#125;&#125;public class Application_10 &#123; public static void main(String[] args) throws Exception &#123; int id=1; String status=&quot;睡觉&quot;; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DruidDataSource dataSource = (DruidDataSource) context.getBean(&quot;dataSource&quot;); UserDao userDao= (UserDao) context.getBean(&quot;userDao&quot;); // 1.导入驱动jar包 // 2.加载驱动 Class.forName(dataSource.getDriverClassName()); // 3.获取数据库连接对象 Connection connection = DriverManager.getConnection(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword()); // 4.定义sql语句 // 5.获取执行sql语句的对象 Statement statement = connection.createStatement(); // 6.执行sql并接收返回的对象 statement.executeUpdate(userDao.updateUserStatusById(id,status)); ResultSet resultSet = statement.executeQuery(userDao.selectUserById(id)); // 7.处理结果 while (resultSet.next()) &#123; System.out.println(&quot;User(&quot; + resultSet.getInt(&quot;uid&quot;) + &#x27;,&#x27; + resultSet.getString(&quot;name&quot;) + &#x27;,&#x27; + resultSet.getString(&quot;gender&quot;) + &#x27;,&#x27; + resultSet.getInt(&quot;age&quot;) + &#x27;,&#x27; + resultSet.getInt(&quot;parent_id&quot;) + &#x27;,&#x27;+ resultSet.getString(&quot;status&quot;)+&quot;)&quot;); &#125; // 8.关闭连接，释放资源 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 将uid为1的user的status字段更新为睡觉后查询输出常用注解有@Component、@Repository、@Service、@Controller @Value @Value并不依赖于set方法，支持SPEL表达式 &lt;context:component-scan base-package=&quot;org.example&quot;/&gt; @ToString@Component(&quot;userEntity&quot;)public class User &#123; @Value(&quot;1&quot;) private Integer uid; @Value(&quot;admin&quot;) private String username; @Value(&quot;123456&quot;) private String password;&#125; public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User userEntity = (User) context.getBean(&quot;userEntity&quot;); System.out.println(userEntity); &#125;&#125; 我这里User类并没有给set方法，并不影响运行结果，说明@Value并不依赖于set方法 @Autowired @Repositorypublic class UserDao &#123; @Value(&quot;名字&quot;) private String name;&#125;@Service(&quot;service&quot;)public class UserService &#123; @Autowired private UserDao userDao;&#125;public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //User userEntity = (User) context.getBean(&quot;userEntity&quot;); //System.out.println(userEntity); UserService userService = (UserService) context.getBean(&quot;service&quot;); System.out.println(userService); &#125;&#125; @Qualifier 假如说，我们现在有多个UserDaoImpl实现UserDao此时@Autowired根据类型会找到多个类，此时会发生报错 No qualifying bean of type &#39;org.example.dao.UserDao&#39; available: expected single matching bean but found 2: userDao1,userDao2 如何解决？ public interface UserDao &#123;&#125;@Repository(&quot;userDao1&quot;)public class UserDaoImpl implements UserDao &#123; @Value(&quot;名字&quot;) private String name;&#125;@Repository(&quot;userDao2&quot;)@ToStringpublic class UserDaoImpl2 implements UserDao &#123; @Value(&quot;名字2&quot;) private String name;&#125; 可以看到Idea这里也提示了报错信息 @Service(&quot;userService&quot;)@ToStringpublic class UserService &#123; @Autowired @Qualifier(&quot;userDao1&quot;) private UserDao userDao;&#125; 可以通过@Qualifier(&quot;BeanName&quot;)来指定对应的bean这里的@Qualifier(&quot;userDao1&quot;)和UserDao接口下的@Repository(&quot;userDao1&quot;)对应 注意，@Qualifier注解不能单独使用，需配合@Autowired来使用","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"01_AOP入门","slug":"编程语言/Java/学习/框架/Spring/SpringAOP/01_AOP入门","date":"2023-01-15T00:00:00.000Z","updated":"2024-06-01T14:12:24.954Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/01-aop-ru-men.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springaop/01-aop-ru-men.html","excerpt":"","text":"01_AOP入门 AOP为Aspect Oriented Programming的缩写，意为:面向切面编程。他是一种可以在不修改原来的核心代码的情况下给程序动态统—进行增强的一种技术。SpringAOP:批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。需求：要求让service包下所有类的所有方法在调用前都输出:方法被调用了。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;_01_Spring_AOP&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- lombok依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- IOC相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AOP相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; @Servicepublic class PhoneService &#123; public void toInit()&#123; System.out.println(&quot;PhoneService中toInit的核心代码&quot;); &#125;&#125;@Servicepublic class UserService &#123; public void toInit()&#123; System.out.println(&quot;UserService中toInit的核心代码&quot;); &#125;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt; &lt;!-- 开启aop注解支持 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 创建切面类创建一个类，在类上加上@Component和@Aspect使用@Pointcut注解来指定要被增强的方法使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。 import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class MyAspect &#123; // 对哪些方法进行增强 @Pointcut(&quot;execution(* com.example.service.*.toInit(..))&quot;) public void pt()&#123;&#125; // 怎么增强 @Before(&quot;pt()&quot;) public void methodBefore()&#123; System.out.println(&quot;方法被调用了&quot;); &#125;&#125; public class Application_01 &#123; public static void main(String[] args) &#123; // 创建容器 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 获取对象 PhoneService phoneService = context.getBean(PhoneService.class); UserService userService = context.getBean(UserService.class); // 方法调用 phoneService.toInit(); userService.toInit(); &#125;&#125;","categories":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"}],"tags":[{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"}]},{"title":"07_Spring低频知识点","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/07_Spring低频知识点","date":"2023-01-14T06:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/07-spring-di-pin-zhi-shi-dian.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/07-spring-di-pin-zhi-shi-dian.html","excerpt":"","text":"Spring低频知识点 bean的配置 name属性 lazy-init init-method destory-method factory-bean&amp;factory-method bean的配置name属性&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.User&quot; id=&quot;userEntity&quot; name=&quot;user1&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class Application_08 &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user= (User) context.getBean(&quot;userEntity&quot;); System.out.println(user); &#125;&#125;// User(uid=1, username=admin, password=123456)public class Application_08 &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user= (User) context.getBean(&quot;user1&quot;); System.out.println(user); &#125;&#125;// User(uid=1, username=admin, password=123456) User user= (User) context.getBean(&quot;user1&quot;); 可以通过id or name来获取bean对象name可以赋多个名字，如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.User&quot; id=&quot;userEntity&quot; name=&quot;user1,user2&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class Application_08 &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user= (User) context.getBean(&quot;user2&quot;); System.out.println(user); &#125;&#125; lazy-init scope=&quot;singleton&quot;单例bean，默认在容器创建时创建而lazy-init是在第一次调用getBean方法是创建对象和懒加载类似，需要用到的时候再加载lazy-init=&quot;true&quot;或者lazy-init=&quot;false&quot;两种情况来进行对比 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.User&quot; lazy-init=&quot;true&quot; id=&quot;userEntity&quot; name=&quot;user1,user2&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; init-method 设置出初始化方法，在对象创建之后，自动调用指定方法 @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String username; private String password; private void initUser()&#123; System.out.println(&quot;学生对象初始化中---&quot;); &#125;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.User&quot; id=&quot;userEntity&quot; init-method=&quot;initUser&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; // 学生对象初始化中---// User(uid=1, username=admin, password=123456) 注意：该初始化方法必须是空参方法 destory-method 和init-method一样，这两个方法都需要是空参方法怎么样销毁user对象？注意，配置文件中默认是单例bean，所以在容器销毁的时候，会销毁对象 public class Application_08 &#123; public static void main(String[] args) throws InterruptedException &#123; ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user= (User) context.getBean(&quot;userEntity&quot;); System.out.println(user); context.close(); &#125;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.User&quot; id=&quot;userEntity&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; @Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String username; private String password; private void initUser()&#123; System.out.println(&quot;学生对象初始化中---&quot;); &#125; private void destoryUser()&#123; System.out.println(&quot;学生对象销毁前调用，用于释放资源---&quot;); &#125;&#125; factory-bean&amp;factory-method@Datapublic class Car &#123; /** * 发动机 */ private Motor motor; /** * 方向盘 */ private SteeringWheel steeringWheel; /** * 轮胎 */ private Tyre tyre; /** * 测试发动机 */ public void testMotor()&#123; System.out.println(&quot;测试发动机---&quot;); &#125; /** * 测试方向盘 */ public void testSteeringWheel()&#123; System.out.println(&quot;测试方向盘---&quot;); &#125; /** * 测试轮胎 */ public void testTyre()&#123; System.out.println(&quot;测试轮胎---&quot;); &#125;&#125;public class Motor &#123;&#125;public class SteeringWheel &#123;&#125;public class Tyre &#123;&#125; /** * @author 深海 * @version 1.0.0 * @date 2023/01/14 * @doc 汽车实例工厂 * @since 1.0.0 */public class CarFactory &#123; public Car getCar()&#123; Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); return car; &#125;&#125;/** * @author 深海 * @version 1.0.0 * @date 2023/01/14 * @doc 汽车静态工厂 * @since 1.0.0 */public class CarStaticFactory &#123; public static Car getCar()&#123; Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); return car; &#125;&#125; public class MyTest &#123; @Test public void test1()&#123; Car car = new Car(); // 设置属性 car.setMotor(new Motor()); car.setSteeringWheel(new SteeringWheel()); car.setTyre(new Tyre()); // 调用相关方法进行调试 car.testMotor(); car.testSteeringWheel(); car.testTyre(); System.out.println(car); &#125; /** * 使用实例工厂来创建Car对象 */ @Test public void test2()&#123; CarFactory factory=new CarFactory(); Car car=factory.getCar(); System.out.println(car); &#125; /** * 使用静态工厂来创建Car对象 */ @Test public void test3()&#123; Car car=CarStaticFactory.getCar(); System.out.println(car); &#125;&#125; 总体来说，实例工厂和静态工厂就是提取代码、增加代码复用性的作用上述方法还是手动调用方法，接下来使用Spring来自动调用 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 创建实例工厂 --&gt; &lt;bean class=&quot;com.example.factory.CarFactory&quot; id=&quot;carFactory&quot;/&gt; &lt;!-- 使用实例工厂创建Car，注入容器 --&gt; &lt;bean factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot; id=&quot;car1&quot;/&gt;&lt;/beans&gt; @Testpublic void test4()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Car car1 = (Car) context.getBean(&quot;car1&quot;); System.out.println(car1);&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- &amp;lt;!&amp;ndash; 创建实例工厂 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;bean class=&quot;com.example.factory.CarFactory&quot; id=&quot;carFactory&quot;/&gt;--&gt;&lt;!-- &amp;lt;!&amp;ndash; 使用实例工厂创建Car，注入容器 &amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;bean factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot; id=&quot;car1&quot;/&gt;--&gt; &lt;!-- 使用静态工厂创建Car，注入容器 --&gt; &lt;bean class=&quot;com.example.factory.CarStaticFactory&quot; factory-method=&quot;getCar&quot; id=&quot;car2&quot;/&gt;&lt;/beans&gt; @Testpublic void test5()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Car car2 = (Car) context.getBean(&quot;car2&quot;); System.out.println(car2);&#125; 细心地小伙伴可能发现了，为啥结果输出了两遍？测试实例工厂的时候，注释掉静态工厂的配置测试静态工厂的时候，注释掉实例工厂的配置其实就是两个工厂的配置之间的影响，测试哪个，就留哪个的配置","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"06_引入XML配置文件","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/06_引入xml配置文件","date":"2023-01-14T05:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/06-yin-ru-xml-pei-zhi-wen-jian.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/06-yin-ru-xml-pei-zhi-wen-jian.html","excerpt":"","text":"引入XML配置文件 注意看左侧的项目结构将来或许有各种各样的配置，将同类的配置文件放在一起首先，jdbc.xml读取properties文件的配置，然后applicationContext导入jdbc.xml的配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc/jdbc.properties&quot;/&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;mysql.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;mysql.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;mysql.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入jdbc.xml配置文件 --&gt; &lt;import resource=&quot;classpath:jdbc/jdbc.xml&quot;/&gt;&lt;/beans&gt;","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"05_读取properties配置文件","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/05_读取properties配置文件","date":"2023-01-14T04:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/05-du-qu-properties-pei-zhi-wen-jian.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/05-du-qu-properties-pei-zhi-wen-jian.html","excerpt":"","text":"读取properties配置文件可以看到这四个属性已经注入进去了 以前是下面这种写法现在直接读取properties配置文件后，注入属性 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;_06_Read_Properties&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 读取properties配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;mysql.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;mysql.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;mysql.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; mysql.driverClassName=com.mysql.cj.jdbc.Drivermysql.url=jdbc:mysql://localhost/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaimysql.username=rootmysql.password=123456 package com.example.test;import com.alibaba.druid.pool.DruidDataSource;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; @Test public void dataSourceTest()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application_datasource.xml&quot;); DruidDataSource dataSource = (DruidDataSource) context.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125; @Test public void dataSourceTest1()&#123; //DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(); //dataSource.setUrl(); //dataSource.setUsername(); //dataSource.setPassword(); &#125;&#125; 本文第二张图片报了DruidDataSource警告，提示使用try-with-resources的写法注意：用try-with-resources来代替try-catch-finally在JavaGuide里有这里的解释，原文连接按Ctrl+F，搜索 “如何使用 try-with-resources 代替try-catch-finally“ 即可找到该位置一般情况下会在finally语句中关闭资源，如下 @Testpublic void dataSourceTest1()&#123; DruidDataSource dataSource = null; try &#123; dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;&quot;); dataSource.setUrl(&quot;&quot;); dataSource.setUsername(&quot;&quot;); dataSource.setPassword(&quot;&quot;); &#125;catch (Exception e)&#123; throw new RuntimeException(&quot;出现异常&quot;,e); &#125;finally &#123; assert dataSource != null; dataSource.close(); &#125;&#125; 使用try-with-resources来改造上面的代码 @Testpublic void dataSourceTest1()&#123; try (DruidDataSource dataSource = new DruidDataSource()) &#123; dataSource.setDriverClassName(&quot;&quot;); dataSource.setUrl(&quot;&quot;); dataSource.setUsername(&quot;&quot;); dataSource.setPassword(&quot;&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;出现异常&quot;,e); &#125;&#125; 感兴趣的可以去了解一下@Value注解，会有不一样的感觉","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"04_SPEL表达式","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/04_SPEL表达式","date":"2023-01-14T03:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/04-spel-biao-da-shi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/04-spel-biao-da-shi.html","excerpt":"","text":"SPEL表达式 先写原写法，再看spel表达式和原写法之间的区别 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- game --&gt; &lt;bean class=&quot;com.example.entity.Game&quot; id=&quot;gameEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;王者荣耀&quot;/&gt; &lt;property name=&quot;country&quot; value=&quot;中国&quot;/&gt; &lt;property name=&quot;money&quot; value=&quot;88.8&quot;/&gt; &lt;/bean&gt; &lt;!-- student --&gt; &lt;bean class=&quot;com.example.entity.Student&quot; id=&quot;studentEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;学生1&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;!-- 这里ref指向上面的gameid --&gt; &lt;property name=&quot;game&quot; ref=&quot;gameEntity&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; SPEL表达式 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- game --&gt; &lt;bean class=&quot;com.example.entity.Game&quot; id=&quot;gameEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;王者荣耀&quot;/&gt; &lt;property name=&quot;country&quot; value=&quot;中国&quot;/&gt; &lt;property name=&quot;money&quot; value=&quot;#&#123;88+0.8&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- student --&gt; &lt;bean class=&quot;com.example.entity.Student&quot; id=&quot;studentEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;学生1&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;!-- 这里ref指向上面的gameid --&gt; &lt;property name=&quot;game&quot; value=&quot;#&#123;gameEntity&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意：SPEL需要写到value属性中，而不能写在ref属性中","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"03_Set方法注入&&有参构造注入","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/03_Spring_DI","date":"2023-01-14T02:00:00.000Z","updated":"2024-06-01T14:32:53.506Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/03-spring-di.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/03-spring-di.html","excerpt":"","text":"Set方法注入&amp;&amp;有参构造注入 需知：@Data注解会为类自动生成get、set方法、toString方法使用property标签来为实体类赋值是需要生成set方法的，如果去掉了@Data注解，则需要生成set方法才行若类中不存在set方法，applicationContext.xml会爆红 import lombok.Data;@Datapublic class Student &#123; private String name; private String gender; private Integer age;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.Student&quot; id=&quot;studentEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;学生1&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; public class Application_05 &#123; public static void main(String[] args) &#123; // 创建容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 获取对象 对应applicationContext里bean标签的id Student student= (Student) context.getBean(&quot;studentEntity&quot;); System.out.println(student); &#125;&#125; value来设置Student的属性，这里bean标签里有value属性和ref属性需要注意，下面针对ref属性来进行举例 import lombok.Data;@Datapublic class Student &#123; private String name; private String gender; private Integer age; private Game game;&#125;@Datapublic class Game &#123; private String name; private String country; private Double money;&#125;// Application_05不变 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- game --&gt; &lt;bean class=&quot;com.example.entity.Game&quot; id=&quot;gameEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;王者荣耀&quot;/&gt; &lt;property name=&quot;country&quot; value=&quot;中国&quot;/&gt; &lt;property name=&quot;money&quot; value=&quot;88.8&quot;/&gt; &lt;/bean&gt; &lt;!-- student --&gt; &lt;bean class=&quot;com.example.entity.Student&quot; id=&quot;studentEntity&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;学生1&quot;/&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;!-- 这里ref指向上面的gameid --&gt; &lt;property name=&quot;game&quot; ref=&quot;gameEntity&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ref&#x3D;”gameEntity”这里指向上面game的bean标签的id值 有参构造注入 和set注入一样，set注入需要存在set方法才能注入这里同样需要存在有参构造方法才能进行注入下图为了区别，就将原本的applicationContext改名了 @Data// 全参构造方法@AllArgsConstructor// 无参构造犯法@NoArgsConstructorpublic class Game &#123; private String name; private String country; private Double money;&#125;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private String name; private String gender; private Integer age; private Game game;&#125; 这里报错是正常的，因为你game类的属性还没写完，但是给的是全参构造方法，所以会报错，把属性写完整就不会报错了这里直接换到测试方法里进行测试 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.Game&quot; id=&quot;gameEntity&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;原神&quot;/&gt; &lt;constructor-arg name=&quot;country&quot; value=&quot;China&quot;/&gt; &lt;constructor-arg name=&quot;money&quot; value=&quot;136.9&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; @Testpublic void constructorTest()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;application_constructor.xml&quot;); Game studentEntity = (Game) context.getBean(&quot;gameEntity&quot;); System.out.println(studentEntity);&#125; 这里先测试Game实体类，显然是没问题，接下来测试Student类 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.entity.Game&quot; id=&quot;gameEntity&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;原神&quot;/&gt; &lt;constructor-arg name=&quot;country&quot; value=&quot;China&quot;/&gt; &lt;constructor-arg name=&quot;money&quot; value=&quot;136.9&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.example.entity.Student&quot; id=&quot;studentEntity&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;学生2&quot;/&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;女&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;constructor-arg name=&quot;game&quot; ref=&quot;gameEntity&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; package com.example.test;import com.example.entity.Student;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; @Test public void setterTest()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;application_set.xml&quot;); Student studentEntity = (Student) context.getBean(&quot;studentEntity&quot;); System.out.println(studentEntity); &#125; @Test public void constructorTest()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;application_constructor.xml&quot;); Student studentEntity = (Student) context.getBean(&quot;studentEntity&quot;); System.out.println(studentEntity); &#125;&#125; ref和set注入的ref是一样的用法，用来关联game的bean 复杂属性怎么注入？package com.example.complexEntity;@Data@AllArgsConstructor@NoArgsConstructorpublic class Phone &#123; private double price; private String name; private String password; private String path;&#125;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int age; private String name; private Phone phone; private List&lt;String&gt; list; private List&lt;Phone&gt; phones; private Set&lt;String&gt; set; private Map&lt;String,Phone&gt; map; private int[] arr; private Properties properties;&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- plone --&gt; &lt;bean class=&quot;com.example.complexEntity.Phone&quot; id=&quot;phoneEntity1&quot;&gt; &lt;property name=&quot;price&quot; value=&quot;1999.9&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;骁龙&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;path&quot; value=&quot;红米&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.example.complexEntity.Phone&quot; id=&quot;phoneEntity2&quot;&gt; &lt;property name=&quot;price&quot; value=&quot;2999.9&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;天玑&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;654321&quot;/&gt; &lt;property name=&quot;path&quot; value=&quot;vivo&quot;/&gt; &lt;/bean&gt; &lt;!-- user --&gt; &lt;bean class=&quot;com.example.complexEntity.User&quot; id=&quot;userEntity&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;某用户&quot;/&gt; &lt;property name=&quot;phone&quot; ref=&quot;phoneEntity1&quot;/&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;元素1&lt;/value&gt; &lt;value&gt;元素2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;phones&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;phoneEntity1&quot;/&gt; &lt;ref bean=&quot;phoneEntity2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value-ref=&quot;phoneEntity1&quot;/&gt; &lt;entry key=&quot;bb&quot; value-ref=&quot;phoneEntity2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;arr&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;value&gt;5&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt; &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt; &lt;prop key=&quot;k3&quot;&gt;v3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; package com.example.test;import com.example.complexEntity.User;import com.example.entity.Student;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; @Test public void setterTest() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application_set.xml&quot;); Student studentEntity = (Student) context.getBean(&quot;studentEntity&quot;); System.out.println(studentEntity); &#125; @Test public void constructorTest() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application_constructor.xml&quot;); Student studentEntity = (Student) context.getBean(&quot;studentEntity&quot;); System.out.println(studentEntity); &#125; @Test public void complexTest() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application_complex.xml&quot;); User studentEntity = (User) context.getBean(&quot;userEntity&quot;); System.out.println(studentEntity); &#125;&#125;","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"02_bean的常用属性配置","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/02_bean的常用属性配置","date":"2023-01-14T01:00:00.000Z","updated":"2024-06-01T14:12:24.969Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/02-bean-de-chang-yong-shu-xing-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/02-bean-de-chang-yong-shu-xing-pei-zhi.html","excerpt":"","text":"bean的常用属性配置idbean的唯一表示，同一个Spring容器中不允许重复 class全类名，用于反射创建对象 scopescope主要有两个值：singleton、prototype如果设置为singleton，则一个容器中只会有一个bean对象，多个方法共用一个bean对象如果设置为prototype，则一个容器中会有多个该bean对象。每次调用getBean方法都会创建一个新对象 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- scope=&quot;prototype&quot;多例 ，scope=&quot;singleton&quot;单例， 默认是单例的 --&gt; &lt;!-- 多例：每调用一次getBean方法会创建一个新的对象，debug可以看到对象地址，单例和多例的两次对象地址不一样 --&gt; &lt;bean class=&quot;com.example.dao.impl.StudentDaoImpl&quot; id=&quot;studentDao&quot; scope=&quot;prototype&quot;&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"01_SpringIOC快速入门","slug":"编程语言/Java/学习/框架/Spring/SpringIOC/01_SpringIOC入门","date":"2023-01-14T00:00:00.000Z","updated":"2024-06-01T14:32:53.507Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/01-springioc-ru-men.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/spring/springioc/01-springioc-ru-men.html","excerpt":"","text":"SpringIOC快速入门 _04_SpringIOC_test ├─ src │ ├─ main │ │ ├─ java │ │ │ └─ com │ │ │ └─ example │ │ │ ├─ dao │ │ │ │ ├─ impl │ │ │ │ │ └─ StudentDaoImpl.java │ │ │ │ └─ StudentDao.java │ │ │ ├─ entity │ │ │ │ └─ Student.java │ │ │ └─ Application_04.java │ │ └─ resources │ │ └─ applicationContext.xml │ └─ test │ └─ java ├─ pom.xml └─ _04_SpringIOC_test.iml &lt;!-- pom.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;_04_SpringIOC_test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; &lt;!-- applicationContext.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.example.dao.impl.StudentDaoImpl&quot; id=&quot;studentDao&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; @Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private String name; private Integer id; private Integer age;&#125;public interface StudentDao &#123; Student getStudentById(Integer id);&#125;public class StudentDaoImpl implements StudentDao &#123; @Override public Student getStudentById(Integer id) &#123; return new Student(&quot;张三&quot;,1,20); &#125;&#125;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Application_04 &#123; public static void main(String[] args) &#123; // 创建容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 获取对象 StudentDao studentDao= (StudentDao) context.getBean(&quot;studentDao&quot;); Student studentById = studentDao.getStudentById(5); System.out.println(studentById); &#125;&#125;// 运行Application_04// Student(name=张三, id=1, age=20) 读取applicationContext文件 根据bean标签的class以反射的方式来创建对象，以bean标签的id为key存入map集合当中 通过getBean()方法传入key来获取","categories":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"}],"tags":[{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"}]},{"title":"阿里云OSS上传图片遇到403这个错误（谷粒商城）","slug":"报错记录/Vue/上传错误/阿里云oss图片上传错误","date":"2023-01-09T16:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/vue/shang-chuan-cuo-wu/a-li-yun-oss-tu-pian-shang-chuan-cuo-wu.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/vue/shang-chuan-cuo-wu/a-li-yun-oss-tu-pian-shang-chuan-cuo-wu.html","excerpt":"","text":"阿里云OSS上传图片遇到403这个错误（谷粒商城） upload.js?c0e8:599 POST http://gulimall-twh.oss-cn-shanghai.aliyuncs.com/ 403 (Forbidden) 挺纳闷的，跟着视频一起做的，没有漏掉授权类的步骤上网查基本都是授权的问题，还有一个同志是电脑时间的问题，说是需要电脑时间必须和北京时间同步，不能有错误但是以上都不是我报错的原因，我看了一下请求这里accessKeyId是一个undefined但是确确实实可以获取到accessKeyId开始查看前端代码（upload组件是课件里直接发的），我猜想是upload组件这里出问题了果不其然！！！将accessid改为accessId即可由于阿里云的文档改了一点，视频里是accessid，所以视频里没报错估计是阿里云文档里后来把accessid改成accessId了","categories":[{"name":"阿里云oss-403","slug":"阿里云oss-403","permalink":"https://isunderachiever.github.io/categories/%E9%98%BF%E9%87%8C%E4%BA%91oss-403/"}],"tags":[{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://isunderachiever.github.io/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]},{"title":"关闭Vue语法检查","slug":"报错记录/Vue/语法检查/语法检查","date":"2023-01-09T16:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/bao-cuo-ji-lu/vue/yu-fa-jian-cha/yu-fa-jian-cha.html","link":"","permalink":"https://isunderachiever.github.io/bao-cuo-ji-lu/vue/yu-fa-jian-cha/yu-fa-jian-cha.html","excerpt":"","text":"语法明明没有问题，却报错？ 以上操作即可关闭eslink的语法检查","categories":[{"name":"vue语法检查报错","slug":"vue语法检查报错","permalink":"https://isunderachiever.github.io/categories/vue%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99/"}],"tags":[{"name":"vue语法检查报错","slug":"vue语法检查报错","permalink":"https://isunderachiever.github.io/tags/vue%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99/"}]},{"title":"java反射","slug":"编程语言/Java/学习/基础/006_反射","date":"2023-01-04T16:00:00.000Z","updated":"2024-06-01T14:12:24.914Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/006-fan-she.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/006-fan-she.html","excerpt":"","text":"java 反射详细信息推介查看 //获取包名、类名clazz.getPackage().getName()//包名clazz.getSimpleName()//类名clazz.getName()//完整类名 //获取成员变量定义信息getFields()//获取所有公开的成员变量,包括继承变量getDeclaredFields()//获取本类定义的成员变量,包括私有,但不包括继承的变量getField(变量名)getDeclaredField(变量名) //获取构造方法定义信息getConstructor(参数类型列表)//获取公开的构造方法getConstructors()//获取所有的公开的构造方法getDeclaredConstructors()//获取所有的构造方法,包括私有getDeclaredConstructor(int.class,String.class) //获取方法定义信息getMethods()//获取所有可见的方法,包括继承的方法getMethod(方法名,参数类型列表)getDeclaredMethods()//获取本类定义的的方法,包括私有,不包括继承的方法getDeclaredMethod(方法名,int.class,String.class) //反射新建实例clazz.newInstance();//执行无参构造创建对象clazz.newInstance(222,&quot;韦小宝&quot;);//执行有参构造创建对象clazz.getConstructor(int.class,String.class)//获取构造方法 //反射调用成员变量clazz.getDeclaredField(变量名);//获取变量clazz.setAccessible(true);//使私有成员允许访问f.set(实例,值);//为指定实例的变量赋值,静态变量,第一参数给nullf.get(实例);//访问指定实例变量的值,静态变量,第一参数给null //反射调用成员方法Method m = Clazz.getDeclaredMethod(方法名,参数类型列表);m.setAccessible(true);//使私有方法允许被调用m.invoke(实例,参数数据);//让指定实例来执行该方法 获取对象字节码的3种方式// 1.public static void getClazz1() &#123; User user = new User(); Class&lt;? extends User&gt; clazz = user.getClass(); System.out.println(clazz);&#125;// 2.public static void getClazz2() &#123; Class&lt;User&gt; clazz = User.class; System.out.println(clazz);&#125;// 3.public static void getClazz3() &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.example.domain.User&quot;); System.out.println(clazz); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125;&#125; public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(getClazz()); // class com.example.domain.User System.out.println(getClazz().getName()); // com.example.domain.User System.out.println(getClazz().getSimpleName()); // User System.out.println(getClazz().getPackage()); // package com.example.domain System.out.println(getClazz().getPackage().getName()); // com.example.domain &#125; public static Class&lt;?&gt; getClazz()&#123; try &#123; return Class.forName(&quot;com.example.domain.User&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; package com.example.mytest;import com.example.domain.User;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.List;public class MyTest &#123; public static void main(String[] args) &#123; createObjectByReflect(); &#125; /** * 获取 Class 对象 * 方法1 */ public static void getClazz1() &#123; User user = new User(); Class&lt;? extends User&gt; clazz = user.getClass(); System.out.println(clazz); &#125; /** * 获取 Class 对象 * 方法2 */ public static void getClazz2() &#123; Class&lt;User&gt; clazz = User.class; System.out.println(clazz); &#125; /** * 获取 Class 对象 * 方法3 */ public static void getClazz3() &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.example.domain.User&quot;); System.out.println(clazz); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取类的所有方法信息 */ public static void getAllMethods() &#123; Class&lt;?&gt; clazz = getClazz(); Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method); &#125; &#125; /** * 获取类的所有成员属性信息 */ public static void getAllFields() &#123; Field[] declaredFields = getClazz().getDeclaredFields(); for (Field f : declaredFields) &#123; System.out.println(f); &#125; &#125; /** * 获取类的构造方法信息 */ public static void getAllConstructors() &#123; try &#123; Constructor&lt;?&gt;[] declaredConstructors = getClazz().getDeclaredConstructors(); for (Constructor&lt;?&gt; constructor : declaredConstructors) &#123; System.out.println(constructor); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // 利用反射动态创建对象实例 /** * 通过反射---创建对象 */ public static void createObjectByReflect() &#123; Class&lt;?&gt; clazz = getClazz(); try &#123; //User user = (User) clazz.newInstance(); Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor(Integer.class,String.class,Integer.class,String.class, List.class); User user = (User) declaredConstructor.newInstance(1, &quot;张三&quot;, 12, &quot;男&quot;, null); System.out.println(user); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 提取方法：---获取class对象 * * @return &#123;@link Class&#125;&lt;&#123;@link ?&#125;&gt; */ private static Class&lt;?&gt; getClazz() &#123; try &#123; return Class.forName(&quot;com.example.domain.User&quot;); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; // User@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer uid; private String name; private Integer age; private String gender; private List&lt;User&gt; children;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"DB22_数据库安全管理","slug":"数据库/MySQL/大数据学习/DB20&DB21&DB22/DB22_数据库安全管理","date":"2022-12-30T02:00:00.000Z","updated":"2024-06-01T14:12:24.881Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db22-shu-ju-ku-an-quan-guan-li.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db22-shu-ju-ku-an-quan-guan-li.html","excerpt":"","text":"访问控制原理MySQL的访问权限是通过两个方面来认证的。首先会进行用户的IP、用户名及密码校验，校验通过的用户，才能连接上MySQL,当连上后，用户进行任何操作时，MySQL都会对其所拥有的权限进行校验，拥有该权限，才会执行用户请求的操作。否则，不执行 分类和分配原则权限分类对数据的操作，比如增删改查。结构的操作，比如创建库，修改表结构等。管理方面的权限，比如创建用户、分配权限等分配原则给予最小权限，比如目前该用户只需要看的权限且只需要看一个表时，那就不要去分配所有表的读权限。只限制为一个表的权限，不要怕麻烦就给予所有表的读权限。创建用户时一定要限制IP及设定足够强度的密码。定期清理不需要的用户，及回收那些不需要的权限 创建用户CREATE USER [IF NOT EXISTS]user [auth_option][, user [auth_option]]...DEFAULT ROLE role [, role ] ...[REQUIRE &#123;NONE | tls_option [[AND] tls_option] ...&#125;][WITH resource_option [resource_option] ...][password_option | lock_option] ...[COMMENT &#x27;comment_string&#x27;lATTRIBUTE &#x27;json_object&#x27;] CREATE USER &#x27;jeffrey&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;; 用户名的格式为’ user nam@’ host name , @’ host name为可选表示限定登录所在主机，默认值为’表示可以从任何地方进行登录。该语句创建用户jeffrey，指定密码位123456，只能在MySQL服务所在机器上登录数据库，采用默认的身份验证插件 CREATE USER &#x27;jeffrey&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;123456&#x27; PASSWORD EXPIRE; 关键字PASSWORD EXPIRE指定用户在第一次登录时必须进行密码修改 CREATE USER &#x27;jefrey&#x27; @&#x27;localhost&#x27;IDENTIFIED WITH caching_sha2_password BY &#x27;new_password&#x27; PASSWORD EXPIRE INTERVAL 180 DAYFAILED_LOGIN_ATTEMPTS 3 PASSWORD_LOCK_TIME 2; 指定caching sha2_ password 的身份验证插件，并要求每180天更改密码（密码到期)，连续3次输入密码不正确，则用户账号被锁定2天 修改用户ALTER USER user2251 ACCOUNT UNLOCK; 删除用户通过DROP USER语句对用户进行删除操作，具体语法很简单，如下: DROP USER[IF NOT EXISTS] user [, user] ... DROP USER命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表的相应记录都消失了。例子:删除用户jeffrey用户 DROP USER &#x27;jeffrey&#x27; @&#x27;localhost&#x27; 如果没有指定@’localhost’，则删除的是jeffrey@’%’ drop user if exists &#x27;twh&#x27;@&#x27;localhost&#x27;; 授权使用下面的语句多用户进行授权、回收: GRANT prvileges_name ON [object_type] priv_level TO username@host 【WITH GRANT OPTION】;REVOKE privileges name ON dbname.table name FROM username@host; 权限 含义和授权级别 ALL [PRIVILEGES] 授予某个特定级别的所有权限，出GRANT OPTION之外 ALTER 允许使用ALTER TABLE语句，级别为GLOBAL、DATBASE、TABLE ALTER ROUTINE 允许修改或删除存储过程，级别为GLOBAL、DATABASE、PROCEDURE CREATE 允许创建数据库和表，级别为GLOBAL、DATBASE、TABLE CREATE ROUTINE 允许创建存储例程，级别为GLOBAL、DATABASE CREATE TABLESPACE 允许创建、修改、删除表空间和日志文件组，级别为GLOBAL CREATE TEMPORARY TABLES 允许创建临时表，级别为GLOBAL、DATABASE CREATE USER 允许使用CREATE USER,DROP USER, RENAME USER和REVOKE ALL PRIVILEGES语句，级别为GLOBAL GRANT SELECT,INSERT ON *.* TO u1; 针对所有的数据库上对用户u1授予查询和插入操作权限 GRANT SELECT, INSERT,UPDATE ON *.* TO u1; 针对所有的数据库上对用户u1授予查询、插入和修改操作权限 REVOKE INSERT,UPDATE ON db1.* FROM u1; 收回u1用户在db1数据库的插入和修改操作权限，意味着该用户在db1数据库上只有只读权限，无法对数据进行更改 GRANT UPDATE(id,name) ON test.table1 TO u1; 授予用户u1可以对test.table1表的id和name列进行更新。注意:权限都是单独授予的，对某个表具有update权限不会导致自动得到select权限 GRANT SELECT ON test.* TO u1; 授予U1可以对test数据库中的所有表进行查询 GRANT CREATE，ALTER, DROP, CREATE VIEW ON test.* TO u1; 授予u1在 test数据库中创建、修改、删除表的权限以及创建视图的权限 GRANT ALL ON *.* to u1 WITH GRANT OPTION; 授予u1具有和root@%一样的权限","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB21_存储函数","slug":"数据库/MySQL/大数据学习/DB20&DB21&DB22/DB21_存储函数","date":"2022-12-30T01:45:00.000Z","updated":"2024-06-01T14:12:24.880Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db21-cun-chu-han-shu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db21-cun-chu-han-shu.html","excerpt":"","text":"什么是存储函数存储函数和存储过程一样，都是在数据库中定义一些SQL语句的集合。存储函数可以通过return语句返回函数值，主要用于计算并返回一个值。而存储过程没有直接返回值，主要用于执行操作。存储函数不需要有输入参数，并且可以直接调用，不需妻CALL读句，且必须有一条包含RETURN语句。存储函数和存储过程的区别 存储函数 存储过程 不能拥有输出参数 可以拥有输出参数 可以直接调用存储函数，不需要CALL语句 需要CALL语句调用存储过程 必须包含一条RETURN语句 不允许包含RETURN语句 创建存储函数在MySQL中，使用CREATE FUNCTION语句来创建存储函数，其语法形式如下 CREATE FUNCTION sp_name ([func_parameter[...])RETURNS type[characteristic ...] routine_body 注意:在具体创建函数时，函数名不能与已经存在的函数名重名，否则创建出错其中各个参数的含义如下: sp_name参数:表示存储函数的名称 func_parameter:表示存储函数的参数列表 RETURNS type:指定返回值的类型，注意这里是RETURNS而不是RETURN characteristic参数:指定存储函数的特性，该参数的取值与存储过程是一样的 routine_body参数:表示SQL代码的内容，可以用BEGIN…END来标示SQL代码的开始和结束。func_parameter可以由多个参数组成，其中每个参数由参数名称和参数类型组成，其形式如下:param_name type;其中: 存储函数只支持IN类型参数，布置OUT或者INOUT类型 param_name参数是存储函数的参数名称 type参数指定存储函数的参数类型，该类型可以是 MySQL数据库的任意数据类型 存储函数characteristic参数characteristics指定存储过程的特性，有以下取值: LANGUAGE SQL:说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL，SQL是LANGUAGE特性的唯一值 [NOT] DETERMINISTIC:指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的，每次执行存储过程时,相同的输入会得到相同的输出，NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出，如果没有指定任意一个值，默认为NOT DETERMINISTIC [CONTAINS SQLINO SQLIREADS SQL DATAIMODIFIES SQL DATA]:指明子程序使用SQL语句的限制。CONTAINS SQL表明子程序包含SQL语句，但不包含读写数据语句;NO SQL表明子程序不包含SQL语句;READS SQL DATA说明子程序包含读数据的语句;MODIFIES SQL DATA表名子程序包含写数据的语句。默认情况下，系统会指定为CONTAINS SQL SQL SECURITYIDEFINERINVOKER]:指明谁有权限来执行。DEFINER表示只有定义着才能执行。INVOKER表示用友权限的调用者可以执行。默认情况下，系统指定为DEFINER。 COMMENT ‘string’:注释信息，用来描述存储过程或函数。 存储函数的调用存储函数的调用相当简单，语句系统提供的函数一致，可以在SELECT子句里面直接使用，调用语法:SELELCT函数名([参数列表])执行完语句，得到返回值无参数有返回 CREATE FUNCTION example.fun10) RETURNS INT DETERMINISTICBEGIN DECLARE res INT DEFAULT O;--变量声明 SELECT COUNT(*)INTO res FROM example.customers; RETURN res;END; 有参数有返回 CREATE FUNCTION example.fun2(customer_name VARCHAR(50))RETURNS INT DETERMINISTICBEGIN DECLARE customer_id lNT; --变量声明 SELECT cust_id INTO customer_id FROM example.customers WHERE cust_name = customer_nameRETURN customer_id;END; 查看函数由于存储函数和存储过程的查看、修改、删除等操作几乎相同: SHOW CREATE FUNCTION存储函数名 SHOW FUNCTION STATUS LIKE存储函数名 SELECT * FROM information_schema.routines WHERE ROUTINE_NAME&#x3D;存储函数名ROUTINES表提供了关于存储子程序(存储程序和函数)的信息。此时，ROUTINES表不包含自定义函数(UDF)SELECT *FROM information_schema routinesWHERE routine_schema F &#x27;example&#x27;AND routine_name = &#x27;fun2&#x27;AND routine_type = &#x27;FUNCTION&#x27;\\G routine_schema表示函数在那个数据库(SCHEMA)中 routine_name表示函数的名称 routine_type表示类型，取值只有两个:PROCEDURE或者FUNCTION","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB20_存储过程-编程基础","slug":"数据库/MySQL/大数据学习/DB20&DB21&DB22/DB20_存储过程-编程基础","date":"2022-12-30T01:00:00.000Z","updated":"2024-06-01T14:12:24.878Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db20-cun-chu-guo-cheng-bian-cheng-ji-chu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db20-db21-db22/db20-cun-chu-guo-cheng-bian-cheng-ji-chu.html","excerpt":"","text":"MySQL变量MySQL变量一共分为两大类:系统变量和用户自定义变量系统变量,由系统提供，不是用户定义，属于服务器层面 会话变量，仅仅针对当前会话(连接)有效 全局变量，服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话(连接)有效用户自定义变量，就是字面的意思，由用户自定义的变量 局部变量，仅仅在定义它的BEGIN END中有效 会话变量，针对于当前会话(连接)有效，与会话变量作用域相同 查看系统变量系统变量分为全局级(GLOBAL)和会话级(SESSION)，故在客户端连接到服务端后，可以分别查看全局级的系统变量和当前连接会话的会话级系统变量 修改系统变量系统变量分为全局级(GLOBAL)和会话级(SESSION)，所以，修改系统变量，也同样分为两种情形:修改会话级系统变量、修改全局级系统变量。修改系统全局变量需要SESSION_VARIABLES_ADMIN权限，一般由DBA用户进行。查看会话级系统变量可通过下述命令，来修改会话级系统变量。其只对当前连接的客户端的当次连接会话生效，对其他客户端无效。同样地，当不显式指定为session时，将默认修改会话级系统变量set session variable &#x3D;value;set variable &#x3D; value;set @@session.variable &#x3D; value;set @@variable &#x3D; value;修改全局级系统变量可通过下述命令，来修改全局级系统变量。如前所述，全局级系统变量用于在客户端建立连接时来初始化该连接会话的会话级系统变量。所以在Client 1修改了全局级系统变量后，该客户端的当次会话级系统变量的值不会发生更新。而只有其后续的新客户端连接时，才会应用修改后的全局级系统变量来初始化新连接的会话级系统变量set global variable &#x3D; value;set @@global.variable &#x3D; value; 用户自定义会话变量会话变量即为服务器为每个客户端连接维护的变量。在客户端连接时，使用相应全局变量的当前值对客户端的回话变量进行初始化。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量。其作用域与生命周期均限于当前客户端连接。会话变量的赋值set @variable_name &#x3D; expr;set @variable_name :&#x3D; expr;会话变量的查询SELECT @variable_name;注意：变量名不区分大小写，即大小写不敏感 用户自定义局部变量作用范围在BEGIN到END语句块之间。在该语句块里设置的变量，DECLARE语句专门用于定义局部变量 局部变量是使用DECLARE关键字声明 局部变量DECLARE语句出现的位置一定是在BEGIN和END之间，BEGIN..END是在函数&#x2F;存储过程&#x2F;触发器中使声明语法DECLARE变量名数据类型[属性];例如DECLARE RES INT DEFAULT O; 赋值语法SET 变量名=值;SET 变量名:=值; 例:CREATE PRDCEDURE example spl( IN v1 INT, IN v2 INT, OUT ret1 INT, OUT ret2INT)BEGIN DECLARE res,INT DEFAULT 0 SET res = v1+V2; SELECT res INTO ret1; SET res := v1*v2 SELECT res INTO ret2;END; 用户自定义变量详解 可以利用SQL语句将值存储在用户自定义变量中，然后再利用另一条SQL语句来查询用户自定义变量。这样以来，可以再不同的SQL间传递值 用户自定义变量的声明方法形如:@variable_name，其中变量名称由字母、数字、””、”_”和”$”组成。当然，在以字符串或者标识符引用时也可以包含其他字符（例如:@’my-variable’，@”my-var”，或者@’my-var’) 用户自定义变量是会话级别的变量。其变量的作用域仅限于声明其的客户端链接。当这个客户端断开时，其所有的会话变量将会被释放 用户自定义变量是不区分大小写的 在使用SET设置变量时，可以使用&#x3D;或者:&#x3D;操作符进行赋值，在SELECT子句中赋值操作符只能使用:&#x3D;。因为&#x3D;操作符将会被认为是比较操作符 用户变量的类型仅限于整形、浮点型、二进制与非二进制串和NULL 如果用户自定义变量的值以结果集形式返回，系统会将其转换成字符串形式 如果查询一个没有初始化的变量，将会以字符串类型返回NULL。变量的值是在SQL发送到客户端后才计算的在SELECT语句中，在每一个SELECT的变量表达式被发送给客户端后，才会进行计算。这就意味着，在形如HAVING，GROUP BY和ORDER BY子句是在服务器端执行)当其中有使用在当前SELECT表达式定义的变量的情况下，该语句将不会得到如期的效果。在HAVING只句中使用了在当前的SELECT列表中定义的别名c2，其使用了变量@v1。这条语句并不会得到如期的效果:@v1变量为上一次SQL语句执行的结果集中的quantity值，并非当前的。查询客户表的数据，按照客户名称生序排列，每行记录生成序号SELECT (@rnk := @rnk + 1)AS rnk,t1.*FROM (SELECT cust_id, cust_name FROM example.customersORDER BY cust_name) AS t1INNER JOIN (SELECT @rnk := 0) AS t2 if语句IF语句用来进行条件判断，根据是否满足条件(可包含多个条件)，来执行不同的语句，是流程控制中最常用的判断语句。其语法的基本形式如下 IF search_condition THEN statement_list[ELSEIF search_condition THEN statement_list]J...[ELSE statement_list]END IF 其中，search_condition参数表示条件判断语句，如果返回值为TRUE，相应的SQL语句列表(statement list）被执行;如果返回值为FALSE，则ELSE子句的语句列表被执行。statement_list可以包括一个或多个语句。例子 IF age&gt;20 THEN SET counter1=counter1+1;ELSEIF age=20 THEN SET counter2=counter2+1;ELSE SET counter3=counter3+1;END IF; SQL代码根据age与20的大小关系来执行不同的SET语句。如果age值大于20,那么将counter1的值加1;如果age值等于20，那么将counter2的值加1;其他情况将counter3的值加1。IF语句都需要使用ENDIF来结束。 case语句CASE语句也是用来进行条件判断的，它提供了多个条件进行选择，可以实现比IF语句更复杂的条件判断。CASE语句的基本形式如下 CASE case_valueWHEN when_value THEN statement_list[WHEN when value THEN statement_list]...[ELSE statement_list]END CASE case_value参数表示条件判断的变量，决定了哪一个WHEN子句会被执行when_value参数表示变量的取值，如果某个when_value表达式与case_value变量的值相同，则执行对应的THEN关键字后的statement_list中的语句;statement_list参数表示 when_value值没有与case_value相同值时的执行语句。CASE语句都要使用END CASE结束 CASE age WHEN 20 THEN SET counter2=counter2+1; ELSE SET counter3=counter3+1;END CASE; 注意这种方式只能进行单值判断，无法进行类似age &gt;20的判断然后进行相关处理 loop语句LOOP语句可以使某些特定的语句重复执行。与IF和CASE语句相比，LOOP只实现了一个简单的循环，并不进行条件判断。LOOP语句本身没有停止循环的语句，必须使用LEAVE语句等才能停止循环，跳出循环过程。LOOP语句的基本形式如下 [begin_label:]LOOP statement_listEND LOOP [end_label] 其中,begin label参数和end_label参数分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略;statement_list参数表示需要循环执行的语句。例子: add_num: LOOP SET counter=@counter+1;END LOOP add_num; 该示例循环执行counter加1的操作。因为没有跳出循环的语句（没有使用LEAVE语句)，这个循环成了一个死循环。LOOP循环都以END LOOP结束 leave语句LEAVE语句主要用于跳出循环控制。其语法形式如下:LEAVE label;其中，label参数表示循环的标志，LEAVE语句必须跟在循环标志前面。一般LEAVE配合LOOP进行使用，使用条件判断来控制是否终止循环。 add_num: LOOP SET counter=@counter+1; IF counter = 100 THEN LEAVE add_num; ELSE IF MOD(counter, 3)= 0 THEN ITERATE add_num; SELECT * FROM example.order_totals; END IF;END LOOP add_num; LEAVE与ITERATE的区别LEAVE语句和ITERATE语句都用来跳出循环语句，但两者的功能是不一样的。LEAVE语句是跳出整个循环,然后执行循环后面的程序。而ITERATE语句是跳出本次循环，然后进入下一次循环。使用这两个语句时一定要区分清楚。 while语句WHILE语句也是有条件控制的循环语句。WHILE语句和REPEAT语句不同的是,WHILE语句是当满足条件时，执行循环内的语句，否则退出循环。WHILE语句的基本语法形式如下: [begin_label:] WHILE search_condition DO statement_list UNTIL search_conditionEND WHILE [end_label] 其中 search_condition参数表示循环执行的条件，满足该条件时循环执行 statement_list参数表示循环的执行语句。 WHILE循环需要使用END WHILE来结束WHILE counter &lt; 100 DO SET counter=@counter+1;END WHILE; 循环执行counter 加1的操作，counter值小于100时执行循环。如果counter值等于100了，则跳出循环","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB19_存储过程1","slug":"数据库/MySQL/大数据学习/DB18&DB19/DB19_存储过程1","date":"2022-12-29T02:00:00.000Z","updated":"2024-06-01T14:12:24.877Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db18-db19/db19-cun-chu-guo-cheng-1.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db18-db19/db19-cun-chu-guo-cheng-1.html","excerpt":"","text":"存储过程的优点封装性通常完成一个逻辑功能需要多条SQL语句，而且各个语句之间很可能传递参数，所以，编写逻辑功能相对来说稍微复杂些，而存储过程可以把这些SQL语句包含到一个独立的单元中，使外界看不到复杂的SQL语句，只需要简单调用即可达到目的。并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码可增强SQL语句的功能和灵活性存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。可减少网络流量由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时,网络中传送的只是该调用语句，从而可降低网络负载高性能当存储过程被成功编译后，就存储在数据库服务器里了，以后客户端可以直接调用，这样所有的SQL语句将从服务器执行，从而提高性能。但需要注意的是，存储过程不是越多越好，过多的使用存储过程反而影响系统性能提高数据库的安全性和数据的完整性存储过程提高安全性的一个方案就是把它作为中间组件，存储过程里可以对某些表做相关操作，然后存储过程作为接口提供给外部程序。这样，外部程序无法直接操作数据库表，只能通过存储过程来操作对应的表，因此在一定程度上，安全性是可以得到提高的使数据独立数据的独立可以达到解耦的效果，也就是说，程序可以调用存储过程，来替代执行多条的 SQL语句。这种情况下，存储过程把数据同用户隔离开来，优点就是当数据表的结构改变时，调用表不用修改程序，只需要数据库管理者重新编写存储过程即可 执行存储过程MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数 CALL product_pricing(@price_low, @price_hight, @price_average); 其中 执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。 存储过程可以显示结果，也可以不显示结果 创建一个简单地存储过程CREATE PROCEDURE example.product_pricing()BEGINSELECT AVG(prod_price) AS price_averageFROM example.products;END; 此存储过程名为product_pricing，使用CREATEPROCEDURE example.product_pricing()进行创建;如果存储过程接收参数，所有的参数在()中列举。此存储过程有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句，调用聚合AVG函数计算产品的平均价格默认的MySQL语句分隔符为分号;，命令行实用程序也使用;作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示 DELIMITER//CREATE PROCEDURE example.product_pricing()BEGIN SELECT AVG(prod_price)AS price_average FROM example.products;END //DELIMITER; 其中，DELIMITER&#x2F;&#x2F;告诉命令行实用程序使用&#x2F;&#x2F;作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END&#x2F;&#x2F;而不是END;。这样，存储过程体内的’;’仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符， 删除存储过程存储过程在创建之后，被保存在服务器上以供使用，直至被删除。删除存储的语法为 DROP PROCEDURE [IF EXISTS] database.procedure_name 例如删除前面创建的存储的语句为 DROP PROCEDURE example.product_pricing; 注意不是运行存储过程，名称后面无需带()，只需要给出存储过程的名称即可当存在时删除如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时(如果过程不存在也不产生错误)可使用DROP PROCEDURE IF EXISTS 存储过程使用参数product pricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量(参数)变量(variable)，内存中一个特定的位置，用来临时存储数据 DROP PROCEDURE IF EXISTS example.product_pricing;CREATE PROCEDURE example.product_pricing( OUT pl DECIMAL(10,2), OUT ph DECIMAL(10,2), OUT pa DECIMAL(10,2))BEGIN SELECT MIN(prod_price),MAX(prod_price), AVG(prod_price)INTO pl, ph, pa FROM example.products;END; 此存储过过程接收3个参数: pl表示最低价格，ph表示最高价格，pa表示平均价格。每个参数必须具有指定的类型 关键字out指出相应的参数用来从存储过程传出一个值返回给调用者.MySQL支持in、Out、Inout三种参数类型，分别表示传递给存储过程、从存储过程传出、对存储过程传入和传出存储过程 通过指定INTO关键字保存到相关变量参数的数据类型存储过程的参数允许的数据类型与表中使用的数据类型相同。在定义参数时，记录集是不允许的类型，因此，不能通过一个参数返回多个行和列。为调用此修改过的存储过程，必须指定3个变量名CALL example.product_pricing(@price_low, @price_high, @price_avg); 注意:所有MySQL变量都必须以@开始。在调用时，该语句不会显示任何数据，因为所有的返回值都通过变量返回SELECT @price_low,@price_high, @price_avg; 使用IN和OUT参数。order_total接受订单号并返回该订单的合计CREATE PROCEDURE order_total( IN ord_num INT, OUT ord_total DECIMAL(10,2))BEGIN SELECT SUM(item_price * quantity) INTO ord_total FROM example.orderitems WHERE order_num = ord_num;END; ord_num定义为IN，因为订单号被传入存储过程。ord_total定义为OUT，因为要从存储过程返回合计。SELECT语句使用这两个参数，WHERE子句使用ord_num选择正确的行，INTO关键字使用ord_total存储计算出来的合计。调用CALL example.order_total(20005,@total);必须给order_total传递两个参数;第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。 复杂的存储过程迄今为止使用的所有存储过程基本上都是封装MySQL简单的SELECT语句。虽然它们全都是有效的存储过程例子，但它们所能完成的工作你直接用这些被封装的语句就能完成。只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显现出来。考虑这个场景。你需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客(或许是你所在省份中那些顾客)。那么，你需要做下面几件事情: 获得合计 把营业税根据业务规则有条件地添加到合计 返回合计（带或者不带税)DROP PROCEDURE IF EXISTS example.order_total;--名称: order_total--参数:-- ord_num =订单号码-- taxable = O表示无税，1表示合税-- ord_total =订单总金额,OUT类型，返回调用者CREATE PROCEDURE example.order_totaK( IN ord_num INT, IN taxable BOOLEAN, OUT ord_total DECIMAL(10,2))COMMENT &#x27;根据给出的含税标识，计算订单总金额&#x27;BEGIN --声明订单总金额变量 DECLARE total DECIMAL(10,2); --声明税率 DECLARE taxrate INT DEFAULT6; --计算订单总金额 SELECT SUM(item_price * quantity) INTO total FROM example.orderitems WHERE order_num = ord_num; --判断是否合税，合税则需要加上税部分的金额 IF taxable THEN --含税，将税加到订单总金额中 SELECT total* (1 + taxrate / 100) INTO total; END IF; --将结果返回参数指定的变量 SELECT total INTO ord_total;END; order_total存储过程有很大的变动 增加了注释(前面放置–，两个减号后面一个空格开始)，在存储过程复杂性增加时，这样做特别重要 添加了另外一个参数taxable，它是一个布尔值(如果要增加税则为真，否则为假) 存储过程体中，用DECLARE语句定义了两个局部变量。DECLARE要求指定变量名和数据类型，它也支持可选的默认值(这个例子中的taxrate的默认被设置为6，注意税率为6%需要在程序进行转换) SELECT语句已经改变，因此其结果存储到局部变量total而不是参数ord_total IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total 最后，用另一SELECT语句将total保存到参数ord_total COMMENT关键字:在CREATEPROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，COMMENT指定的内容将在SHOW PROCEDURE STATUS的结果中显示。 查看存储过程为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句SHOW CREATE PROCEDURE example.order_total\\G","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB18_分析函数2-窗口函数","slug":"数据库/MySQL/大数据学习/DB18&DB19/DB18_分析函数2-窗口聚合函数 copy","date":"2022-12-29T01:00:00.000Z","updated":"2024-06-01T14:12:24.876Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db18-db19/db18-fen-xi-han-shu-2-chuang-kou-ju-he-han-shu-copy.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db18-db19/db18-fen-xi-han-shu-2-chuang-kou-ju-he-han-shu-copy.html","excerpt":"","text":"聚合函数作为窗口函数在窗口中每条记录动态地应用聚合函数( SUM()、AVG()、MAX()、MIN()、COUNT() )，可以动态计算在指定的窗口内的各种聚合函数值。用来作为滑动窗口使用。作用：聚合函数作为窗口函数，是起到”累加&#x2F;累计”的效果，比如，就是截止到本行，最大值、最小值是多少与专用窗口函数的区别：括号中需要有指定列，不能为空用法：聚合函数名(字段名)OVER(PARTION BY 字段名ORDER BY字段名) AVG作为窗口函数语法：AVG(字段名)OVER(PARTION BY 字段名ORDER BY 字段名)案例查找单科成绩高于该科目平均成绩的学生名单，考虑 单科成绩，表示需要按科目进行分组，分组有两种:GROUP BY子句和窗口函数的PARTITION BY 要求平均值，需要通过AVG()实现，并且找到大于平均值的学生，那么不能减少行数，则用PARTITION BY# 方法一：select student_id, course_id, scorefrom sales.t_scores as t1where t1.score &gt; (select avg(t2.score) as avg_score from sales.t_scores as t2 where t1.course_id = t2.course_id);# 方法二：SELECT *FROM (SELECT student_id, course_id, score, AVG(score) OVER w As avg_score FROM sales.t_scores AS t1 WINDOW w AS (PARTITION BY course_id)) AS t1WHERE t1.score &gt; t1.avg_score; 实现移动平均语法AVG(字段名)OVER(ORDER BY 字段名ROWS BETWEEN一个时间点 AND一个时间点)时间点的取值有 n PRECEDING:前n行 n FOLLOWING:后n行 CURRENT ROW :当前行 UNBOUNDED PRECEDING:窗口第一行 UNBOUNDED FOLLOWING:窗口的最后一行注意事项窗口函数中的如果省略PARTITION BY，则纪术个进1力lAeI 不进行排序;用法计算指定时间的平均销售额，可以拿学生成绩表进行模拟SELECT student_id,course_id,score,AVG(score) OVER w AS avg_scoreFROM sales.t_scores AS t1WHERE t1.student_id &#x3D; ‘220102’WINDow wAS (PARTITION BY student_id ORDER BY course_id ROWS 2 PRECEDING);参数ROWS N PROCEDINGN表示在当前行的前N行，比如，N&#x3D;2，当前行在第4行，那么该平均值是第2行，第3行，第4行，这三行数据的平均值，则avg_score&#x3D;(99+87+91)&#x2F;3 &#x3D; 92.333 MIN作为窗口函数语法MIN(字段名)OVER(PARTION BY 字段名)，注意不需要使用ORDER BY案例在一个查询实现不同的最低分与自己的分数进行比较，比较差距。 每个学生的最低分 每门课程的最低分SELECT student_id,course_id,score,MIN(score) OVER w1 AS course_min_score,MIN(score) OVER w2 AS student_min_soreFROM sales.t_scores t1WINDOw w1 AS (PARTITION BY t1.course_id),w2 AS (PARTITION BY t1.student_id)LIMIT 12; 窗口函数案例应用在一个查询实现每个学生的最低最高分析，所有学生范围的最高最低分思路 每个学生的最低最高，使用PARTITION BY student_id定义窗口 所有学生范围的最低最高，不指定范围则表示全部数据SELECT distinct student_id,MIN(score) OVER w1 AS student_min_score,MAX(score) OVER w1 AS student_max_score,MIN(score) OVER w2 AS all_min_score,MAX(score) OVER w2 AS all_max_scoreFROM sales.t_scores t1WINDOW w1 AS (PARTITION BY t1.student_id),w2 AS (); 系统存储有(游戏)用户登录表user_login，模拟数据如下CREATE TABLE sales.user_login(user_name VARCHAR( 5 ),login_dt date);INSERT INTO sales.user_loginVALUES(&#x27;A&#x27;, &#x27;2020/8/1&#x27;),(&#x27;B&#x27;,&#x27;2020/8/2&#x27;),(&#x27;A&#x27;, &#x27;2020/8/2&#x27;),(&#x27;C&#x27;,&#x27;2020/8/3&#x27;),(&#x27;A&#x27;, &#x27;2020/8/3&#x27;),(&#x27;D&#x27;,&#x27;2020/8/4&#x27;),(&#x27;C&#x27;, &#x27;2020/8/4&#x27;),(&#x27;B&#x27;,&#x27;2020/8/4&#x27;),(&#x27;A&#x27;, &#x27;2020/8/4&#x27;),(&#x27;A&#x27;,&#x27;2020/8/5&#x27;),(&#x27;B&#x27;, &#x27;2020/8/5&#x27;),(&#x27;C&#x27;,&#x27;2020/8/6&#x27;),(&#x27;A&#x27;, &#x27;2020/8/6&#x27;),(&#x27;A&#x27;,&#x27;2020/8/7&#x27;),(&#x27;A&#x27;, &#x27;2020/8/8&#x27;),(&#x27;B&#x27;,&#x27;2020/8/9&#x27;); 求连续7天都登录平台的重要用户，思路 利用LEAD函数查询每个用户后7条记录，如果有则返回相应日期，如果无则返回NULLSELECT user_name,login_dt,LEAD(login_dt, 7) OVER w AS dt7FROM sales.user_loginWINDOW w AS (PARTITION BY user_name ORDER BY login_dt) 查询用户登录时间往后推七天的日期，判断LEAD和前天后的日期是否相等SELECT user_nameFROM t1 --t1为第一步封装的子查询WHERE t1.dt7 IS NOT NULLAND DATE_ADD(login_dt, INTERVAL 7 DAY) = dt7 求商品种类的按照月份统计的环比和同比数据，计算环比增长率和同比增长率。思路如下 先对原始数据按照月份进行统计形成子查询t2 基于t2使用PARTITION BY商品种类形成窗口，窗口数据按照订单月份进行升序排序 使用LAG窗口往前1行获取上月销售数据，往前推12个月获取同期销售 列间计算环比增长率和同比增长率SELECT t2.ord_month AS销售月份.t2.prod_category AS商品类别,t2.sold_quantity AS销售数量，LAG(t2.sold_quantity,1) OVER w AS 环比数量,LAG(t2.sold_quantity, 12) OVER w AS 同比数量,(t2.sold_quantity - LAG(t2.sold_quantity,1) OVER w)/LAG(t2.sold_quantity, 1) OVER w AS 同比增长率,(t2.sold_quantity - LAG(t2.sold_quantity,12) OVER w)/LAG(t2.sold_quantity, 12)OVER w AS 环比增长率FROM(SELECT DATE_FORMAT(t1.orderdate, &#x27;%Y-%m&#x27;) AS ord_month,t1.categoryname AS prod_category,SUM(t1.quantity) AS sold_quantityFROM northwind.sales t1WHERE t1.categoryname = &#x27;点心&#x27; GROUP BY prod_category,ord_month) AS t2WINDOW w AS (PARTITION BY t2.prod_category ORDER BY t2.ord_month);","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB17_分析函数1-窗口函数","slug":"数据库/MySQL/大数据学习/DB16&DB17/DB17_分析函数1-窗口函数","date":"2022-12-28T02:00:00.000Z","updated":"2024-06-01T14:12:24.875Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db16-db17/db17-fen-xi-han-shu-1-chuang-kou-han-shu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db16-db17/db17-fen-xi-han-shu-1-chuang-kou-han-shu.html","excerpt":"","text":"窗口:窗口的概念非常重要，它可以理解为记录集合。窗口函数:在满足某些条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。有的函数随着记录的不同窗口大小都是固定的，称为静态窗口;有的函数则相反，不同的记录对应着不同的窗口，称为滑动窗口窗口函数和普通聚合函数的区别聚合函数是将多条记录聚合为一条;窗口函数是每条记录都会执行，有几条记录执行完还是几条，不会改变记录的数量聚合函数也可以用于窗口函数，相对MySQL，PostgreSQL和Oracle提供更多聚合函数对于窗口的支持窗口函数的基本用法函数名OVER子句OVER关键字用来指定函数执行的窗口范围，若后面括亏中什么都个与，则忌添自凶H基于所有行进行计算;如果不为空，则支持以下4中语法来设置窗口。WINDOW NAME:给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读;PARTITION BY子句:窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行;ORDER BY子句:按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号;FRAME子句:FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。 窗口函数的使用场景在日常工作中经常会遇到类似这样的需求医院看病，怎样知道上次就医距现在的时间?产品销售的环比如何计算?怎么样得到各部门工资排名前N名员工列表?查找各部门每人工资占部门总工资的百分比?对于这样的需求，使用传统的SQL实现起来比较困难。这类需求都有一个共同的特点需要在单表中满足某些条件的记录集内部做一些函数操作，不是简单的表连接，也不是简单的聚合可以实现的，通常会让写SQL的同学焦头烂额、绞尽脑汁，费了大半天时间写出来一堆长长的晦涩难懂的自连接SQL，且性能低下，难以维护。要解决此类问题，最方便的就是使用窗口函数。 序号函数-row_number()用途:显示分区中的当前行号应用场景:查询每个学生的分数最高的前3门课程语法ROW_NUMBER() OVER(PARTITION BY 分区字段名 ORDER BY 排序字段名)例： SELECT student_id, score_rnk, scoreFROM (SELECT student_id, ROW_NUMBER() OVER (partition by student_id ORDER BY score DESC ) AS score_rnk, course_id, score FROM sales.t_scores) AS t1WHERE t1.score_rnk &lt;= 3; 序号函数-rank()对于号码220101的同学，有两门课程的成绩均为98，序号随机排了2和3。但很多情况下二者应该是并列第2，这时候，ROW_NUMBER()就不能满足需求，需要RANK()和DENSE_RANK()出场，它们和ROW_NUMBER()非常类似，只是在出现重复值时处理逻辑有所不同。语法：RANKO OVER(PARTITION BY分区字段名ORDER BY 排序字段名)例： SELECT student_id, score_rnk, scoreFROM (SELECT student_id, RANK() OVER (partition by student_id ORDER BY score DESC ) AS score_rnk, course_id, score FROM sales.t_scores) AS t1WHERE t1.score_rnk &lt;= 3; RANK():并列排序，跳过重复序号,1,2,2,4比如220101有两个98、所以并列第2，该学生的下一条记录的序号为4，而不是3 序号函数-dense_rank()语法：DENSE_RANK( OVER (PARTITION BY 分区字段名ORDER BY 排序字段名)例： SELECT student_id, score_rnk, scoreFROM (SELECT student_id, DENSE_RANK() OVER ( PARTITION BY student_id ORDER BY score DESC ) AS score_rnk, course_id, score FROM sales.t_scores) AS t1WHERE t1.score_rnk &lt;= 3; DENSE_RANK():并列排序，不跳过重复序号比如220101有两个98，所以并列第2，该学生的下―条记录的序号顺序跟进为3 分布函数-cume_dist()用途:分组内小于等于当前rank值的行数&#x2F;分组内总行数应用场景:查询小于等于当前成绩(score)的比例语法：不指定PARTITION BY则所有数据为一个组，行数为COUNT的结果·指定PARTITION BY则按照设定的字段分组例： SELECT student_id, course_id, score, CUME_DIST() OVER (ORDER BY score) AS cd1, CUME_DIST() OVER (PARTITION BY course_id ORDER BY score) AS cd2FROM sales.t_scoresWHERE course_id IN (&#x27;C001&#x27;, &#x27;C003&#x27;); 前后函数-lag(expr,n)用途:返回位于当前行的前n行应用场景:查询前1名同学的成绩和当前同学成绩的差值。在数据分析基于月份n&#x3D;1，12可以分别进行环比和同比的计算用法：LAG （PARTITION BY字段名称ORDER BY字段名称)先通过LAG()函数得到前1记录，再将当前记录和前1行记录的计算差值例子 SELECT student_id, course_id, score, LAG(score, 1) OVER (PARTITION BY course_id ORDER BY score) AS prev_score, score - LAG(score, 1) OVER (PARTITION BY course_id ORDER BY score ) AS diffFROM sales.t_scoresWHERE course_id IN (&#x27;C001&#x27;, &#x27;C003&#x27;); 前后函数-lead(expr,n)用法LEAD( PARTITION BY字段名称ORDER BY字段名称)先通过LEAD()函数得到前1记录，再将当前记录和前1行记录的计算差值 头尾函数-first_value(expr)&#x2F;last_value(expr)·用途:返回第一个FIRST_VALUE(expr)或最后一个LAST_VALUE(expr)的值·应用场景:截止到当前成绩，按照成绩排序查询第1个和最后1个同学的分数，即第一名和最后一名用法：.FIRST_VALUE&#x2F;LAST_VALUE(字段名）OVER ( PARTITION BY 字段名称 ORDER BY字段名称)例： SELECT student_id, course_id, score, FIRST_VALUE(score) OVER w AS first_score, LAST_VALUE(score) OVER w AS last_scoreFROM sales.t_scoresWHERE course_id IN (&#x27;C001&#x27;, &#x27;C003&#x27;) WINDOW w AS (PARTITION BY course_id ORDER BY score DESC); 窗口按照score降序，所以first score对每门课是固定，但是last_score会随着窗口滑动而发生变化 nth_value(expr,n)·用途:返回窗口中第n个expr的值。expr可以是表达式，也可以是列名·应用场景:截止到当前成绩，显示每个同学的成绩中排名第2和第3的课程编码用法：NTH_VALUE(字段名) OVER ( PARTITION BY 字段名称 ORDER BY 字段名称)例： SELECT student_id, course_id, score, NTH_VALUE(course_id, 2) OVER w AS second_score, NTH_VALUE(course_id, 3) OVER w AS thrid_scoreFROM sales.t_scoresWHERE student_id IN (&#x27;220101&#x27;, &#x27;220102&#x27;) WINDOW w AS (PARTITION BY student_id ORDER BY score DESC); 窗口按照score降序，所以first_score对每门课是固定，但是last_score会随着窗口滑动而发生变化","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB16_组合查询","slug":"数据库/MySQL/大数据学习/DB16&DB17/DB16_组合查询","date":"2022-12-28T01:00:00.000Z","updated":"2024-06-01T14:12:24.874Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db16-db17/db16-zu-he-cha-xun.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db16-db17/db16-zu-he-cha-xun.html","excerpt":"","text":"unionUNION操作符可以组合两个或多LECT语句的结果，不包含重复的记录。换句话说，如果某行的输出存在于一个查询结果里，那么其他查询结果同一行的记录就不会再输出了。在使用union操作符时，每个SELECT语句里必须选择同样数量的字段、同样数量的字段数据类型长度不必一样。语法SELECT column1[, column2,….…]FROM table1[, table2][WHERE conditions]UNIONSELECT column1[, column2,….]FROM table3[, table4][WHERE conditions]例：SELECT emp_id FROM sales.employee_tblUNIONSELECT emp_id FROM sales.employees_pay_tbl; union allUNION ALL操作符可以组合两ELECT语句的结果，并且包含重复的结果。其使用规则与UNION一样，它导VION基本上是一楠,只是一个返回重复的结果，一个不返回。 intersect的MySQL实现MySQL目前的版本不支持INTERSECT操作符。但是可以相关SQL语法模拟INTERSECT运算符，即使用DISTINCT组创INNER JOIN(内关联)的方式实现SELECT useridFROM( SELECT 1 AS userid FROM dual UNION ALL SELECT 1 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 4 AS userid FROM dual)INTERSECTSELECT useridFROM( SELECT 2 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 5 AS userid FROM dual)SELECT DISTINCT t1.useridFROM( SELECT 1 AS userid FROM dual UNION ALL SELECT 1 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 4 AS userid FROM dual)AS t1INNER JOIN( SELECT 2 AS userid FROM dual UNION ALL SELECT 2 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 3 AS userid FROM dual UNION ALL SELECT 5 AS userid FROM dual) AS t2ON t1.userid &#x3D; t2.userid; minus差集，即MINUS操作符组合两SLECT语句，返回第一个SELECT语句里有但第二个SELECT语句里没有的记录。同样的，它的使用规则与UNION操作符一样。目前MySQL并不支持EXCEPT。而在Oracle 中，则使用MINUS操作符来实现同样的功能。 order byORDER BY子句可以用于组合查询，但它只能用于对全部查询骞的排序，因此组合查询里虽然可能包含多个查询成ELECT语句，但只能有一个ORDER BY子句且在最后一个SQL，可以用字段名、别名或数字来引用字段。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"terminal配置","slug":"系统配置/编程配置/环境配置/Terminal配置/terminal配置","date":"2022-12-27T15:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/terminal-pei-zhi/terminal-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/terminal-pei-zhi/terminal-pei-zhi.html","excerpt":"","text":"直接右键，可以选择在终端中打开&#x2F;&#x2F;windows terminal here方便很多这里有两种安装方法 微软商店安装 github安装第一种直接打开商店搜索Windows Terminal后安装即可第二种点击链接 配置右键打开终端在C:\\Users\\用户名\\AppData\\Local下建立文件夹Terminal新建一个空白的reg注册表文件，命名为terminal.reg，可以使用txt变换后缀得到编辑terminal.reg文件，写入如下语句，这里的%USERPROFILE%可以换成绝对路径C:\\Users\\用户名 Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;打开终端&quot;&quot;Icon&quot;=&quot;%USERPROFILE%\\\\AppData\\\\Local\\\\Terminal\\\\terminal.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 然后双击注册表文件即可具体步骤可查看安装+美化","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"potplayer配置","slug":"系统配置/常规配置/potplayer配置/potplayer配置","date":"2022-12-27T13:00:00.000Z","updated":"2024-06-01T14:32:53.521Z","comments":true,"path":"/xi-tong-pei-zhi/chang-gui-pei-zhi/potplayer-pei-zhi/potplayer-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/chang-gui-pei-zhi/potplayer-pei-zhi/potplayer-pei-zhi.html","excerpt":"","text":"基本配置 配置实时翻译 参考教程如下 教程1 教程2点击此处登录百度翻译点击开始注册","categories":[{"name":"基本配置","slug":"基本配置","permalink":"https://isunderachiever.github.io/categories/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"基本配置","slug":"基本配置","permalink":"https://isunderachiever.github.io/tags/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"}]},{"title":"DB15_子查询","slug":"数据库/MySQL/大数据学习/DB14&DB15/DB15_子查询","date":"2022-12-27T01:40:00.000Z","updated":"2024-06-01T14:12:24.873Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db14-db15/db15-zi-cha-xun.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db14-db15/db15-zi-cha-xun.html","excerpt":"","text":"子查询的基本语法SELECT column_name1, column_name2, column_name3FROM table_nameWHERE column_name &#x3D; (SELECT column_name FROM table_nameWHERE conditions)规则 子查询必须位于圆括号里 除非主查询里有多个字段让子查询进行比较，否则子查询的SELECT子句里只能有一个字段 子查询里不能使用ORDER BY子句。在子查询里，我们可以利用GROUP BY子句实现ORDER BY功能 返回多条记录的子查询只能与多值操作符(比如IN)配合使用 SELECT列表里不能引用任何BLOB、ARRAY、CLOB或NCLOB类型的值 子查询不能直接被包围在函数里。 当操作符BETWEEN用于子查询，需要保证子查询结果为单值 标量子查询需求：知道区域的名称为地区，想获取该地区的所有机场列表获取所有的机场SELECT t1.* from d _airlines t1 where t1.attr_region_cd &#x3D;?可以通过班级名字确定SELECT t1.* from d_flight_attr t1 where t1.attr_name &#x3D; ‘地区”编码只有一个值（主键或唯一键)，用标量子查询实现 列子查询需求:查询2020年国庆节飞往上海的航班·确定数据源:航班表select * from f flight_info s1 where s1.flt_act dt &#x3D; ‘ 2020-10-O1’ and s1.dest station _cd in (?)确定上海的机场三字码列表select * from d _open_airports t1 where t1.city_fullname_cn &#x3D; ‘上海’ 行子查询不用行子查询的SQL语句为SELECT s1.orderid, requireddate, shipname, shipaddressFROM northwind.orders 91WHERE skorderdate &#x3D; (SELECT MIN(orderdate)FROM sales.orders)AND stshippeddate&#x3D;(SELECT MIN(shippeddate)FROM sales.orders)AND requireddate &lt;&#x3D; ‘2016-01-03”;当使用行子查询，则需要构造行元素，行元素可以由多个字段构成SELECT s1.orderid, requireddate, shipname, shipaddressFROM northwind.orders s1WHERE(s1.orderdate, s1.shippeddate)IN(SELECT MIN(orderdate),MIN(shippeddate)FROM sales.orders)AND requireddate &lt;&#x3D; ‘2016-01-03”; exists子查询[NOT] EXISTS子查询是用来判断某些条件是否满足，exists接在where之后，因为exists返回的结果只有0和1需求:查询所有的没有航班飞行的航空公司确定数据源: SELECT t1.iata_cd, t1.icao_cd, t1.fullname cn, t1.attr_region_name FROM d_airlines)AS t1 WHERE ?确定条件是否满足:NOT EXISTS(SELECT 1 FROM f flight_info WHERE airlines_cd &#x3D; t1.iata_cd)","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB14_表连接","slug":"数据库/MySQL/大数据学习/DB14&DB15/DB14_表连接","date":"2022-12-27T00:55:00.000Z","updated":"2024-06-01T14:12:24.872Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db14-db15/db14-biao-lian-jie.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db14-db15/db14-biao-lian-jie.html","excerpt":"","text":"表连接类型是把两个或多个表关联在一起来获取数据，SQL标准定义的关系型数据库里以下的关联方式 内关联，如果表中有至少一个事配，则返回行左(外)关联，即使右表中没有匹配，也从左表返回所有的行右(外)关联，即使左表中没有匹配，也从右表返回所有的行全关联，只要其中一个表中存在匹配，则返回行在SQL语句中，SELECT和FROM是SQL语句的必要子句，当进行表关联的时候，可以在FROM子句里面完成，也可以在WHERE子句里面完成，表之间关联的操作符通用使用&#x3D;符号进行，除了&#x3D;符号之外&lt;、&gt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、BETWEEN、LIKE和NOT等符号也可以使用 内关联最常用也是最重要的关联就是内关联，也被称为等值关联，平常一般所说的关联便是内关联。内关联结合利用通用字段结合两个表。内关联的语法如下SELECT table1.column1, table2.column2….FROM table1 INNER JOINtable2 ON)table1.column_name &#x3D; table2.column name[INNER JOIN table3 ON table1.column_name &#x3D; table3.column_name]另一种写法，即在WHERE里面实现表的关联SELECT table1.column1, table2.column2….FROM table1, table2[,table3][,…..]WHERE table1.column_name &#x3D; table2.column_name[AND table1.column_name &#x3D; table3.column_name]内连接使用WHER迹是oN关键字?ON比WHERE效率高。是JOIN之前的连接条件，代表两个表建立关系所遵循的规则;而WHERE是在JOIN之后的筛选条件，是对最终结果集进行过滤所遵循的规则。 外关联外关联会返回一个表里的全部记录，即使对应的记录在第二个表里不存在。以某张表为主表，取出里面的所有记录，然后每条与另外一张表(副表)进行连接。不管能不能匹配上条件，主表中的数据都会保留;副表中的数据如果匹配上则保留，匹配不上则字段置NULL。外部关联被划分为左外关联、右外关联和全外联关联。 左外关联使用LEFT [OUTER] JOIN 右外关联使用RIGHT [OUTER] JOIN·全外关联使用FULL [OUTER]JOIN在SQL标准中使用的上面的语法，另外Oracle等一些数据库使用“+”表示外部关联，虽然不是标准，但是带来了更简练的书写方式。SQL标准的外关联语法如下:FROM table1 {LEFT | RIGHT | FULL} [OUTER] JOIN table2 ON …{LEFT | RIGHT | FULL} [OUTER] JOIN table3 ON …Oracle可以写成FROM table1, table2 [, table3]WHERE table1.column_name[(+)] &#x3D; table2.column_name[(+)][AND table1.column_name[(+)] &#x3D; table3.column_name[(+)]]例： 查询产品描述和订购数量，这两个字段取自两个单独的表里。注意,并不是每件产品在表orders_tbl里都有相应的记录。这里执行了一个普通的等值结合SELECT p.prod_desc,o.qtyFROM sales.products_tbl pINNER JOIN sales.orders_tbl o ON p.prod_id = o.prod _id 第一个查询只得到5中产品的记录，但是产品共有10，我们需要显示所有产品的订单情况，而不管该产品是否有订单SELECT p.prod_desc,o.qtyFROM sales.products_tbl pLEFT OUTER JOIN sales.orders_tbl o ON p.prod_id =o.prod_id 自关联自关联利用数据表别名在SQL语句对表进行重命名，像处理两个不同表一样把表结合到自身。其语法如下所示:SELECT t1.column_name, t2.column_name[, t3.column_name]FROM table1 AS t1 [INNER JOIN |LEFTJOIN | RIGHT JOIN | FULL JOIN ] table1 AS T2 WHERE t1.column_name &#x3D; t2.column_name[ [INNERJOIN | LEFT JOIN |RIGHT JOIN |FULLJOIN ] table1 AS T3 WHERE t1.column_name &#x3D; t3.column_name]在MySQL中不支持FULL OUTER JOIN,则可以通过UNION ALL将LEFT JOIN和RIGHT JOIN组合起来,","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB12_数据库函数1","slug":"数据库/MySQL/大数据学习/DB12&DB13/DB12_数据库函数1","date":"2022-12-26T04:40:00.000Z","updated":"2024-06-01T14:12:24.869Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db12-db13/db12-shu-ju-ku-han-shu-1.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db12-db13/db12-shu-ju-ku-han-shu-1.html","excerpt":"","text":"拼接字符串串接及其他一些函数在不同类型数据库实现里略有不同，假设要把JOHN和SON串接起来形成JOHNSON Oracle的代码:SELECT ‘JOHN’ || ‘SON’,… sQLServer的代码:SELECT ‘JOHN’+’SON’,… MySQL的代码: SELECT CONCAT(‘JOHN’, ‘SON’)…MySQL中的串接函数可以连接多个字符串 TRANSLATE字符函数TRANSLATE函数搜索字符串里的字符并查找特定的字符，标记找到的位置，然后用替代字符串里对应的字符替换它。– oracle 把字符串里的空格、星号、斜线、单引号都替换为下划线select translate (‘SQL*Plus User’’s Guide’,’ *&#x2F;‘’’,’_’) from dual;mysql目前没有translate，可以用多次replace进行 REPLACE字符函数REPLACE函数用于把某个字符或字符串替换为指定的一个字符(或多个字符)，其使用类似于TRANSLATE函数，只是它是把一个字符或字符串替换到另一个字符串里，其语法是:REPLACE(‘value’ , ‘value’, [ NULL | ‘value’ ]-返回全部的first_name名，并且把全部的T都替换为B SELECT first_name, replace(first_name, &#x27;T&#x27;, &#x27;B&#x27;)FROM sales.employee_tbl; 返回员工表里的全部城市，并且把城市名称里的I都替换为Z SELECT city, replace(city, &#x27;l&#x27;, &#x27;Z&#x27;)FROM sales.employee_tbl; UPPER&#x2F;LOWER字符函数大多数实现都提供了控制数据大小写的函数。UPPER函数可以把字符串里的小写字母转化为大写,与UPPER函数相反，LOWER把字符串里的大写字符转化为小写。下面的语句把字段里产品描述所有的字符都转化为大写和小写SELECT prod_desc, UPPER(prod_desc), LOWER(prod_desc) FROM sales.products_tbl; INSTR字符函数INSTR函数用于在字符串里寻找指定的字符串，返回其所在的字符第一个字符开始的位置。ANSI语法如下所示:INSTR(column_name, search_string [,start_position [, occurence ]]其中column_name表示被查找的字符串; search_ string表示要查找的字符串; start position参数可选，表示开始寻找的位置;occurrence表示指定第几次出现，如果无法找到返回结果0MySQL的语法有所不同，没有后面两个参数，只能查找首次出现的位置例子 select city,instr(city,&#x27;I&#x27;,3,2) from employee_tbl; . Oracle数据库返回城市字段从的第3个字符开始，返回I字符第2次出现的位置 select emp_id,instr(emp_id,&#x27;5&#x27;) from sales.employee_tbl; . MySQL返回emp_id的字符5出现的位置 TRIM&#x2F;LTRIM&#x2F;RTRIM字符函数TRIM、LTRIM和RTRIM函数是另一种截取部分字符串的方式，它与SUBSTRING属于同一家族。分别用于从左右两边、左边、右边删除字符串里的字符，其语法如下所示:. TRIM (characster_string, [‘set’]). LTRIM(characster_string, [‘set’]). RTRIM(characster_string, [‘set’])对于MySQL来说，无法指定删除的字符串，只能将两边或左边或右边的空格删除例子：oracle函数将city字段左边IN字符删除select city,LTRIM(city,’IN’) from employee_tbl; LENGTH函数LENGTH函数是很常见的，用于得到字符串、数字、日期或表达式的长度(单位是字节,)其语法如下所示:LENGTH(character_string)例子Oracle函数将city字段左边IN字符删除 SELECT position,date_hire,LENGTH(position),LENGTH(date_hire)FROM sales.employee_pay_tbl; IFNULL函数IFNULL函数用于在一个表达式是NULL时从另一个表达式获得值。它可以用于大多数数据类型，但值与替代值必须是同一数据类型。其语法如下所示:IFNULL(value1, value2)例子·查询NULL值，并且用123456789代替NULL值: SELECT pager,IFNULL(pager, &#x27;123456789&#x27;) FROM sales.employee_tbl; ·应用在两个字段的算数操作，例如将salary和bonus值下相加，由于这两字段允许为NULL，所以需要是IFNUUL进行装换操作，保障结果的正确性 SELECT salary,bonus,salary + bonus,IFNULL(salary,O)+ IFNULL(bonus, 0) FROM sales.employee_pay_tbl; COALESCE函数COALESCE函数也是用指定值替代NULL值，这一点与IFNULL是一样的。其不同点在于，它可以接受一个数据集，依次检查其中每一个值，直到发现一个非NULL值。如果没有找到非NULL值，它会返回一个NULL值。例子. COALESCE函数返回BONUS、SALARY和PAY_RATE字段里第一个非NULL值。 SELECT salary,bonus,pay_rate,COALESCE(salary, bonus, pay_rate)FROM sales.employee_pay_tbl; LPAD&#x2F;RPAD函数LPAD(左填充)&#x2F;RPAD(有填充)用于在字符串左侧&#x2F;右侧添加指定的字符，其语法如下所示:. LPAD(str, len, padstr). RPAD(str, len, padstr)例子·范例在每个产品描述左侧&#x2F;右侧添加句点，使其总长度达到20个字符 select prod_desc,length(prod_desc) as len,lpad(prod_desc,20,&#x27;.&#x27;),rpad(prod_desc,20,&#x27;.&#x27;) from prod_tbl; SELECT salary,bonus,pay_rate,COALESCE(salary, bonus, pay_rate)FROM sales.employee_pay_tbl; 注意如果原始值超过指定的长度结果值会被截短 ASCII函数ASCII函数返回字符串参数第一个字符的ASCII(美国信息交换标准码)，其语法如下所示:ASCll(character_string)下面是一些例子ASCII(‘A’)返回65ASCII(‘B’)返回66ASCII(‘C’)返回67ASCII(‘a’)返回97 算数函数算术函数可以对数据库里的值根据算术规则进行运算，在不同类型数据库中，算术函数相对很标准: 绝对值– ABS 四舍五入-ROUND(X), ROUND(X,D)没有指定参数D时表示取证，当指定参数且为正数表示保留小数D，为负数时表示保留整数位的个数 平方根-SQRT 符号-SIGN(X)返回参数的符号值，使用1,0,-1分别表示参数是否整数、0或者负数 幂运算一 POWER 上限和下限-CEIL(X)&#x2F;FLOOR(X)CEIL返回大于等于参数的最小整数值，FLOOR返回小于等于参数的最大整数值 指数-EXP 三角函数- SIN&#x2F;COS&#x2F;TAN CAST&#x2F;CONVERT转换函数转换函数把数据类型从一种转换为另一种。举例来说，我们的数据通常是以字符形式保存的，但为了计算就需要把它转换为数值。算术函数和计算不能用于以字符形式表示的数据。下面是一些常见的数据转换: 字符到数字 数字到字符 字符到日期 日期到字符转换函数的语法为:CAST(expr As type [ARRAY])CONVERT(expr, type)type可以是BINARY、CHAR、DATE、DATETIME、DECIMAL、DOUBLE、FLOAT、JSON、SIGNED、UNSIGNED等MySQL定义的数据类型 函数的组合使用大多数函数可以在SQL语句里组合使用，多个函数组合使用，SQL就能够有很大的灵活性，完成各种各种的数据处理。当SQL语句的函数内部嵌有函数时，最内层的函数首先被处理，然后从里向外依次执行各个函数例子·在一个查询里组合使用两个函数(串接和子串)，把 EMP_ID字段分为3部分，再用短划线把它们连接起来，从而得到更清晰易读的社会保险号码。范例里使用了CONCAT函数来组合字符串。 SELECT CONCAT(last_name, &#x27;. &#x27;, first_name) AS name,CONCAT(SUBSTR(emp_id,1,3), &#x27;-&#x27;, SUBSTR(emp_id, 4,2), &#x27;-&#x27;, SUBSTR(emp_id, 6,4))AS id FROM sales.employee_tbl; ·使用LENGTH函数和算术运算符(+)把每个字段的姓和名的长度加在一起，然后SUM函数返回所有姓和名的长度之和。 SELECT SUM(LENGTH(last_name)+ LENGTH(first_name))As total_lengthFROM sales.employee_tbl; 例：编写一个SQL语句，以以下形式列出员工的姓名、ID和电话号码（表：employee_tbl）a) 姓名显示为Smith， Johnb) 员工ID显示为999-99-9999格式c) 电话号码显示为（999）999-9999 select concat(first_name, &#x27; &#x27;, last_name) as &#x27;员工姓名&#x27;, concat(substr(emp_id, 1, 3), &#x27;-&#x27;, substr(emp_id, 4, 2), +&#x27;-&#x27;, substr(emp_id, 6, 9)) as &#x27;员工ID&#x27;, concat(&#x27;(&#x27;, substr(phone, 1, 3), &#x27;)&#x27;, substr(phone, 4, 3), &#x27;-&#x27;, substr(phone, 7, 4)) as &#x27;员工电话&#x27;from employee_tbl;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB13_数据库函数1","slug":"数据库/MySQL/大数据学习/DB12&DB13/DB13_数据库函数2","date":"2022-12-26T04:40:00.000Z","updated":"2024-06-01T14:12:24.871Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db12-db13/db13-shu-ju-ku-han-shu-2.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db12-db13/db13-shu-ju-ku-han-shu-2.html","excerpt":"","text":"理解时间日期 MySQL以标准输出格式(YYYY-MM-DD或YY-MM-DD)检索给定日期或时间类型的值,其他格式能够被识别，但是不推荐使用(‘2012&#x2F;12&#x2F;31’, ‘2012^12131’, and ‘2012@12@31’)，可能会出现不可预测的结果。 MySQL会多种格式解释，但日期部分必须始终以year-month-day格式进行显示，当需要month-day-year台aay-montn-year格式，请使用str_to_date函数进行处理 由于两位年份的不明确化，MySQL的规则是70-99表示1970-1999,00-69表示2000 zero值(非法值的处理结果) 数据库通过与操作系统进行交互可以获取系统日期，从而用于自身需要或是满足数据库请求(比如查询)。 SQL Server通过GETDATE函数获取当前日期 Oracle通过SYSDATE函数获取当前日期（时间) MySQL CURDATE返回当前日期，CURRENT_DATE()和CURRENT_DATE为定义的同义词 CURTIME返回当前时间，CURRENT_TIME()和CURRENT_TIME为定义的同义词 NOW返回当前日期和时间，CURRENT_TIMESTAMP()和CURRENT_TIMESTAMP为定义的同义词 日期&#x2F;时间加减操作MySQL函数提供了 ADDDATE ADDTIME DATE_ADD DATE_SUB SUBDATE (DATE_SUB的同义词) SUBTIME TIMESTAMPADD等函数对日期&#x2F;时间类型的数据进行更丰富的操作select date &#x27;2020-01-01&#x27; + interval &#x27;1&#x27; day;select adddate(&#x27;2018-05-01&#x27;,1),date_add(&#x27;2018-05-01&#x27;,interval 1 day); DATE()，返回DATE或DATETIME类型数据的DATE部分DAYOFMONTH)、DAY()，返回月份中的天（0-31)DAYNAME()，返回星期的名称，例如SaturdayDAYOFWEEKO，返回参数所属的周数字索引，1表示周日，2表示周一，…，7表示周六DAYOFYEAR(，返回参数是一年中的第几天（1-366)HOUR(),提取小时数字(0-23)MINUTEO)，提取分钟数字(0-59)MONTH0，提取参数的月份数字（1-12)MONTHNAME()，提取参数的月份名称,例如MarchSECOND)，提取秒数字(0-59)QUARTER()，提取参数的季度数字（1-4）WEEKDAYO，返回参数所属的周数字索引，0表示周一，1表示周二…，6表示周日WEEKOFYEAR()，相当于WEEK(date，3)查询日期所属的周数字索引SELECT DAYOFWEEK(‘2022-03-15’);1表示周日查询日期是年中的第几天SELECT DAYOFYEAR(‘2022-03-15’);查询日期的星期名称SELECT DAYNAME(‘2022-03-15’);查询日期所在月份的名称SLEECT MONTHNAME( 2022-03-15’);查询日期所属的周数字索引SELECT WEEDAY(‘2022-03-15’);0表示周1查询日期属于第几周SELECT WEEK(‘2022-01-01’);2022-01-01是周六","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"04.后端以及数据库准备","slug":"编程语言/Java/项目/从零开始搭建前后端分离项目/Vue/04.后端以及数据库准备","date":"2022-12-25T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/04.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/04.html","excerpt":"","text":"新建的数据库新建后端项目直接自动生成，两种方法，人人开源里的renren-generator，mybatisx插件生成现在已经可以自由发送请求了链接：https://pan.baidu.com/s/1QZMyWBx6JCIpn4wF8_01gA?pwd=nc8q提取码：nc8q​","categories":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://isunderachiever.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"Eureka+Ribbon+Nacos","slug":"编程语言/Java/学习/框架/SpringCloud/day1/eureka服务注册/Eureka注册中心","date":"2022-12-23T12:30:00.000Z","updated":"2024-06-01T14:32:53.506Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/day1/eureka-fu-wu-zhu-ce/eureka-zhu-ce-zhong-xin.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/day1/eureka-fu-wu-zhu-ce/eureka-zhu-ce-zhong-xin.html","excerpt":"","text":"Eureka注册中心问题1：order-service如何得知user-service实例地址？获取地址信息的流程如下： user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册 eureka-server保存服务名称到服务实例地址列表的映射关系 order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取问题2：order-service如何从多个user-service实例中选择具体的实例？ order-service从实例列表中利用负载均衡算法选中一个实例地址 向该实例地址发起远程调用问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？ user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除 order-service拉取服务时，就能将故障实例排除了 搭建EurekaService服务 创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖(新建一个模块) 编写启动类，添加@EnableEurekaServer注解 添加application.yml文件，编写下面的配置:Eureka依赖&lt;!--eureka--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置# 服务端口server: port: 8003# 服务名称spring: application: name: eureka-server# 服务地址eureka: client: service-url: defaultZone: http://localhost:8003/eureka 服务注册将user-service服务注册到EurekaServer步骤如下: 在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖 配置application.yml依赖&lt;!--eureka客户端依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置eureka: client: service-url: defaultZone: http://localhost:8003/eureka 服务发现 引入eureka-client依赖 在application.yml中配置eureka地址 给RestTemplate添加注解@LoadBalanced 用服务名来代替ip端口远程调用&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 配置信息spring: application: name: orderserviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。不过这些动作不用我们去做，只需要添加一些注解即可。在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口 Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。通过定义IRule实现可以修改负载均衡规则，有两种方式： 代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：@Beanpublic IRule randomRule()&#123; return new RandomRule();&#125; 配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务 ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 注意，一般用默认的负载均衡规则，不做修改。 饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载： ribbon: eager-load: enabled: true clients: userservice NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。链接：https://pan.baidu.com/s/1qam0HHfZ_FNfJbXxWu9fhw?pwd=s66u提取码：s66u这里提供一个win的nacos版本[nacos-server-1.4.1.zip]，nacos-server-1.4.1.tar.gz是linux里使用的在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：GitHub主页：https://github.com/alibaba/nacosGitHub的Release下载页：https://github.com/alibaba/nacos/releases windows安装 将这个包解压到任意非中文目录下 Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程 进入bin目录，在bin内打开cmd，startup.cmd -m standalone 在浏览器输入地址：http://127.0.0.1:8848/nacos即可 linux安装：Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行上传到某个目录，例如：/usr/local/然后解压缩： tar -xvf jdk-8u144-linux-x64.tar.gz 然后重命名为java配置环境变量： export JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin 设置环境变量： source /etc/profile 命令解压缩安装包： tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包： rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式：目录内部：启动 sh startup.sh -m standalone nacos依赖父工程： &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 客户端： &lt;!-- nacos客户端依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; nacos地址 spring: cloud: nacos: server-addr: localhost:8848 修改user-service的application.yml文件，添加集群配置： spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 可以看到上述每个服务只有一个实例，其实可以多开启几个实例来测试一下，但是要修改端口，否则端口冲突默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。1）给order-service配置集群信息修改order-service的application.yml文件，添加集群配置： spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 2）修改负载均衡规则修改order-service的application.yml文件，修改负载均衡规则： userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 权重配置实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：新建命名空间namespace并填写表单给微服务配置namespace只能通过修改配置来实现。例如，修改order-service的application.yml文件 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID 如果orderservice和userservice不在一个命名空间下，则会报错 Nacos与Eureka的区别Nacos的服务实例分为两种l类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。配置一个服务实例为永久实例：spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例 Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异： Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式","categories":[{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/categories/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/tags/springcloud/"}]},{"title":"初识springcloud","slug":"编程语言/Java/学习/框架/SpringCloud/day1/初识springcloud/初识springcloud","date":"2022-12-23T12:00:00.000Z","updated":"2024-06-01T14:32:53.499Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/day1/chu-shi-springcloud/chu-shi-springcloud.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springcloud/day1/chu-shi-springcloud/chu-shi-springcloud.html","excerpt":"","text":"基本配置源码在底部链接处 新建springcloud项目文件夹 直接用idea打开 springcloud文件夹（右键选择idea打开 或者 将文件夹拖到idea图标上） 新建两个springboot项目【user-service、order-service】 右键新建，选择module 同理新建order-service项目（步骤如上） 附：若某个项目没有被识别，找到该项目的pom.xml，右键选择add as maven project即可 数据库准备 新建两个数据库，分别是cloud-order、cloud-user 在各自的数据库上建表，这里就以一个表为例（tb_user、tb_order） 随意插入一些数据 导入mybatis-plus的依赖、swagger的依赖以及mybatis-plus自动生成的依赖【两个项目都要导入这些依赖】&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--新版 mybatis-plus 自动生成器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt;&lt;!--Swagger3.x--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 编写mybatis-plus自动生成类package com.example.userservice;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import com.baomidou.mybatisplus.generator.fill.Column;import com.baomidou.mybatisplus.generator.fill.Property;import java.util.Collections;public class Generator &#123; public static void main(String[] args) &#123; //配置相关的数据库连接 // TODO TODO FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/cloud-user?serverTimezone=Asia/Shanghai&quot;, &quot;root&quot;, &quot;root&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;深海火锅店&quot;) // 设置作者 .enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 // TODO TODO .outputDir(&quot;XXX\\\\Desktop\\\\springcloud\\\\user-service\\\\src\\\\main\\\\java\\\\&quot;) // 指定输出目录 .dateType(DateType.ONLY_DATE); &#125;) .packageConfig(builder -&gt; &#123; // TODO TODO builder.parent(&quot;com.example.userservice&quot;) // 设置父包名// .moduleName(&quot;&quot;) // 设置父包模块名 .entity(&quot;domain&quot;) .controller(&quot;controller&quot;) .mapper(&quot;mapper&quot;) .service(&quot;service&quot;) .serviceImpl(&quot;service.impl&quot;) // TODO TODO 写项目的路径 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;user-service\\\\src\\\\main\\\\resources\\\\mapper\\\\&quot;)); // 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;tb_user&quot;)// 设置需要生成的表名 // TODO TODO .addTablePrefix(&quot;tb_&quot;) // 设置过滤表前缀 .mapperBuilder() // 控制器controller配置 .controllerBuilder() // 开启生成@RestController 控制器 .enableRestStyle() // 开启驼峰转连字符 .enableHyphenStyle() // 开启父类// .superClass(&quot;com.mybatisplus.generator.controller.BaseController&quot;) // 控制器统一后缀 .formatFileName(&quot;%sController&quot;) // service配置 .serviceBuilder() // service统一后缀 .formatServiceFileName(&quot;%sService&quot;) // serviceImpl统一后缀 .formatServiceImplFileName(&quot;%sServiceImpl&quot;) //mapper配置 .mapperBuilder() // 生成基础字段的map映射map .enableBaseResultMap() // 生成基础查询的sql .enableBaseColumnList() // 实体类配置 .entityBuilder() // 开启链式模型，开启lombok模型不需要开启这个// .enableChainModel() // 开启lombok模型 .enableLombok() // 开启表字段注解 .enableTableFieldAnnotation() // 逻辑删除字段 // TODO TODO //.logicDeleteColumnName(&quot;is_deleted&quot;) // 数据库表映射到实体的命名策略 .naming(NamingStrategy.underline_to_camel) // 数据库表字段映射到实体的命名策略,驼峰命名，这个未设置会按照naming来配置// .columnNaming(NamingStrategy.underline_to_camel) // 指定实体类父类// .superClass(&quot;com.mybatisplus.generator.entity.BaseEntity&quot;) // 父类字段// .addSuperEntityColumns(&quot;id&quot;, &quot;create_id&quot;, &quot;modify_id&quot;, &quot;create_date&quot;, &quot;modify_date&quot;, &quot;is_deleted&quot;)// 开启 ActiveRecord 模式，即实体类继承Model类,自己提供CRUD操作,不建议使用,会和父类形成单继承冲突// .enableActiveRecord() // 表字段填充字段，对应数据库字段，插入的时候自动填充 .addTableFills(new Column(&quot;create_date&quot;, FieldFill.INSERT)) // 表字段填充字段，对应实体类字段，插入的时候自动填充 .addTableFills(new Property(&quot;createDate&quot;, FieldFill.INSERT)) // 表字段填充字段，对应数据库字段，更新的时候自动填充 .addTableFills(new Column(&quot;modify_date&quot;, FieldFill.UPDATE)) // 表字段填充字段，对应实体类字段，更新的时候自动填充 .addTableFills(new Property(&quot;modifyDate&quot;, FieldFill.UPDATE)) // 忽略的字段// .addIgnoreColumns(&quot;version&quot;) // id自增 .idType(IdType.AUTO); // 实体类统一后缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 注意:以上写了&#x2F;&#x2F; TODO的地方都需要注意 数据库的连接 项目的地址 项目的名称 xml文件的路径，名称要改 表过滤前缀 逻辑删除字段（表中没有这个字段，可以注释掉） 运行main方法后自动生成，结构如下order同理生成（略）建议在Generator内直接ctrl+f搜索user关键词，改为order即可 先简单写个get方法来测试一下// ordercontroller@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/&#123;id&#125;&quot;) private Object getOrder(@PathVariable(&quot;id&quot;) Long id)&#123; return orderService.getById(id); &#125;&#125;// usercontroller@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/&#123;id&#125;&quot;) public Object getUser(@PathVariable(&quot;id&quot;) Long id)&#123; return userService.getById(id); &#125;&#125; order启动类上加入@MapperScan注解【OrderServiceApplication】—-user同理package com.example.orderservice;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.example.orderservice.mapper&quot;)public class OrderServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceApplication.class, args); &#125;&#125; 配置application.properties【两个项目】【user】# 应用名称spring.application.name=user-service# 应用服务 WEB 访问端口server.port=8081# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-user?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置最新全局配置文件#mybatis-plus.config-location=classpath:mybatis-config.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.userservice.domain# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto# 逻辑删除 （1为删除，0为未删除）#mybatis-plus.global-config.db-config.logic-delete-value=1#mybatis-plus.global-config.db-config.logic-not-delete-value=0# 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置#mybatis-plus.global-config.db-config.logic-delete-field=is_deleted# ==========自定义swagger配置==========swagger.enable=trueswagger.application-name=$&#123;spring.application.name&#125;swagger.application-version=1.0#swagger.application-description=1024shop电商平台管理后端接口文档swagger.application-description=user# swagger3spring.mvc.pathmatch.matching-strategy=ant_path_matcher 【order】# 应用名称spring.application.name=order-service# 应用服务 WEB 访问端口server.port=8082# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/cloud-order?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置最新全局配置文件#mybatis-plus.config-location=classpath:mybatis-config.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.orderservice.domain# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto# 逻辑删除 （1为删除，0为未删除）#mybatis-plus.global-config.db-config.logic-delete-value=1#mybatis-plus.global-config.db-config.logic-not-delete-value=0# 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置#mybatis-plus.global-config.db-config.logic-delete-field=is_deleted# ==========自定义swagger配置==========swagger.enable=trueswagger.application-name=$&#123;spring.application.name&#125;swagger.application-version=1.0swagger.application-description=order# swagger3spring.mvc.pathmatch.matching-strategy=ant_path_matcher 复制一份pom.xml到springcloud根目录进行修改&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;description&gt;springcloud项目&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;order-service&lt;/module&gt; &lt;module&gt;user-service&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 运行项目，测试 http://localhost:8081/user/1 测试用户模块 http://localhost:8082/order/1 测试订单模块 swagger配置【不需要swagger则可省略】@Component@Data@ConfigurationProperties(&quot;swagger&quot;) // 映射到properties配置，省略前缀@EnableOpenApi // 开启规范public class SwaggerConfiguration &#123; /** * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量 */ private Boolean enable; /** * 项目应用名 */ private String applicationName; /** * 项目版本信息 */ private String applicationVersion; /** * 项目描述信息 */ private String applicationDescription; @Bean public Docket docket() &#123; return new Docket(DocumentationType.OAS_30) .pathMapping(&quot;/&quot;) // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭 .enable(enable) //配置api文档元信息 .apiInfo(apiInfo()) // 选择哪些接口作为swagger的doc发布 .select() //apis() 控制哪些接口暴露给swagger， // RequestHandlerSelectors.any() 所有都暴露 // RequestHandlerSelectors.basePackage(&quot;net.xdclass.*&quot;) 指定包位置 // withMethodAnnotation(ApiOperation.class)标记有这个注解 ApiOperation .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(applicationName) .description(applicationDescription) .contact(new Contact(&quot;深海火锅店&quot;, &quot;tongstyle.gitee.io&quot;, &quot;938798576@aliyun.com&quot;)) .version(applicationVersion) .build(); &#125;&#125; order模块同理配置在controller中添加注解，在类上添加@Api注解，在方法上添加@ApiOperation(“description”)注解@RestController@RequestMapping(&quot;/order&quot;)@Apipublic class OrderController &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/&#123;id&#125;&quot;) @ApiOperation(&quot;查找用户&quot;) private Object getOrder(@PathVariable(&quot;id&quot;) Long id)&#123; return orderService.getById(id); &#125;&#125; order模块同理配置 服务调用在order模块中调用user的方法【在订单中查找用户的信息】在order模块中导入user模块的依赖 &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;user-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 在Order实体类中添加如下属性 @ApiModelProperty(&quot;用户信息&quot;)@TableField(exist = false)private User user; 在order启动类OrderServiceApplication中添加如下方法 @Beanpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 在orderservice中添加如下方法 Order queryOrderById(Long orderId); 并在impl里重写该方法 @Overridepublic Order queryOrderById(Long orderId)&#123; Order order = baseMapper.selectById(orderId); String url=&quot;http://localhost:8081/user/&quot;+order.getUserId(); User forObject = restTemplate.getForObject(url, User.class); order.setUser(forObject); return order;&#125; 更改OrderController代码 @GetMapping(&quot;/&#123;id&#125;&quot;)@ApiOperation(&quot;查找订单&quot;)private Object getOrder(@PathVariable(&quot;id&quot;) Long id)&#123; return orderService.queryOrderById(id);&#125; 当然，不添加User依赖，直接在order新建一个user实体类其实也可以 @Datapublic class User &#123; private Long id; private String username; private String address;&#125; 但是有一个非常严重的问题：以上实现的业务是根据订单查用户，如果还需要根据用户查订单的话，那么在用户模块继续导入订单模块就会形成一个问题，模块与模块之间的相互依赖关系源码：链接：https://pan.baidu.com/s/1FAVIVz92EwvNkGoMxIvMTQ?pwd=s1v5提取码：s1v5 更正之前一直没懂教程里是怎么在order服务里使用user服务的实体类的，起初我以为是上述写法，在order服务里引入了user服务的依赖，但是教程的代码里并没有引入user的依赖，所以我一直很疑惑。难道是在order服务里直接写了一个user实体类？这不太优雅啊！而且…教程的代码里依然没有在order服务里找到user实体类。。。视频看了几遍，找到了一个切入点…没有导入其他的包，所以…应该是在pojo里写了一个user实体类了，至于为什么给的代码里没在order里找到user实体类…我只能解释为后期删掉了其他的一样写，依然能实现上述效果链接：https://pan.baidu.com/s/1WerXmr-Ntp5rwhTVLMXOWQ?pwd=b75y提取码：b75y–来自百度网盘超级会员V3的分享","categories":[{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/categories/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/tags/springcloud/"}]},{"title":"DB11_数据库分组与排序","slug":"数据库/MySQL/大数据学习/DB10&DB11/DB11_数据库分组与排序","date":"2022-12-23T02:30:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db10-db11/db11-shu-ju-ku-fen-zu-yu-pai-xu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db10-db11/db11-shu-ju-ku-fen-zu-yu-pai-xu.html","excerpt":"","text":"为什么要分组？数据分组是按照逻辑次序把具有重复值的字段进行合并。比如说，一个数据库存储了关于所有员工的信息，有些员工住在不同的城市里，有些员工住在同一个城市里。我们可能需要进行一个查询，了解每个指定城市里的员工的信息。这时就是在根据城市对员工进行分组，并且创建一个统计报告。假设我们想了解每个城市的员工的平均薪水，这时可以对SALARY字段使用AVG函数，并且使用GROUP BY子句把结果按照城市进行分组。数据分组是通过在SELECT语句(查询)里使用GROUP BY子句来实现的。基于前面汇总函数，这一章将讨论如何组合使用汇总函数与GROUP BY子句，从而更高效地显示查询结果。 GROUP BY子句GROUP BY子句与SELECT语句配合使用，把相同的数据划分为一组。在SELECT语句里，GROUP BY子句在WHERE子句之后,在ORDER BY子句之前。GROUP BY子句在查询中的位置如下所示: SELECT column1, column2,FROM table1, table2GROUP BY column1, column2ORDER BY column1, column2; 在使用GROUP BY子句的时候，要养成按顺序书写的习惯，以确保逻辑正确。GROUP BY子句对CPU的运行效率有很大影响，如果我们不对提供给它的数据进行过滤，那么后期很可能需要删除大量的无用数据。所以，需要使用WHERE子句来缩小数据范围，从而确保对有用的数据进行分组。在SQL中也可以加入ORDER BY子句并且使用GROUP BY子句中的列序对返回结果进行排序，后续内容将对此进行深入介绍。 GROUP BY规则出现在SELECT子句中的单独的列,应该出现在GROUP BY子句中作为分组列在GROUP BY子句里可以使用字段名称，也可以使用一个整数来代表字段。另外，分组字段的顺序不一定需要与SELECT子句中的字段顺序相同分组列可以不出现在SELECT子句中，该情况最好避免出现如果字段在SELECT语句里找不到，但是又出现在GROUP BY子句，虽然无法不报错，但是不太合乎逻辑的:如果数据根本就不显示，我们如何对其进行分组，意义何在呢?分组列可出现在SELECT子句中的一个复合表达式中如果GROUP BY后面是一个复合表达式，那么在SELECT子句中，它必须整体作为一个表达式的一部分才能使用。 select date_format(ord_date, &#x27;%Y-%m-%d&#x27;) as &#x27;时间&#x27;,sum(ord_num)from orders_tblgroup by date_format(ord_date, &#x27;%Y-%m-%d&#x27;); 创建分组和使用聚合函数SELECT语句在使用GROUP BY子句时必须满足一定条件。特别是SELECT子句的字段应该出现在GROUPBY子句里，除了聚合函数参数中使用的字段。GROUP BY子句里的字段不必与SELECT子句里的字段具有相同的顺序。只要SELECT子句的字段名称是符合条件的，它的名称就应该出现在GROUP BY子句里。 select匹配group by字段列表 顺序不要求对于MySQL，与Oracle和其他的数据库，不太遵循标准SQL。常规的SQL要求GROUP BY来说一定要结合聚合函数，而且选择的字段除了聚合函数外，还必须在GROUP BY中出现，否则报错;但是在MySQL中不会报错，其操作相当于先进行GROUP BY,然后在每个GROUP BY下面进行LIMIT 1。 GROUP BY例子select emp_id, position, date_hire, pay_rate, date_last_raise, salary, bonusfrom employee_pay_tblgroup by emp_id, salary;select city, avg(pay_rate) &#x27;时薪平均值&#x27;, avg(salary) &#x27;月薪平均值&#x27;from emp_pay_tmpwhere city in (&#x27;WHITELAND&#x27;, &#x27;INDIANAPOLIS&#x27;)group by cityorder by 2, 3;# 以数字代替字段名称，比如排序 order by 2,3# 同等与 order by avg(pay_rate) &#x27;时薪平均值&#x27;, avg(salary) &#x27;月薪平均值&#x27; ，即以第二个和第三个字段排序 ROLLUP语句在某些情况下，对分组数据进行小计是很有用的。比如，用户既要分析各种产品每年分别在不同国家的销售数据，也需要看到每年在每个国家所有产品的销售数据总额。ANSI SQL提供了CUBE和ROLLUP语句来解决这类问题。各种数据具体的实现不一样，MySQL提供了WITH ROLLUP修饰符，该修饰符可以对分组后各组的某个列的结果值进行汇总，并在结果中输出，即提供更高一级的聚合操作。因此，ROLLUP使您能够使用单个查询在多个分析级别回答问题。例如，ROLLUP可用于为OLAP(在线分析处理)操作提供支持。ROLLUP语句可以用来进行小计，即在全部分组数据的基础上，对其中的一部分进行汇总。其ANSI语法结构如下:GROUP BY ROLLUP (column list of grouping sets)ROLLUP语句执行过程:在完成了基本的分组数据汇总以后，按照从右向左的顺序，每次去掉字段列表中的最后一个字段，再对剩余的字段进行分组统计，并将获得的小计结果插入返回表中，被去掉的字段位置使用NULL填充，最后，再对全表进行一次统计，所有字段位置均使用NULL填充。MySQL的ROLLUP语法结构稍有不同 GROUP BY column list of grouping sets WITH ROLLUP 示例： select date_format(month_ending, &#x27;%Y&#x27;), car_category, sum(quantity)from car_soldwhere month_ending&gt;=&#x27;2001-01-01&#x27;group by 1,2; select date_format(month_ending, &#x27;%Y&#x27;), car_category, sum(quantity)from car_soldwhere month_ending&gt;=&#x27;2001-01-01&#x27;group by 1,2 with rollup ; 在完成了基本的分组数据汇总以后，去掉了最后一个字段(车型)，并根据剩余的字段(年份)，再次进行分组统计，并将结果插入返回表。最后，还对全表进行了一次统计。 rollup练习rollup() 是分组函数的一种用法，配合 group by 使用。rollup() 能够起到一个多次分组求值的效果。 select sum(字段A)from 表名group by rollup(字段A) 作用：一共执行了两次分组求和：第1步：以“字段A”作为条件，进行分组求和；第2步：以所有记录作为一个大组，进行求和； 多个字段分组的语法：select sum(字段A), sum(字段B)from 表名group by rollup(字段A, 字段B) 作用：一共执行了三次分组求和：第1步：以“字段A”和“字段B”联合起来作为条件，进行分组求和；第2步：以“字段A”作为条件，进行分组求和；第3步：以所有记录作为一个大组，进行求和； CUBE语句CUBE语句的工作方式与ROLLLP有所不同。它对分组列表中的所有字段进行排列组合，并根据每一种组合结果，分别进行统计汇总。最后，CUBE语句也会对全表进行统计，体现立(N)方体的概念CUBE的ANSI语法结构如下:GROUP BY CUBE ( column list of grouping sets)CUBE语句通常被用来生成交叉报表〉比如需要根据月份(month code)、省份(province)、商品类别(prod_cartegory)三个字段获得销售数据的分组统计结果，GROUP BY语句会根据一下的每一种字段组合分组汇总，并产生结果。 month_code month_code, privince month_code, prod_category month_code, province, prod_categoryprovince province, prod_categoryprod_category grand_total MySQL目前还不支持CUBE操作!!! HAVING子句HAVING子句在SELECT语句里与GROUP BY子句联合使用时，用于告诉GROUP BY子句在输出里包含哪些分组。HAVING对于GROUP BY的作用相当于WHERE对于SELECT的作用。换句话说，WHERE子句设定被选择字段的条件，而HAVING子句设置GROUP BY子句形成分组的条件。因此，使用HAVING子句可以让结果里包含或是去除整组的数据。 IO上的过滤(WHERE) 内存中的过滤(HAVING)下面是HAVING子句在查询里的位置:SELECT column_name1, column_name2FROM table_name1, table_name2WHERE conditionsGROUP BY column_name1, column_name2HAVING conditionsORDER BY column_name1, column_name2 HAVING子句必须跟在GROUP BY子句之后,在ORDER BY子句之前。聚合函数无法结合where使用如：where avg(salary)&gt;300正确写法: having avg(salary)&gt;300","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB10_数据库聚合函数","slug":"数据库/MySQL/大数据学习/DB10&DB11/DB10_数据库聚合函数","date":"2022-12-23T01:40:00.000Z","updated":"2024-06-01T14:12:24.867Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db10-db11/db10-shu-ju-ku-ju-he-han-shu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db10-db11/db10-shu-ju-ku-ju-he-han-shu.html","excerpt":"","text":"什么是聚合函数函数是SQL里的关键字，用于对字段里的数据进行操作。函数是一个命令，通常与字段名称或表达式联合使用，处理输入的数据并产生结果。SQL包含多种类型的函数，其中聚合函数为SQL语句提供合计信息，比如计数、总和、平均等。基本的聚合函数包括COUNT、suM、MIN、MAx、AVG COUNT聚合函数COUNT函数用于统计不包含NULL值的记录或字段值，在用于查询之中时，它返回一个数值。它也可以与DISTINCT命令一起使用，从而只统计数据集里不同的记录数量。命令ALL(与DISTINCT相反)是默认的，在语句中不需要明确指定。在没有指定DISTINCT的情况下，重复的行也被统计在内。使用COUNT函数的另一种方式是与星号配合。COUNT(*)会统计表里的全部记录数量，包括重复的，也不管字段里是否包含NULL值(即使极端情况全部字段值为NULL)。COUNT语法如下： COUNT [(*)|(DISTINCT|ALL)](column_name) 注意: DISTINCT命令只能用于COUNT(column_ name)，不能与COUNT(*)一起使用 数据类型不影响COUNT的统计记过，COUNT函数统计的是行数，不涉及数据类型。行里可以包含任意类型的数据。select count(*)from products_tbl;select count(prod_id)from products_tbl;select count(distinct prod_id)from products_tbl; 在COUNT函数中使用星号，将返回所有的统计数就记录数，包括重复项和NULL 在COUNT函数指定字段名，则除NULL之外的统计数 SUM聚合函数SUM函数返回一组记录中某一个字段值的总和。它也可以与DISTINCT一起使用，这时只会计算不同记录之和。这一般没有什么意义，因为有些记录被忽略掉了，在实际应用基本上没有使用。sum语法如下： SUM( [ DISTINCT ] column_name) 虽然SUM函数只能处理数值类型的字段，无法处理其它数量类型，比如字符类型或者日期类型。但也有例外，char数据可以隐式转换为数值类型，如果数据不能隐含地转化为数值类型，其结果就是0。 # 统计全部员工的总和select sum(salary)from employee_pay_tbl;# 统计不同薪水的总和select sum(distinct salary)from employee_pay_tbl; AVG聚合函数AVG函数可以计算一组指定记录的平均值。在与DISTINCT一起使用时，它返回不重复记录的平均值。AVG函数的语法如下： AVG ([ DISTINCT ] column_name) AVG函数只能处理数值类型的字段，AVG聚合函数的参数必须是数值类型，和上述SUM聚合函数一样NULL值不包括在计算中在某些场景中，AVG统计结果被四舍五入到数据类型精度 select avg(salary)from employee_pay_tbl;select avg(distinct salary)from employee_pay_tbl; MAX聚合函数MAX函数返回一组记录中某个字段的最大值，NULL值不在计算范围之内。DISTINCT也可以使用, 但全部记录与不同记录的最大值是一样的，所以用DISTINCT没有意义。MAX函数的语法如下： MAX([ DISTINCT ] column_name) MAX函数可以针对字符类型进行聚合 select max(prod_desc)from products_tbl; MIN聚合函数MIN函数返回一组记录里某个字段的最小值，NULL值不在计算范围之内。DISTINCT也可以使用 但全部记录与不同记录的最大值是一样的，所以用DISTINCT没有意义。MIN函数的语法如下： MIN ([ DISTINCT ] column_name) MIN函数可以针对字符类型进行聚合 聚合函数组合使用SELECT COUNT(ord_num), SUM(qty), SUM(qty) / COUNT(ord_num) avg_qtyFROM orders_tbl; sum、avg、max、min、count均会忽略null值","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"认识PS界面","slug":"其他技术栈/剪辑/PS/PS异闻录/01_认识界面","date":"2022-12-22T13:50:00.000Z","updated":"2024-06-01T14:32:53.545Z","comments":true,"path":"/qi-ta-ji-zhu-zhan/jian-ji/ps/ps-yi-wen-lu/01-ren-shi-jie-mian.html","link":"","permalink":"https://isunderachiever.github.io/qi-ta-ji-zhu-zhan/jian-ji/ps/ps-yi-wen-lu/01-ren-shi-jie-mian.html","excerpt":"","text":"新建文件建立新的预设若是要放在屏幕显示则分辨率常设置为72PPI；若要作为印刷品打印出来，则要设置为300PPI 颜色模式 RGB颜色 CMYK颜色 Lab颜色RGB颜色–Red，Green，BlueCMYK颜色–青色cyan、品红色magenta、黄色yellow、黑色black 屏幕显示的画面是由红、绿、蓝这三种主动发光的光学三原色以不同比例组合而成，简称RGB 而印刷品不同，只能通过反射照上去的光线才能被看到，因此由青色、品红色、黄色这三种色彩三原色组成，而K去的是黑色black最后一个字母 理论上CMY叠加应该得到黑色，但由于当时油墨纯度不够高，三色混合出来时暗红色，因此人们专门加入了黑色以供印刷需要图像–模式 可以在这里更改颜色模式和位数图像–图像大小 可以在这里更改图像的宽、高以及分辨率【多用于对图片大小有限制的地方】 按住alt的同时滑动鼠标滚轮可以缩放图像 灰白交错的网格表示这些地方是背景，是透明的 psd是存储格式，点击文件–存储为–保存类型 里可以找到常用的图片格式，比如psd、jpg、png 点击保存后可以调节存储的图片的品质。在图片本身质量很高的时候，可选择牺牲一部分品质，来换取更小的体积 psd文件注意保存！！！psd是原创的证据 1、 psd是ps专用的可编辑格式，记录了创作文档是时的原始信息，保存了在ps里进行的绝大部分操作2、 jpg压缩率极高的同时也能展现生动丰富的图像信息3、 png的特点是无损压缩、体积小、方便传输、支持透明效果4、 看上去这些格式的图片差别不大在保存png格式的窗口中，交错是指定这张图片在网页被查看时的加载方式。为了在有限的网络速度下提升观看体验，使用带有交错格式的png图片，能够花更少的时间先看到图片模糊的全貌，然后再慢慢转变为清晰","categories":[{"name":"ps异闻录","slug":"ps异闻录","permalink":"https://isunderachiever.github.io/categories/ps%E5%BC%82%E9%97%BB%E5%BD%95/"}],"tags":[{"name":"ps学习","slug":"ps学习","permalink":"https://isunderachiever.github.io/tags/ps%E5%AD%A6%E4%B9%A0/"}]},{"title":"DB08_数据库查询","slug":"数据库/MySQL/大数据学习/DB08&DB09/DB08_数据库查询","date":"2022-12-22T12:40:00.000Z","updated":"2024-06-01T14:12:24.865Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db08-db09/db08-shu-ju-ku-cha-xun.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db08-db09/db08-shu-ju-ku-cha-xun.html","excerpt":"","text":"简单的SELECT语句语法SELECT [ * |ALL | DISTINCT column1, column2, ... ] FROM table_name[,table_name2,...]; 星号(*)表示输出结果里包含表里的全部字段 选项ALL用于显示一列的全部值，包括重复值。选项ALL是默认的操作方式，这意味着它并不在SELECT语句中明确指定。 选项DISTINCT禁止在输出结果里包含重复的行。 FROM子句FROM子句必须与SLELCT语句联合使用，它是任何查询的重要元素，其作用是告诉数据库从哪些表里获取所需的数据，它可以指定一个或多个表，且必须至少指定一个表。但是…对于MySQL来说，FROM在一些情况是可以忽略，如下: select version() as 数据库版本,now() as 当前时间,user() as 登录用户; WHERE子句查询里的条件指定了要返回满足什么标准的信息。条件的值是TRUE或FALSE，从而限制查询中获取的数据。WHERE子句用于给查询添加条件，从而去除用户不需要的数据。WHERE子句里可以有多个条件，它们之间以操作符AND或OR连接，具体的讲解和实际应用在后面章节进行。操作符是SQL里的字符或关键字，用于连接SQL语句里的元素。WHERE子句的语法如下所示: SELECT [ * |ALL | DISTINCT column1, column2,...] FROM table_name[, table_name2,...]WHERE [condition1 | expression1 ] [ AND | OR condition2 | expression2 ]; ORDER BY子句我们一般需要让输出以某种方式进行排序，为此可以使用ORDER BY子句，它能够以用户指定的列表格式对查询结果进行排列。ORDER BY子句的默认次序是升序，也就是说，如果对输出为字符的结果进行排序，就是A到Z的次序。反之，降序就是以Z到A的次序显示字符结果。对于数字值来说，升序是从1到9，降序是从9到1。ORDER BY子句的语法是: SELECT [ * |ALL | DISTINCT column1, column2,...] FROM table_name[, table_name2,...]WHERE [condition1 | expression1 ] [ AND | OR condition2 | expression2 ]ORDER BY column1|integer [ ASC | DESC]; 在ORDER BY子句中，排序的方式 指定字段名称 指定显示结果的列位置绝对索引(从1开始计数)，该方式存在一旦改变SELECT子句字段的顺序，ORDER BY的排序规则也需要进行相应的改动mysql&gt; select * from sales.products_tbl order by cost;+---------+-------------------------+-------+| prod_id | prod_desc | cost |+---------+-------------------------+-------+| 87 | Plastic Spiders | 1.05 || 13 | False Paraffin Teeth | 1.10 || 9 | Candy Corn | 1.35 || 6 | Pumpkin Candy | 1.45 || 119 | assorted Masks | 4.95 || 222 | Plastic Pumpkin 18 inch | 7.75 || 15 | Assorted Costumes | 10.00 || 90 | Lighted Lanterns | 14.50 || 11235 | Witch Costume | 29.99 |+---------+-------------------------+-------+mysql&gt; select * from sales.products_tbl order by 3;+---------+-------------------------+-------+| prod_id | prod_desc | cost |+---------+-------------------------+-------+| 87 | Plastic Spiders | 1.05 || 13 | False Paraffin Teeth | 1.10 || 9 | Candy Corn | 1.35 || 6 | Pumpkin Candy | 1.45 || 119 | assorted Masks | 4.95 || 222 | Plastic Pumpkin 18 inch | 7.75 || 15 | Assorted Costumes | 10.00 || 90 | Lighted Lanterns | 14.50 || 11235 | Witch Costume | 29.99 |+---------+-------------------------+-------+# order by 3 和 order by cost 是一个意思，3是指字段索引 查询例子select distinct prod_desc from sales.candy_tbl;select distinct(prod_desc) from sales.candy_tbl;select prod_desc as &#x27;prod_desc的别名&#x27; from sales.candy_tbl; 字符大小写敏感性在使用SQL编写代码时，大小写敏感性是一个需要理解的重要概念。一般来说，SQL命令和关键字是不区分大小写的，也就是允许我们以大写或小写来输入命令和关键字，而且可以混用。对于MySQL来说通过lower_case_table_names的设置来表名的大小敏感，1&#x3D;表示大小写不敏感，0表示敏感排序规则(gOLLATION)决定了RDBMS如何查找数据，包括排序方式和大小写敏感性等内容。数据的大小写敏感性很重要，这直接决定了WHERE子句如何匹配记录，在开发时用户务必要明确数据库在排序规则方面的相关规则 Oracle，默认是大小写敏感的 MySQL和Microsoft SQL Server，默认是大小写不敏感的。这就意味着，在进行数据匹配时，系统会忽视数据的大小写。 MySQL可以通过server、database、table、column4个级别的CHARACTER SET和COLLAIION的排序规则，越小层次设置的字符集属性，优先级越大(server &lt; database &lt; table column)，即column级别的字符集设置会覆盖其他层次的字符集设置。MySQL相关命令 查询数据库支持的字符集SHOW CHARACTER SET、SHOW CHAR SET、SHOW CHARSET常用的字符集有GBK、UTF8.UTF8MB4 查询数据库支持的排序规则SHOW COLLATIONCOLLATION中一般以”_ci”, “_cs”,”_bin”结尾，其中 ci表示case insensitive，字符串比较是大小写不敏感,a和A当做一样对待 cs表示case sensitive，字符串比较是大小写敏感,a和A会别区别对待 bin表示binary (二进制)，a和A会别区别对待 设置CHARACTER SET和COLLATIONserver，字符集默认使用utf8mb4; collation默认使用utf8mb4_0900_ai_ci，在server启动是可以修改 mysql&gt; mysqld --character-set-server=utf8 --collation-server=utf8_unicode_ci database CREATE DATABASE database_name CHARACTER SET utf8 COLLATEutf8_bin;ALTER DATABASE database_name CHARACTER SET utf8 COLLATE utf8_bin; table CREATE TABLE TABLE_NAME( …..)ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;ALTER TABLE TABLE_NAME CONVERT TO CHARACTER SET utf8 COLLATE utf8_bin; column column_name [CHAR | VARCHAR │TEXT] (length)CHARACTER SETcharacter_set_name COLLATE collation_nameALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50)BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB09_SQL操作符","slug":"数据库/MySQL/大数据学习/DB08&DB09/DB09_sql操作符","date":"2022-12-22T12:40:00.000Z","updated":"2024-06-01T14:12:24.866Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db08-db09/db09-sql-cao-zuo-fu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db08-db09/db09-sql-cao-zuo-fu.html","excerpt":"","text":"比较操作符（&#x3D;）等于where salary&#x3D;20000返回true或false &lt;&gt;,!&#x3D; 不等于where salary &lt;&gt; 20000 &lt;,&gt; 小于和大于，小于等于和大于等于where salary &gt;&#x3D; 20000 逻辑操作符IS NULLwhere salary is nullwhere salary is not null BETWEEN … AND …where salary between 2000 and 3000 INwhere salary in (2000,3000,4000)使用操作符IN可以得到与操作符OR一样的结果，但它的速度更快,OR和IN的比较 禁用OR，使用in 有索引时执行效率基本上相当 无索引时OR的效率明显低于IN，且条件越多差距越大 LIKE操作符LIKE利用通配符把一个值与类似的值进行比较，通配符有百分号(%）和下划线(）两个百分号代表0个、1个或多个字符，下划线代表1个数字或字符，百分号和下划线可以组合使用:where name&#x3D;’张%’可查询到以’张’开头的数据，如张三、张三三where name&#x3D;’张‘可查询到以’张’开头的数据且此数据的长度必须为2，如张三 EXISTSEXISTS操作符用于搜索指定表里是否存在满足特定条件的记录。WHERE EXISTS(SELECT emp_id FROM sales.employee_tbl WHERE employee_id &#x3D; ‘123456’)返回true或false 连接操作符ANDwhere salary &gt;&#x3D;20 and salary &lt;&#x3D;50salary大于等于20的同时，salary还要小于等于50 ORwhere salary &#x3D;20 or salary&#x3D;30salary等于20，或者，salary等于30 and or 组合使用从左向右解析where cost&gt;5 and (id&#x3D;5 or id&#x3D;6)匹配cost&gt;5，且（id等于5或者6）where cost&gt;5 and id&#x3D;5 or id&#x3D;6匹配(cost&gt;5，且id&#x3D;5)，或id&#x3D;6 取反操作符 not between not in not like is not null","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB07_管理数据库事务","slug":"数据库/MySQL/大数据学习/DB06&DB07/DB07_管理数据库事务","date":"2022-12-21T04:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db06-db07/db07-guan-li-shu-ju-ku-shi-wu.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db06-db07/db07-guan-li-shu-ju-ku-shi-wu.html","excerpt":"","text":"管理数据库事务什么是事务？数据库几乎是所有系统的核心模块，它将数据有条理地保存在储存介质(磁盘)中，并在逻辑上，将数据以结构化的形态呈现给用户。支持数据的增、删、改.查，并在过程中保障数据的正确且可靠。要做到这点并非易事，常见的例子就是银行转账，A账户给B账户转账一个亿(T1)，买一块地盖房子。在这种交易的过程中，有几个问题值得思考: 如何同时保证上述交易中，A账户总金额减少一个亿,B账户总金额增加一个亿? A账户如果同时在和C账户交易(T2)，如何让这两笔交易互不影响? 如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中? 如何在支持大量交易的同时，保证数据的合法性(没有钱凭空产生或消失)?要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是事务诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性: 原子性(Atomicity):事务要么全部完成，要么全部取消。如果事务崩溃，状态回到事务之前(事务回滚)。 隔离性(lsolation):如果2个事务T1和T2同时运行，最后不管T1和T2谁先结束，事务T1和T2最终的结果是相同的。 持久性(Durability):一旦事务提交，不管发生什么(崩溃或者出错），数据要保存在数据库中。 一致性(Consistency)∶只有合法的数据（依照关系约束和函数约束)才能写入数据库。 数据库事务特性事务具有四大特性，即原子性(Atomicity)、一致性(Consistency)、隔离性（lsolation)和持久性(Durability)，这四个特性通常简称为ACID。事务的ACID原则保证了一个事务或者成功提交，或者失败回滚，二者必居其一。因此，它对事务的修改具有可恢复性。即当事务失败时，它对数据的修改都会恢复到该事务执行前的状态。 原子性事务是一个完整的操作事务的各元素是不可分的(原子的)，事务中的所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。事务的原子性确保不管交易过程中发生了什么意外状况（服务器崩溃、网络中断等)，不能出现A账户少了一个亿.但B账户没到帐，或者A账户没变，但B账户却凭空收到一个亿(数据不一致)。A和B账户的金额变动要么同时成功，要么同时失败(保持原状).一致性当事务完成时，数据必须处于一致状态。也就是说，在事务开始之前，数据库中存储的数据处于一致状态。在正在进行的事务中.数据可能处于不一致的状态，如数据可能有部分被修改。然而,当事务成功完成时，数据必须再次回到已知的一致状态。通过事务对数据所做的修改不能损坏数据，或者说事务不能使数据存储处于不稳定的状态。确保钱不会在系统内煲空产生或消失,依赖原子性和隔离性隔离性对数据进行修改的所有并发事务是彼此隔离的,这表明事务必须是独立的,它不应以任何方式依赖于或影响其他事务。修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。如果A在转账1亿给B(T1)，同时C又在转账3亿给A_(T2)，不管T1和T2谁先执行完毕,最终结果必须是A账户增加2亿,而不是3亿，B增加1亿,C减少3亿。持久性事务的持久性指不管系统是否发生了故源,事务处理的结果都是永久的。—个事务成功完成之后，它对数据库所作的改变是永久性的,即使系统出现故障也是如此。也就是说,一旦事务被提交，事务对数据所做的任何变动都会被永久地保留在数据库中事务的持久性确保确保如果T1刚刚提交，数据库就发生崩溃,T1执行的结果依然会保持在数据库中. 控制事务事务控制是对关系型数据库管理系统(RDBMS)里可能发生的各种事务的管理能力。在谈及事务时,我们是INSERT、UPDATE和DELETE等DML命令。事务的启动或执行在各个数据库实现中是不同的，详细情况请查看具体实现的文档。控制事务的命令有COMMIT、ROLLBACK、SAVEPOINT。什么可以使用事务?事务控制命令只与DML命令INSERT、UPDATE和DELETE配合使用，比如我们不会在创建表之后使用COMMIT语句，因为当表被创建之后，它会自动被提交给数据库。也不能使用ROLLBACK语句来恢复被撤销的表。此外，还有其他类似的语句，也是不能被撤销的，例如TRUNCATE语句。当事务完成之后，事务信息被保存在数据库里的指定区域或临时回退区域。所有的修改都被保存到这个临时回退区域，直到事务控制命令出现。当事务控制命令出现时，所做的修改要么被保存到数据库，要么被放弃，然后临时回退区域被清空 COMMITCOMMIT命令用于把事务所做的修改保存到数据库，即把上一个COMMIT或ROLLBACK命令之后的DML操作都保存到数据库。这个命令的语法是:COMMIT [work];关键字COMMIT是语法中唯一不可缺少的部分，其后是可选的用于终止语句的字符或命令，具体内容取决于不同的实现。关键字work是个可选项，其唯一作用是让命令对用户更加友好。 时间 Session#1 Session#2 T1 BEGIN;–开始一个事务 T2 SELEECT * FROM sales.products_tmp01; T3 DELETE FROM sales.products_tmp01; T4 SELECT SHOW(); T5 SELECT now(); T6 SELECT * FROM sales.products_tmp01; T7 COMMIT;–提交一个事务 T8 SELECT now(); T9 SELECT now(); T10 SELECT * FROM sales.products_tmp01; 小结介绍事务定义、事务特点以及事务控制命令COMMIT、ROLLBACK，展示了事务管理的初步概念.COMMIT用于把事务保存到数据库，ROLLBACK用于撤销已经执行的事务。在运行大规模事务操作时，应该经常使用COMMIT和ROLLBACK命令","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB06_操作数据","slug":"数据库/MySQL/大数据学习/DB06&DB07/DB06_操作数据","date":"2022-12-21T04:00:00.000Z","updated":"2024-06-01T14:12:24.862Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db06-db07/db06-cao-zuo-shu-ju.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db06-db07/db06-cao-zuo-shu-ju.html","excerpt":"","text":"操作数据概述数据操作语言使数据库用户能够对关系型数据库里的数据进行修改，包括用新数据填充表、更新现有表里的数据、删除表里的数据。利用DML命令还可以进行简单的数据库查询。SQL里3个基本的DML命令是:insert、update、deleteselect对应的是dql 用新数据填充表用数据填充表就是把新数据输入到表的过程，无论是使用单个命令的手工过程，还是使用程序或其他相关软件的批处理过程。手工数据填充是指通过键盘输入数据，自动填充通常是从外部数据源(比如其他数据库或一个平面文件)获得数据，再把得到的数据加载到数据库。在用数据填充表时，有很多因素会影响什么数据以及多少数据可以输入到表里。主要因素包括 现有的表约束 表的物理尺寸 列的数据类型 列的长度和其他完整性约束(比如主键和外键) delete VS truncateTRUNCATE TABLE语句 删除表中所有的数据 释放表的存储空间 TRUNCATE语句不能回滚，而使用DELETE语句删除数据，可以回滚MySQL默认自动提交，如果需要回滚数据，需要保证在DML前，进行设置SET AUTOCOMMIT &#x3D; FALSE SET AUTOCOMMIT =FALSE;DELETE FROM hr. departments_tmp;#TRUNCATE TABLE hr.departments_tr;SELECT * FROM hr. departments_tmp;ROLLBACK;# TCL操作SELECT * FROM hr. departments_tmp; 阿里开发规范:【参考】TRUNCATE TABLE比 DELETE速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。说明: TRUNCATE TABLE 在功能上与不带WHERE子句的 DELETE语句相同。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB05_数据模型抽象层次","slug":"数据库/MySQL/大数据学习/DB03&DB04&DB05/DB05_规范化过程","date":"2022-12-20T12:40:00.000Z","updated":"2024-06-01T14:12:24.861Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db03-db04-db05/db05-gui-fan-hua-guo-cheng.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db03-db04-db05/db05-gui-fan-hua-guo-cheng.html","excerpt":"","text":"数据模型抽象层次概念模型（CDM）概念模型(Concept Data Model，CDM)是一种面向用户、面向客观世界的模型，主要用来描述世界的概念化结构按用户的观点来对数据和信息建模用于组织信息世界的概念，表现从现实世界中抽象出来的事物以及它们之间的联系这类模型强调其语义表达能力，概念简单、清晰，易于用户理解如如E-R模型 逻辑数据模型（LDM）逻辑数据模型(Logicad Data Model)是利用图形方式，通过数据和关系反映业务的一个过程定义需要追踪和管理的各种实体、属性和关系是进行数据管理、分析和交流的重要手段是IT和业务人员沟通的桥梁。 概念模型（PDM）物理数据模型，是概念数据模型和逻辑数据模型在计算机中的具体表示，真正实现数据在数据库中的存放。其主要的工作是根据逻辑数据模型中的实体、属性、联系转换成对应的物理模型中的元素，包括定义所有的表和列，定义外键以维持表之间的联系等 数据库逻辑设计任何数据库设计都要考虑到终端用户。数据库逻辑设计，也被称为逻辑建模，是把数据安排到逻辑的、有组织的对象组，以便于维护的过程。数据库的逻辑设计应该减少数据重复，甚至是完全消除这种现象。毕竟，为什么要把数据存储两遍呢?另外，数据库逻辑设计应该努力让数据库易于维护和更新，同时也要保持数据库里的命名规范与逻辑。 终端用户的需求在设计数据库时，终端用户的需求应该是最重要的考虑因素，在设计时要考虑的与用户相关的因素包括:数据库里应该保存什么数据? 用户如何访问数据库?用户需要什么权限?数据库里的数据如何分组?哪些数据最经常被访问?全部数据与数据库如何关联?采取什么措施保证数据的正确性?采取什么措施减少数据冗余?采取什么措施让负责维护数据的用户更易于使用数据库? 数据冗余考虑数据应该没有冗余，这意味着重复的数据应该保持到最少,其原因有很多。举例来说，把雇员的家庭住址保存到多个表里就没有意义。重复数据会占据额外的存储空间，而且经常会产生混乱比如员工的地址在一个表里的内容与在另一个表里的内容不相符时，哪一个是正确的呢?能不能找到文档资料来确定雇员当前的地址?数据管理已经很困难了，冗余数据会导致灾难。减少冗余数据还能简化数据库的更新操作。如果只有一个表保存了雇员的地址，那么在用新地址更新了这个表之后，我们就可以确保所有人都会看到这个更新的数据。 非规范化数据库在没有经过规范化的数据库里，有些数据可能会出现在多个不同的表里，而且没有什么明显的原因。这样对安全、磁盘利用、查询速度、数据库更新都不好，特别是可能产生数据完整性的问题。在规范化之前，数据库里的数据并没有从逻辑上被分解到较小的、更易于管理的表里。 什么是规范化规范化是去除数据库里冗余数据的过程，在设计和重新设计数据库时使用。它是一组减少数据冗余来优化数据库的指导方针，具体的方针被称为数据库范式。数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(INSERT)、删除（DELETE)和更新(UPDATE)操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。 范式 Normal Format，是一种离散数学中的知识，解决数据的存储与优化的问题。保存数据之后，凡是能够通过关系寻找出来的数据，不再重复存储，终极目标是为了减少数据的冗余。 范式是一种分层结构的规范，分为六层(1NF、2NF、3NF.…6NF):每一次层都比上一层更加严格。 关系型数据库有空间浪费，需要致力于节省存储空间。在设计数据库的时候，需要范式要求来进行数据库设计。 但是数据库不单是要解决空间问题，还要保证效率问题，所以数据库的设计又不可能完全按照范式的要求实现。一般情况下，只有前三种范式需要满足。范式在数据库的设计当中是有指导意义，但不是强制规范。 第一范式所谓第一范式（1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式 （1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 第一范式要求字段的数据具有原子性，不可再分。 第二范式如果关系模式R为第一范式，并且R中每一个非主属性完全函数依赖于R的某个候选键，则称为第二范式模式。第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 第二范式就是要解决表设计不允许出现部分依赖，要满足第二范式，必须满足第一范式 第三范式一张表中的所有字段都应该直接依赖主键。如果表中存在一个字段，并不直接依赖主键，而是依赖某个非主键字段，最终实现依赖主键，称之为传递依赖关系。第三范式就是要解决传递依赖的问题要满足第三范式，必须满足第二范式。所谓传递依赖，指的是如果存在”A→B→C”的决定关系，则C传递依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系: 关键字段→非关键字段X→非关键字段Y","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB01_MySQL for Windows安装","slug":"数据库/MySQL/大数据学习/DB01&DB02/DB01_MySQL for Windows安装","date":"2022-12-19T12:00:00.000Z","updated":"2024-06-01T14:12:24.859Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db01-db02/db01-mysql-for-windows-an-zhuang.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db01-db02/db01-mysql-for-windows-an-zhuang.html","excerpt":"","text":"MySQL for Windows安装下载从mysql这里下载相应版本这里我也提供我自己用的mysql版本链接：https://pan.baidu.com/s/1S4j2j5AqBlPM-IL1I5lEUg?pwd=8ym5提取码：8ym5 mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.13 |+-----------+1 row in set (0.00 sec)# 我用的是8.0.13 安装mysql安装过程 配置安装完成后，编辑my.ini文件【我的地址是在C:\\ProgramData\\MySQL\\MySQL Server 8.0 注意：ProgramData是一个隐藏文件夹，需要打开查看隐藏文件夹的设置】 [mysqld]# 永久更改时区，解决连接mysql时timeout的情况default-time_zone = &#x27;+8:00&#x27; # 暂时更改时区，重启后失效set global time_zone = &#x27;+8:00&#x27;; # 查看时区是否设置成功show variables like “%time_zone%”; mysql命令# mysql服务的启动和停止net stop mysqlnet start mysql# 登录数据库mysql -uroot -p# 输入密码后登陆成功# 修改用户密码alter user root@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;指定密码&#x27;;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"DB02_sql概念综述","slug":"数据库/MySQL/大数据学习/DB01&DB02/DB02_sql概念综述-常见数据库类型","date":"2022-12-19T12:00:00.000Z","updated":"2024-06-01T14:12:24.860Z","comments":true,"path":"/shu-ju-ku/mysql/da-shu-ju-xue-xi/db01-db02/db02-sql-gai-nian-zong-shu-chang-jian-shu-ju-ku-lei-xing.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/da-shu-ju-xue-xi/db01-db02/db02-sql-gai-nian-zong-shu-chang-jian-shu-ju-ku-lei-xing.html","excerpt":"","text":"sql概念综述什么是数据库？&quot;按照数据结构来组织、存储和管理数据的仓库&quot;。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。简单来说，数据库就是数据集合。可以把数据看成这样一种有组织的机制:它能够存储信息，用户能够以有效且高效的方式检索其中的信息。 数据查询语言select 数据操作语言insert、update、merge，delete 数据定义语言create、drop、alter 事务控制语言commit、rollback、checkpoint、set、transaction 数据控制语言grant、revoke","categories":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"java集合","slug":"编程语言/Java/学习/基础/002_集合","date":"2022-12-16T16:00:00.000Z","updated":"2024-06-01T14:12:24.909Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/002-ji-he.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/002-ji-he.html","excerpt":"","text":"Java集合接口继承关系和实现 集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。 Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据。 Map：是映射表的基础接口。 集合框架： Collection List ArrayList:排列有序，可重复、底层使用数组、查询快增删慢、线程不安全、当容量不够时-ArrayList是当前容量*1.5+1 Vector:排列有序，可重复、底层使用数组、查询快增删慢、线程安全但效率低、当容量不够时-Vector默认扩展一倍容量 LinkedList:排列有序，可重复、底层使用双向循环链表数据结构、查询慢增删快、线程不安全 Set HashSet:排列无序，不可重复、底层使用Hash实现、存取速度快、内部是HashMap TreeSet:排列无序，不可重复、底层使用二叉树实现、排列存储、内部是TreeMap的SortedSet LinkedHashSet:采用Hash表存储，并用双向链表记录插入顺序、内部是LinkedHashMap Queue:在两端出入的List，所以也可以用数组和链表来实现 Map HashMap:键不可重复，值可重复、底层哈希表、线程不安全、允许键null值也可以为null HashTable:键不可重复，值可重复、底层哈希表、线程安全、键值都不允许为null TreeMap:键不可重复，值可重复、底层二叉树 List Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类分别是 ArrayList、Vector 和 LinkedList ArrayList（数组） ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector（数组实现、线程同步） Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 LinkedList（链表） LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 Set Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。 HashSet（Hash表） 哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equals 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 TreeSet（二叉树） TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet（HashSet+LinkedHashMap） 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 MapHashMap（数组+链表+红黑树） HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。 ConcurrentHashMap Java7实现：13&#x2F;04&#x2F;2018 Page 50 of 283大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFact Java8实现：Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 Segment段 ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表部分或一段的意思，所以很多地方都会将其描述为分段锁。注意，行文中，槽来代表一个segment。 线程安全（Segment继承ReentrantLock加锁） 简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 并行度（默认16） concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 Java8实现（引入了红黑树） Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 HashTable（线程安全） Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 TreeMap（可排序） TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 LinkHashMap（记录插入的顺序） LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"jvm","slug":"编程语言/Java/学习/基础/001_JVM","date":"2022-12-16T16:00:00.000Z","updated":"2024-06-01T14:12:24.908Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/001-jvm.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/001-jvm.html","excerpt":"","text":"JVM 加油哦！不要过度焦虑 ヾ(◍°∇°◍)ﾉﾞ JVM线程 这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。label Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的CPU上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源Hotspot JVM 后台运行的系统线程主要有下面几个： 虚拟机线程（VM thread） 周期性任务线程 GC线程 编译器线程 信号分发线程 虚拟机线程：这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the-world垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased locking）解除。周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。GC线程：这些线程支持 JVM 中不同的垃圾回收活动。编译器线程：这些线程在运行时将字节码动态编译成本地平台相关的机器码。信号分发线程：这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。 JVM内存区域 JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【Java堆、方法区】、直接内存。label 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁(在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用: 在 JDK 1.4 引入的label NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作, 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能 程序计数器（线程私有） 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器 ，每条线程都要有一个独立的程序计数器，这类内存也称为线程私有的内存。正在在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域 虚拟机栈（线程私有） 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁 ————无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。 本地方法区（线程私有） 本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 堆（线程共享） 是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。 方法区&#x2F;永久代（线程共享） 即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小）运行时常量池 （Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。 JVM运行时内存 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。新生代：是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 新生代 Eden区Java 新对象的出生地 （如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 ServivorFrom区上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 ServivorTo区保留了一次 MinorGC 过程中的幸存者。MinorGC的过程（复制–清空–互换）MinorGC 采用复制算法。 eden、servicorFrom 复制到 ServicorTo，年龄+1首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年代区） 清空 eden、servicorFrom然后，清空 Eden 和 ServicorFrom 中的对 ServicorTo 和 ServicorFrom 互换最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。 老年代 主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。 永久代 指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理 。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。在 Java8 中，永久代已经被移除，被一个称为元数据区（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。 垃圾回收算法 引用计数法在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。（存在A引用B，B引用A，即AB互相引用，导致都无法被回收的现象） 可达性分析法为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收， 标记清除算法最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重 ，后续可能发生大对象不能找到可利用空间的问题。 复制算法为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，复制 算法的效率会大大降低。 标记整理算法结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。 在新生代中采用复制算法：每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代中采用标记整理算法：因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用标记—清理或标记—整理算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。 引用类型 强引用在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用 。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。 软引用软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 弱引用弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 虚引用虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。 GC分代收集算法 与 分区收集算法 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured&#x2F;Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。分区收集算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是 可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。 GC垃圾收集器 Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器JDK1.6 中 Sun HotSot 虚拟机的垃圾收集器如下： Serial 垃圾收集器（单线程、复制算法） ParNew 垃圾收集器（Serial+多线程） Parallel Scavenge 收集器（多线程复制算法、高效） Serial Old 收集器（单线程标记整理算法） Parallel Old 收集器（多线程标记整理算法） CMS 收集器（多线程标记清除算法） G1收集器 Serial 垃圾收集器（单线程、复制算法） Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。 ParNew 垃圾收集器（Serial+多线程） ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。 Parallel Scavenge 收集器（多线程复制算法、高效） Parallel Scavenge 收集器是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)）， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的重要区别。 Serial Old 收集器（单线程标记整理算法） Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。在 Server 模式下，主要有两个用途： 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。 Parallel Old 收集器（多线程标记整理算法） Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。 CMS 收集器（多线程标记清除算法） Concurrent mark sweep(CMS)收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段 初始标记：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作。 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线 并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。 由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 G1 收集器 Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是： 基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域 。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。 Java IO&#x2F;NIO 阻塞IO模型 非阻塞IO模型 多路复用IO模型 信号驱动IO模型 异步IO模型 IO模型 阻塞IO模型最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data &#x3D; socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。 非阻塞IO模型当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下。 while (true) &#123; data = socket.read(); if (data != error) &#123; // 处理数据 break; &#125; &#125; 但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。 多路复用IO模型多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 信号驱动IO模型在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 异步IO模型异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要知道实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO Java IO包 NIO 主要有三大核心部分：Channel(通道)、Buffer(缓冲区)、 Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 Channel首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。NIO 中的 Channel 的主要实现有： FileChannel DatagramChannel SocketChannel ServerSocketChannel 这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。 BufferBuffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer SelectorSelector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。 NIO的缓冲区Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 NIO的非阻塞IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 Java类加载机制 JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。 加载加载是类加载过程中的一个阶段（请勿混淆这两个概念） ，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： public static int v = 8080; 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器client方法之中。但是注意如果声明为： public static final int v = 8080; 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080. 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的 CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info等类型的常量。 符号引用符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。类构造器：初始化阶段是执行类构造器client方法的过程。client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成client()方法。注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 类加载器：虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器。 启动类加载器(Bootstrap ClassLoader) 扩展类加载器(Extension ClassLoader) 应用程序类加载器(Application ClassLoader) 双亲委派机制：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象 。OSGI（动态模型系统）：OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。 动态改变构造OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 模块化编程与热插拔OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"spring原理","slug":"编程语言/Java/学习/基础/004_Spring原理","date":"2022-12-16T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/004-spring-yuan-li.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/004-spring-yuan-li.html","excerpt":"","text":"Spring原理Spring特点 它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。 轻量级控制反转面向切面容器框架集合 Spring核心组件 Spring常用模块 Spring主要包 Spring常用注解 bean 注入与装配的的方式有很多种，可以通过 xml、get set 方式，、造函数或者注解等。简单易用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式 Spring第三方结合 Spring IOC原理概念 Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。 Spring容器高层视图 Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现。 IOC容器实现BeanFactory-框架基础设施 BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory BeanDefinitionRegistry 注册表：Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法 BeanFactory 顶层接口：位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展 ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一 Bean 等方法 HierarchicalBeanFactory 父子级联：父子级联 IOC 容器的接口，子容器可以通过接口方法访问父容器； 通过HierarchicalBeanFactory 接口， Spring 的 IOC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean ConfigurableBeanFactory：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法 AutowireCapableBeanFactory 自动装配：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法 SingletonBeanRegistry 运行期间注册单例 Bean：定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean 来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以beanName 为键保存在这个 HashMap中 依赖日志框架：在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错 ApplicationContext 面向开发应用 ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能 ClassPathXmlApplicationContext：默认从类路径加载配置文件 FileSystemXmlApplicationContext：默认从文件系统中装载配置文件 ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。 MessageSource：为应用提供 i18n 国际化消息访问的功能； ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。 LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现，ApplicationContext 会将 start&#x2F;stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用上下文 WebApplication 体系架构 WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文 SpringBean作用域 Spring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、request、session 和 global session，5 种作用域说明如下： singleton：单例模式（多线程下不安全）singleton：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式.配置为： &lt;bean id=&quot;userDao&quot; class=&quot;com.ioc.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt; prototype:原型模式每次使用时创建：prototype:原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。 Request：一次 request 一个实例：request：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean实例也将会被销毁。 &lt;bean id=&quot;loginAction&quot; class=&quot;com.cnblogs.Login&quot; scope=&quot;request&quot;/&gt; sessionsession：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。 &lt;bean id=&quot;userPreference&quot; class=&quot;com.ioc.UserPreference&quot; scope=&quot;session&quot;/&gt; global Sessionglobal Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。 SpringBean生命周期 实例化实例化一个 Bean，也就是我们常说的 new。 IOC 依赖注入按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。 setBeanName 实现如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值 BeanFactoryAware 实现如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory，setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。 ApplicationContextAware 实现如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法） postProcessBeforeInitialization 接口实现-初始化预处理如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。 init-method如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。 postProcessAfterInitialization如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean 是一个 Singleton 的，所以一般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton。 Destroy 过期自动清理阶段当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法； destroy-method 自配置清理 最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。 ![Bean在Spring Bean应用上下文中的生命周期](https://raw.githubusercontent.com/IsUnderAchiever/markdown-img/master/PicGo01/202301201942515.png) （生命周期）11. bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。 Spring依赖注入四种方式 构造器注入 /*带参数，方便利用构造器进行注入*/ public CatDaoImpl(String message)&#123; this. message = message; &#125; &lt;bean id=&quot;CatDaoImpl&quot; class=&quot;com.CatDaoImpl&quot;&gt; &lt;constructor-arg value=&quot; message &quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; setter 方法注入 public class Id &#123; private int id; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; &lt;bean id=&quot;id&quot; class=&quot;com.id &quot;&gt; &lt;property name=&quot;id&quot; value=&quot;123&quot;/&gt; &lt;/bean&gt; 静态工厂注入静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所有对象，我们不能直接通过工程类.静态方法()来获取对象，而是依然通过 spring 注入的形式获取 public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125; &#125; public class SpringAction &#123; private FactoryDao staticFactoryDao; //注入对象 //注入对象的 set 方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125; &#125; //factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法 &lt;bean name=&quot;springAction&quot; class=&quot; SpringAction&quot; &gt; &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot; /&gt; &lt;/bean&gt; &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 实例工厂实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法： public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125; &#125; public class SpringAction &#123; private FactoryDao factoryDao; //注入对象 public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125; &#125; &lt;bean name=&quot;springAction&quot; class=&quot;SpringAction&quot;&gt; &lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name=&quot;daoFactory&quot; class=&quot;com.DaoFactory&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 5种不同方式的自动装配 Spring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。 no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。 byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。 constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式。 Spring AOP原理概念 横切的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为Aspect，即切面。所谓切面，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用横切技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。AOP 主要应用场景有： Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 AOP核心概念 1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。4、切入点（pointcut）：对连接点进行拦截的定义5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。6、目标对象：代理的目标对象7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 AOP两种代理方式 Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理JDK 动态接口代理JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象CGLib 动态代理CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以在运行期动态生成新的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。 实现原理@Aspect public class TransactionDemo &#123; @Pointcut(value=&quot;execution(* com.example.core.service.*.*.*(..))&quot;) public void point()&#123; &#125; @Before(value=&quot;point()&quot;) public void before()&#123; System.out.println(&quot;transaction begin&quot;); &#125; @AfterReturning(value = &quot;point()&quot;) public void after()&#123; System.out.println(&quot;transaction commit&quot;); &#125; @Around(&quot;point()&quot;) public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;transaction begin&quot;); joinPoint.proceed(); System.out.println(&quot;transaction commit&quot;); &#125; &#125; SpringMVC原理 Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。 MVC流程 Http 请求到 DispatcherServlet 客户端请求提交到 DispatcherServlet HandlerMapping 寻找处理器 由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller 调用处理器 Controller DispatcherServlet 将请求提交到 Controller。 Controller 调用业务逻辑处理后，返回 ModelAndView 调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。 DispatcherServlet 查询 ModelAndView 处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 指定的视图。 ModelAndView 反馈浏览器 HTTP Http 响应：视图负责将结果显示到客户端。 MVC常用注解 @Controller @RestController @Component @Repository @Service @ResponseBody @RequestMapping @Autowired @PathVariable @RequestParam @RequestHeadler 作用请查看上面 Spring常用注解 图解 SpringBoot原理 Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。其特点如下： 创建独立的 Spring 应用程序 嵌入的 Tomcat，无需部署 WAR 文件 简化 Maven 配置 自动配置 Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对 XML 没有要求配置 JPA原理事务 事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily)。 本地事务 紧密依赖于底层资源管理器(例如数据库连接)，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下： public void transferAccount() &#123; Connection conn = null; Statement stmt = null; try&#123; conn = getDataSource().getConnection(); // 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交 conn.setAutoCommit(false); stmt = conn.createStatement(); // 将 A 账户中的金额减少 500 stmt.execute(&quot;update t_account set amount = amount - 500 where account_id = &#x27;A&#x27;&quot;); // 将 B 账户中的金额增加 500 stmt.execute(&quot;update t_account set amount = amount + 500 where account_id = &#x27;B&#x27;&quot;); // 提交事务 conn.commit(); // 事务提交：转账的两步操作同时成功 &#125; catch(SQLException sqle)&#123; // 发生异常，回滚在本事务中的操做 conn.rollback(); // 事务回滚：转账的两步操作完全撤销 stmt.close(); conn.close(); &#125; &#125; 分布式事务 Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。 public void transferAccount() &#123; UserTransaction userTx = null; Connection connA = null; Statement stmtA = null; Connection connB = null; Statement stmtB = null; try&#123; // 获得 Transaction 管理对象 userTx = (UserTransaction)getContext().lookup(&quot;java:comp/UserTransaction&quot;); connA = getDataSourceA().getConnection();// 从数据库 A 中取得数据库连接 connB = getDataSourceB().getConnection();// 从数据库 B 中取得数据库连接 userTx.begin(); // 启动事务 stmtA = connA.createStatement();// 将 A 账户中的金额减少 500 stmtA.execute(&quot;update t_account set amount = amount - 500 where account_id = &#x27;A&#x27;&quot;); // 将 B 账户中的金额增加 500 stmtB = connB.createStatement(); stmtB.execute(&quot;update t_account set amount = amount + 500 where account_id = &#x27;B&#x27;&quot;); userTx.commit();// 提交事务 // 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新） &#125; catch(SQLException sqle)&#123; // 发生异常，回滚在本事务中的操纵 userTx.rollback();// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销 &#125; catch(Exception ne)&#123; &#125; &#125; 两阶段提交 两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：第一阶段：准备阶段；第二阶段：提交阶段。1 准备阶段事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种万事俱备，只欠东风的状态。2 提交阶段如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。 MyBatis缓存 Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession 是可以共享的。 MyBatis一级缓存原理（sqlsession级别） 第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。key：MapperID+offset+limit+Sql+所有的入参value：用户信息同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存 二级缓存原理（mapper级别） 二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。具体使用需要配置： Mybatis 全局配置中启用二级缓存配置 在对应的 Mapper.xml 中配置 cache 节点 在对应的 select 查询节点中添加 useCache&#x3D;true","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java基础","slug":"编程语言/Java/学习/基础/005_Java基础","date":"2022-12-16T16:00:00.000Z","updated":"2024-06-01T14:12:24.913Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/005-java-ji-chu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/005-java-ji-chu.html","excerpt":"","text":"Java基础Java异常分类及处理概念 如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。 异常分类 Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 ExceptionError Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。Exception（RuntimeException、CheckedException） Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是CheckedException。RuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常CheckedException，如 I&#x2F;O 错误导致的 IOException、SQLException。 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面： 试图在文件尾部读取数据 试图打开一个错误格式的 URL 试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在 异常的处理方式 遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 public static void main(String[] args) &#123; String s = &quot;abc&quot;; if(s.equals(&quot;abc&quot;)) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; int div(int a,int b) throws Exception&#123; return a/b; &#125; try catch 捕获异常针对性处理方式 Throw 和 throws 的区别： 位置不同： throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。功能不同： throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处处理 Java反射动态语言 动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。 反射机制概念（运行状态中知道类所有的属性和方法） 在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。 反射的应用场合 编译时类型和运行时类型在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定。如： Person p=new Student(); 其中编译时类型为 Person，运行时类型为 Student。编译时类型无法获取具体方法程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。 Java 反射 API 反射 API 用来生成 JVM 中的类、接口或者对象的信息 Class 类：反射的核心类，可以获取类的属性，方法等信息。 Field 类：Java.lang.reflect 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 Method 类： Java.lang.reflect 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 Constructor 类： Java.lang.reflect 包中的类，表示类的构造方法。 反射使用步骤（获取 Class 对象、调用对象方法） 获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。 调用 Class 类中的方法，既就是反射的使用阶段。 使用反射 API 来操作这些信息。 获取 Class 对象的 3 种方法 调用某个对象的 getClass()方法 // 调用某个对象的 getClass()方法 Person p=new Person(); Class clazz=p.getClass(); 调用某个类的 class 属性来获取该类对应的 Class 对象 // 调用某个类的 class 属性来获取该类对应的 Class 对象 Class clazz=Person.class; 使用 Class 类中的 forName()静态方法(最安全&#x2F;性能最好) (最常用) // 使用 Class 类中的 forName()静态方法(最安全/性能最好) Class clazz=Class.forName(&quot;类的全路径&quot;); // (最常用) 当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性 //获取 Person 类的 Class 对象 Class clazz=Class.forName(&quot;reflection.Person&quot;); //获取 Person 类的所有方法信息 Method[] method=clazz.getDeclaredMethods(); for(Method m:method)&#123; System.out.println(m.toString()); &#125; //获取 Person 类的所有成员属性信息 Field[] field=clazz.getDeclaredFields(); for(Field f:field)&#123; System.out.println(f.toString()); &#125; //获取 Person 类的所有构造方法信息 Constructor[] constructor=clazz.getDeclaredConstructors(); for(Constructor c:constructor)&#123; System.out.println(c.toString()); &#125; 创建对象的两种方法 Class 对象的 newInstance() 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器 。调用 Constructor 对象的 newInstance() 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。//获取 Person 类的 Class 对象 Class clazz=Class.forName(&quot;reflection.Person&quot;); //使用.newInstane 方法创建对象 Person p=(Person) clazz.newInstance(); //获取构造方法并创建对象 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); //创建对象并设置属性 Person p1=(Person) c.newInstance(&quot;李四&quot;,&quot;男&quot;,20); Java注解概念 Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息 4 种标准元注解 元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。@Target 修饰的对象范围@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标@Retention 定义 被保留的时间长短Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由： SOURCE:在源文件中有效（即源文件保留） CLASS:在 class 文件中有效（即 class 保留） RUNTIME:在运行时有效（即运行时保留） @Documented 描述-javadoc@Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化@Inherited 阐述了某个被标注的类型是被继承的@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。 注解处理器 如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。 /*1：*** 定义注解 *** */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitProvider &#123; /**供应商编号*/ public int id() default -1; /*** 供应商名称*/ public String name() default &quot;&quot;; /** * 供应商地址*/ public String address() default &quot;&quot;; &#125; //2：注解使用 public class Apple &#123; @FruitProvider(id = 1, name = &quot;陕西红富士集团&quot;, address = &quot;陕西省西安市延安路&quot;) private String appleProvider; public void setAppleProvider(String appleProvider) &#123; this.appleProvider = appleProvider; &#125; public String getAppleProvider() &#123; return appleProvider; &#125; &#125; /* 3：*********** 注解处理器 ************** */ public class FruitInfoUtil &#123; public static void getFruitInfo(Class&lt;?&gt; clazz) &#123; String strFruitProvicer = &quot;供应商信息：&quot;; Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解 for (Field field : fields) &#123; // FruitProvider 的注解是否在 field上 if (field.isAnnotationPresent(FruitProvider.class)) &#123; FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class); //注解信息的处理地方 strFruitProvicer = &quot; 供应商编号：&quot; + fruitProvider.id() + &quot; 供应商名称：&quot; + fruitProvider.name() + &quot; 供应商地址：&quot;\\+ fruitProvider.address(); System.out.println(strFruitProvicer); &#125; &#125; &#125; &#125; public class FruitRun &#123; public static void main(String[] args) &#123; FruitInfoUtil.getFruitInfo(Apple.class); /***********输出结果***************/ // 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延 &#125; &#125; Java内部类 Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类 、成员内部类 、局部内部类 、匿名内部类 四种。 静态内部类 定义在类内部的静态类，就是静态内部类。 public class Out &#123; private static int a; private int b; public static class Inner &#123; public void print() &#123; Out out=new Out(); System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+out.b); &#125; &#125; public static void main(String[] args) &#123; Inner inner=new Inner(); inner.print(); &#125; &#125; 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示： Out.Inner inner = new Out.Inner(); inner.print(); Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。 成员内部类 定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。 public class Out &#123; private static int a; private int b; public class Inner &#123; public void print() &#123; System.out.println(a); System.out.println(b); &#125; &#125; &#125; 局部内部类 定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类 public class Out &#123; private static int a; private int b; public void test(final int c) &#123; final int d = 1; class Inner &#123; public void print() &#123; System.out.println(c); &#125; &#125; &#125; &#125; 匿名内部类 要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。 public abstract class Bird &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract int fly(); &#125; public class Test &#123; public void test1(Bird bird) &#123; System.out.println(bird.getName()+&quot;能够飞&quot;+bird.fly()+&quot;米&quot;); &#125; public static void main(String[] args) &#123; Out out=new Out(); out.test1(new Bird() &#123; @Override public int fly() &#123; // TODO Auto-generated method stub return 100; &#125; @Override public String getName() &#123; return &quot;大眼仔&quot;; &#125; &#125;); &#125; &#125; Java泛型 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。 泛型方法（） 你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 // 泛型方法 printArray public static &lt; E &gt; void printArray(E[] inputArray )&#123; for ( E element : inputArray )&#123; System.out.printf( &quot;%s &quot;, element ); &#125; &#125; 表示该通配符所代表的类型是 T 类型的子类。 表示该通配符所代表的类型是 T 类型的父类。 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; &#125; 类型通配符 ? 类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在逻辑上是List,List 等所有 List&lt;具体类型实参&gt;的父类。 类型擦除 Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List和 List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。 Java序列化(创建可复用的 Java 对象) 保存(持久化)对象及其状态到内存或者磁盘Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。序列化对象以字节数组保持-静态成员不保存使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的状态，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量序列化用户远程对象传输除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。Serializable 实现序列化在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化writeObject 和 readObject 自定义序列化策略在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略序列化 ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）序列化并不保存静态变量序列化子父类说明：要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。Transient 关键字阻止该变量被序列化到文件中 在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。（@Transient注解 同） 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 Java复制 将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象 直接赋值复制 直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化 public class Copy &#123; public static void main(String[] args) throws Exception &#123; Class clazz=Class.forName(&quot;com.example.domain.Person&quot;); Constructor c=clazz.getDeclaredConstructor(Integer.class,String.class,Integer.class); Person p1=(Person) c.newInstance(1,&quot;张三&quot;,1); Person p2=p1; System.out.println(String.format(&quot;p1:%s %np2:%s&quot;,ptoString(),ptoString())); psetName(&quot;李四&quot;); System.out.println(String.format(&quot;p1:%s %np2:%s&quot;,ptoString(),ptoString())); &#125; &#125; // p1:Person(id=1, name=张三, sex=2) // p2:Person(id=1, name=张三, sex=2) // p1:Person(id=1, name=李四, sex=2) // p2:Person(id=1, name=李四, sex=2) 浅复制（复制引用但不复制引用的对象） 创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。 class Resume implements Cloneable&#123; public Object clone() &#123; try &#123; return (Resume)super.clone(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; 深复制（复制对象和其应用对象） 深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。 class Student implements Cloneable &#123; String name; int age; Professor p; Student(String name, int age, Professor p) &#123; this.name = name; this.age = age; this.p = p; &#125; public Object clone() &#123; Student o = null; try &#123; o = (Student) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; System.out.println(e.toString()); &#125; o.p = (Professor) p.clone(); return o; &#125; &#125; 序列化（深 clone 中实现） 在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java多线程并发","slug":"编程语言/Java/学习/基础/003_Java多线程并发","date":"2022-12-16T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/ji-chu/003-java-duo-xian-cheng-bing-fa.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/ji-chu/003-java-duo-xian-cheng-bing-fa.html","excerpt":"","text":"Java多线程并发Java线程实现&#x2F;创建方式继承Thread类 Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。 public class MyThread extends Thread &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125; &#125; MyThread myThread1 = new MyThread(); myThreadstart(); 实现Runnable接口 如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。 public class MyThread extends OtherClass implements Runnable &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125; &#125; //启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例： MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); //事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用 target.run() public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 实现Callable接口 有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须实现 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。 //创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); for (int i = 0; i &lt; taskSize; i++) &#123; Callable c = new MyCallable(i + &quot; &quot;); // 执行任务并获取 Future 对象 Future f = pool.submit(c); list.add(f); &#125; // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) &#123; // 从 Future 对象上获取任务的返回值，并输出到控制台 System.out.println(&quot;res：&quot; + f.get().toString()); &#125; 基于线程池的方式 线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。 // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); while(true) &#123; threadPool.execute(new Runnable() &#123; // 提交多个线程任务，并执行 @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; is running ..&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; 4种线程池 Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。 newCachedThreadPool 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 newFixedThreadPool 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 newScheduledThreadPool 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 表头 表头 ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3); scheduledThreadPool.schedule(newRunnable()&#123; @Override public void run() &#123; System.out.println(&quot;延迟三秒&quot;); &#125; &#125;, 3, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123; @Override public void run() &#123; System.out.println(&quot;延迟 1 秒后每三秒执行一次&quot;); &#125; &#125;,1,3,TimeUnit.SECONDS); newSingleThreadExecutor Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。 线程生命周期（状态） 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直霸占着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。 新建状态（new） 当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值。 就绪状态（runnable） 当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。 运行状态（running） 如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。 阻塞状态（blocked） 阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 等待阻塞（o.wait-&gt;等待对列）运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。 同步阻塞(lock-&gt;锁池)运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。 其他阻塞(sleep&#x2F;join)运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。 线程死亡（dead） 线程会以下面三种方式结束，结束后就是死亡状态。正常结束：run()或 call()方法执行完成，线程正常结束。异常结束：线程抛出一个未捕获的 Exception 或 Error。调用 stop：直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。 终止线程的4种方式正常运行结束 程序运行结束，线程自动结束。 使用退出标志退出线程 一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。 使用一个变量来控制循环，例如：最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出，代码示例： public class ThreadSafe extends Thread &#123; public volatile boolean exit = false; public void run() &#123; while (!exit)&#123; //do something &#125; &#125; &#125; 定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile ，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。 interrupt方法结束线程 使用 interrupt()方法来中断线程有两种情况： 线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法 线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。public class ThreadSafe extends Thread &#123; public void run() &#123; while (!isInterrupted())&#123; //非阻塞过程中通过判断中断标志来退出 try&#123; Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出 &#125;catch(InterruptedException e)&#123; e.printStackTrace(); break;//捕获到异常之后，执行 break 跳出循环 &#125; &#125; &#125; &#125; stop方法终止线程（线程不安全） 程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制) ，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。 sleep与wait区别 对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。 sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。 在调用 sleep()方法的过程中，线程不会释放对象锁。 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 start与run区别 start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 在本质上run方法并没有实现多线程，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 Java后台线程 定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 在 Daemon 线程中产生的新线程也是 Daemon 的。 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。 Java锁乐观锁 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 ，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 悲观锁 悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 自旋锁 自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。自旋锁的优缺点自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；自旋锁时间阈值（1.6 引入了适应性自旋锁）自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs&#x2F;2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。自旋锁的开启JDK1.6 中-XX:+UseSpinning 开启；-XX:PreBlockSpin&#x3D;10 为自旋次数；JDK1.7 后，去掉此参数，由 jvm 控制； Synchronized同步锁 synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。synchronized 作用范围 作用于方法时，锁住的是对象的实例(this)； 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 Synchronized 核心组件 Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里； Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中； OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck； Owner：当前已经获取到所资源的线程被称为 Owner； !Owner：当前释放锁的线程。 Synchronized 实现 JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。 Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。 OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。 处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的） Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的 synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。 ReentranLock ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。Lock 接口的主要方法 void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。 getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10 hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法 hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 hasQueuedThreads()：是否有线程等待此锁 isFair()：该锁是否公平锁 isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true isLock()：此锁是否有任意线程占用 lockInterruptibly（）：如果当前线程未被中断，获取锁 tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁 非公平锁JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。公平锁公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。ReentrantLock 与 synchronized ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。 ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。 &#96;ReentrantLock 实现 public class MyService &#123; private Lock lock = new ReentrantLock(); //Lock lock=new ReentrantLock(true);//公平锁 //Lock lock=new ReentrantLock(false);//非公平锁 private Condition condition=lock.newCondition();//创建 Condition public void testMethod() &#123; try &#123; lock.lock();//lock 加锁 //1：wait 方法等待： //System.out.println(&quot;开始 wait&quot;); condition.await(); //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁 //:2：signal 方法唤醒 condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()+ (&quot; &quot; + (i + 1))); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally&#123; lock.unlock(); &#125; &#125; &#125; Condition 类和 Object 类锁方法 区别 Condition 类的 awiat 方法和 Object 类的 wait 方法等效 Condition 类的 signal 方法和 Object 类的 notify 方法等效 Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 tryLock 和 lock 和 lockInterruptibly 的区别 tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false lock 能获得锁就返回 true，不能的话一直等待获得锁 lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。 Semaphore信号量 Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池实现互斥锁（计数器为 1）我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制 ，这也叫二元信号量，表示两种互斥状态。&#96;代码实现 // 创建一个计数阈值为 5 的信号量对象 // 只能 5 个线程同时访问 Semaphore semp = new Semaphore(5); try &#123; // 申请许可 semp.acquire(); try &#123; // 业务逻辑 &#125; catch (Exception e) &#123; &#125; finally &#123; // 释放许可 semp.release(); &#125; &#125; catch (InterruptedException e) &#123; &#125; Semaphore 与 ReentrantLockSemaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能 ，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。 AtomicInteger 首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference将一个对象的所有操作转化成原子操作。我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。 可重入锁（递归锁） 本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。 公平锁与非公平锁 公平锁（Fair）加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得非公平锁（Nonfair）加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 ReadWriteLock读写锁 为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。读锁如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁写锁如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。 共享锁 和 独占锁 java 并发包提供的加锁模式分为独占锁和共享锁。独占锁独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读&#x2F;读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。共享锁共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。 重量级锁（Mutex Lock） Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为重量级锁。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了轻量级锁和偏向锁 轻量级锁 锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。锁升级随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。轻量级是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 偏向锁 Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。 分段锁 分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践。 锁优化 减少锁持有时间只用在有线程安全要求的程序上加锁减小锁粒度将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。锁分离最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。JDK 并发包，读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比LinkedBlockingQueue 从头部取出，从尾部放数据锁粗化通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。锁消除锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。 线程基本方法 线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。 线程等待（wait） 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。 线程睡眠（sleep） sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态。 线程让步（yield） yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。 线程中断（interrupt） 中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。 调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 Join等待其他线程终止 join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 为什么要用join()方法 很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。 System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;); Thread6 thread1 = new Thread6(); threadsetName(&quot;线程 B&quot;); threadjoin(); System.out.println(&quot;这时 thread1 执行完毕之后才能执行主线程&quot;); 线程唤醒（notify） Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 其他方法 sleep()：强迫一个线程睡眠Ｎ毫秒。 isAlive()： 判断一个线程是否存活。 join()： 等待线程终止。 activeCount()： 程序中活跃的线程数。 enumerate()： 枚举程序中的线程。 currentThread()： 得到当前线程。 isDaemon()： 一个线程是否为守护线程。 setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName()： 为线程设置一个名称。 wait()： 强迫一个线程等待。 notify()： 通知一个线程继续运行。 setPriority()： 设置一个线程的优先级。 getPriority():：获得一个线程的优先级。 线程上下文切换 巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一个 CPU 上执行变成了可能。 进程 （有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。 上下文 是指某一时间点 CPU 寄存器和程序计数器的内容。 寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。 程序计数器 是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。 PCB-“切换帧” 上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作切换桢（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。 上下文切换的活动 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。 引起线程上下文切换的原因 当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务； 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务； 用户代码挂起当前任务，让出 CPU 时间； 硬件中断； 同步锁 与 死锁同步锁 当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥 ，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 死锁 何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 线程池原理 线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。 线程复用 每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。 线程池组成 一般的线程池主要分为以下 4 个组成部分： 线程池管理器：用于创建并管理线程池 工作线程：线程池中的线程 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 任务队列：用于存放待处理的任务，提供一种缓冲机制Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。ThreadPoolExecutor 的构造方法如下： public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; corePoolSize：指定了线程池中的线程数量。 maximumPoolSize：指定了线程池中的最大线程数量。 keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。 unit：keepAliveTime 的单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程工厂，用于创建线程，一般用默认的即可。 handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 拒绝策略 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。JDK 内置的拒绝策略如下： AbortPolicy ： 直接抛出异常，阻止系统正常运行。 CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。 Java线程池工作过程 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 当调用 execute() 方法添加一个任务时，线程池会做如下判断：a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 阻塞队列原理 阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况： 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队。 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒 阻塞队列的主要方法 抛出异常：抛出一个异常； 特殊值：返回一个特殊值（null 或 false,视情况而定） 阻塞：在成功操作之前，一直阻塞线程 超时：放弃前只在最大的时间内阻塞 插入操作：1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要)4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败 public void put(E paramE) throws InterruptedException &#123; checkNotNull(paramE); ReentrantLock localReentrantLock = this.lock; localReentrantLock.lockInterruptibly(); try &#123; while (this.count == this.items.length) this.notFull.await();//如果队列满了，则线程阻塞等待 enqueue(paramE); localReentrantLock.unlock(); &#125; finally &#123; localReentrantLock.unlock(); &#125; &#125; 获取数据操作：1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 Java中的阻塞队列 ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 DelayQueue：使用优先级队列实现的无界阻塞队列。 SynchronousQueue：不存储元素的阻塞队列。 LinkedTransferQueue：由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：由链表结构组成的双向阻塞队列 ArrayBlockingQueue（公平、非公平） 用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。ArrayBlockingQueue fairQueue &#x3D; new ArrayBlockingQueue(1000,true); LinkedBlockingQueue（两个独立锁提高并发） 基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 PriorityBlockingQueue（compare to排序实现优先） 是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 DelayQueue（缓存失效、定时任务） 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景。 缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。 定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 SynchronousQueue（不存储数据、可用于传递数据） 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和ArrayBlockingQueue。 LinkedTransferQueue 是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。 transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在工作窃取模式中。 CyclicBarrier、CountDownLatch、Semaphore用法CountDownLatch（线程计数器） CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能了。 final CountDownLatch latch = new CountDownLatch(2); new Thread()&#123; public void run() &#123; System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;); Thread.sleep(3000); System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;); latch.countDown(); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;); Thread.sleep(3000); System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;); latch.countDown(); &#125;; &#125;.start(); System.out.println(&quot;等待 2 个子线程执行完毕...&quot;); latch.await(); System.out.println(&quot;2 个子线程已经执行完毕&quot;); System.out.println(&quot;继续执行主线程&quot;); CycliBarrier（回环栅栏-等待至barrier状态再全部同时执行） 字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本： public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务； public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。具体使用如下，另外 CyclicBarrier 是可以重用的：public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++) new Writer(barrier).start(); &#125; static class Writer extends Thread&#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作 System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完 毕，等待其他线程写入完毕&quot;); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;catch(BrokenBarrierException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;); &#125; &#125; Semaphore（信号量-控制同时访问的线程个数） Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore 类中比较重要的几个方法。 public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 public void acquire(int permits):获取 permits 个许可 public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 public void release(int permits) { }:释放 permits 个许可上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法 public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false 还可以通过 availablePermits()方法得到可用的许可数目。例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现： int N = 8; //工人数 Semaphore semaphore = new Semaphore(5); //机器数目 for(int i=0;i&lt;N;i++)&#123; new Worker(i,semaphore).start(); &#125; static class Worker extends Thread&#123; private int num; private Semaphore semaphore; public Worker(int num,Semaphore semaphore)&#123; this.num = num; this.semaphore = semaphore; &#125; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;); Thread.sleep(2000); System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的 Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。 volatile关键字的作用（变量可见性、禁止重排序） Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。变量可见性其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。禁止重排序volatile 禁止了指令重排。比 sychronized 更轻量级的同步锁在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。适用场景值得说明的是对 volatile 变量的单次读&#x2F;写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag &#x3D; true）。（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。 如何在两个线程之间共享数据 Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到同步和互斥。有以下常规实现方法：将数据抽象成一个类，并将数据的操作作为这个类的方法 将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加“synchronize” Runnable 对象作为一个类的内部类：将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。public class MyData &#123; private int j=0; public synchronized void add()&#123; j++; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;j 为：&quot;+j); &#125; public synchronized void dec()&#123; j--; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;j 为：&quot;+j); &#125; public int getData()&#123; return j; &#125; &#125; public class AddRunnable implements Runnable&#123; MyData data; public AddRunnable(MyData data)&#123; this.data= data; &#125; public void run() &#123; data.add(); &#125; &#125; public class DecRunnable implements Runnable &#123; MyData data; public DecRunnable(MyData data)&#123; this.data = data; &#125; public void run() &#123; data.dec(); &#125; &#125; public static void main(String[] args) &#123; MyData data = new MyData(); Runnable add = new AddRunnable(data); Runnable dec = new DecRunnable(data); for(int i=0;i&lt;2;i++)&#123; new Thread(add).start(); new Thread(dec).start(); &#125; &#125; public class MyData &#123; private int j=0; public synchronized void add()&#123; j++; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;j 为：&quot;+j); &#125; public synchronized void dec()&#123; j--; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;j 为：&quot;+j); &#125; public int getData()&#123; return j; &#125; &#125; public class TestThread &#123; public static void main(String[] args) &#123; final MyData data = new MyData(); for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; public void run() &#123; data.add(); &#125; &#125;).start(); new Thread(new Runnable()&#123; public void run() &#123; data.dec(); &#125; &#125;).start(); &#125; &#125; &#125; ThreadLocal作用（线性本地存储） ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。ThreadLocalMap（线程的一个属性） 每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;使用场景最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException &#123; Session s = (Session) threadSession.get(); try &#123; if (s == null) &#123; s = getSessionFactory().openSession(); threadSession.set(s); &#125; &#125; catch (HibernateException ex) &#123; throw new InfrastructureException(ex); &#125; return s; &#125; Synchronized 和 ReentrantLock 的区别两者的共同点 都是用来协调多线程对共享对象、变量的访问 都是可重入锁，同一线程可以多次获得同一个锁 都保证了可见性和互斥性 两者的不同点 ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的 ReentrantLock 可以实现公平锁 ReentrantLock 通过 Condition 可以绑定多个条件 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略 Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 ConcurrentHashMap并发减小锁粒度 减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。 ConcurrentHashMap分段锁 ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，即就是锁的并发度。如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。 Java中用到的线程调度抢占式调度 抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。 协同式调度 协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。 jvm的线程调度实现（抢占式调度） java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。 线程让出CPU的情况 当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I&#x2F;O 上。 当前运行线程结束，即运行完 run()方法里面的任务。 进程调度算法优先调度算法 先来先服务调度算法（FCFS） 当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 短作业(进程)优先调度算法短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。 高优先权优先调度算法 为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。 非抢占式优先权算法在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 抢占式优先权调度算法在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。 高响应比优先调度算法 在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。 基于时间片的轮转调度算法 时间片轮转法在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 多级反馈队列调度算法(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。 什么是CAS（比较并交换-乐观锁机制-锁自旋）概念及特性 CAS（Compare And Swap&#x2F;Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 原子包java.util.concurrent.atomic（锁自旋） JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码： public class AtomicInteger extends Number implements java.io.Serializable &#123; private volatile int value; public final int get() &#123; return value; &#125; public final int getAndIncrement() &#123; for (;;) &#123; //CAS 自旋，一直尝试，直达成功 int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; &#125; &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; &#125; getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成CPU 指令的操作。 ABA问题 CAS 会导致ABA 问题。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。 什么是AQS（抽象的队列同步器） AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch。它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种: getState() setState() compareAndSetState() AQS 定义两种资源共享方式Exclusive 独占资源-ReentrantLockExclusive（独占，只有一个线程能执行，如 ReentrantLock）Share 共享资源-Semaphore&#x2F;CountDownLatShare（共享，多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch）。AQS 只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get&#x2F;set&#x2F;CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false 同步器的实现是 ABS 核心（state 资源状态计数）同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。ReentrantReadWriteLock 实现独占和共享两种方式一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquired-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"idea推介插件","slug":"系统配置/编程配置/环境配置/Idea配置/idea好用的插件","date":"2022-12-16T14:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-hao-yong-de-cha-jian.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/idea-pei-zhi/idea-hao-yong-de-cha-jian.html","excerpt":"","text":"idea好用的插件Alibaba Java Coding Guidelines阿里代码规范检查工具 CodeGlance2代码缩略图 Easy Javadoc自动生成类和方法的注释 Gitee将项目分享至gitee将gitee项目克隆值idea LeetCode EditorLeetCode刷题 Maven Helper解决maven jar包冲突问题 MyBatisX快速生成实体类、mapper、mapper.xml、service、serviceimpl代码 RestfulTool帮助基于restful服务开发的插件查看请求路径，在项目运行之后还能发送请求查看返回结果 SequenceDiagram生成时序图 Show comment显示注解，在方法上写好注解后，以后用到该方法的地方会看到写好的注解 statistic统计代码量 Tabnine生成代码提示 Translation翻译插件 Rainbow Brackets彩虹括号，以不同的颜色显示每队括号，方便括号配对","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"03.vue项目布局","slug":"编程语言/Java/项目/从零开始搭建前后端分离项目/Vue/03.Vue项目结构","date":"2022-12-14T16:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/03.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/03.html","excerpt":"","text":"vue项目布局Element-plusHelloWorld组件删掉，再把HomeView内相关的内容删一删，App.vue内样式全部删掉如果报错，可能是由于权限不够，复制报错信息上网查找解决方案即可全局引入element-plus再次运行项目选择这里的代码，复制到App.vue &lt;template&gt; &lt;div class=&quot;common-layout&quot;&gt; &lt;el-container&gt; &lt;el-header&gt; Header &lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view/&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent&#125; from &#x27;vue&#x27;;export default defineComponent(&#123; components: &#123; &#125;,&#125;);&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 现在就是页面暂时的结构由于项目会涉及到图标，继续下载 npm install @element-plus/icons-vue // main.ts// 如果您正在使用CDN引入，请删除下面一行。import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125; 测试一下图标是否安装好了 &lt;!-- Home --&gt;&lt;el-row&gt; &lt;el-button icon=&quot;Search&quot; circle/&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;Edit&quot; circle/&gt; &lt;el-button type=&quot;success&quot; icon=&quot;Check&quot; circle/&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Message&quot; circle/&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;Star&quot; circle/&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;Delete&quot; circle/&gt;&lt;/el-row&gt;import &#123; Check, Delete, Edit, Message, Search, Star,&#125; from &#x27;@element-plus/icons-vue&#x27;&lt;!-- main.ts --&gt;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125; 可以看到可以正常使用，控制台也没报错 &lt;!-- 图标若不显示 --&gt;&lt;!-- 将标签中的 :icon 改为icon即可 --&gt; 新建一个头部组件component下新建Header.vue &lt;template&gt; &lt;div style=&quot;height: 50px;line-height: 50px;border-bottom: 1px solid #ccc;display: flex&quot;&gt; &lt;div style=&quot;width: 200px;padding-left:30px;font-weight: bold;color:dodgerblue&quot;&gt;管理系统&lt;/div&gt; &lt;div style=&quot;flex: 1&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width: 150px;margin-top: 10px;&quot;&gt; &lt;el-dropdown trigger=&quot;click&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; 深海火锅店&lt;el-icon class=&quot;el-icon--right&quot;&gt;&lt;arrow-down/&gt;&lt;/el-icon&gt; &lt;/span&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu&gt; &lt;el-dropdown-item icon=&quot;UserFilled&quot;&gt; 个人信息 &lt;/el-dropdown-item&gt; &lt;el-dropdown-item icon=&quot;SwitchButton&quot; @click=&quot;logout&quot;&gt; 退出登录 &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;import &#123; h &#125; from &#x27;vue&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123; ArrowDown, Check, CircleCheck, CirclePlus, CirclePlusFilled, Plus,&#125; from &#x27;@element-plus/icons-vue&#x27;export default &#123; name: &quot;Header&quot;, setup() &#123; const activeIndex = ref(&#x27;1&#x27;) const activeIndex2 = ref(&#x27;1&#x27;) const handleSelect = (key: string, keyPath: string[]) =&gt; &#123; console.log(key, keyPath) &#125; const logout=()=&gt;&#123; ElMessageBox(&#123; title: &#x27;提示&#x27;, message: h(&#x27;p&#x27;, null, [ h(&#x27;span&#x27;, null, &#x27;您即将&#x27;), h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;退出登录&#x27;), ]), showCancelButton: true, confirmButtonText: &#x27;确认&#x27;, cancelButtonText: &#x27;取消&#x27;, beforeClose: (action, instance, done) =&gt; &#123; if (action === &#x27;confirm&#x27;) &#123; instance.confirmButtonLoading = true instance.confirmButtonText = &#x27;Loading...&#x27; setTimeout(() =&gt; &#123; done() setTimeout(() =&gt; &#123; instance.confirmButtonLoading = false &#125;, 300) &#125;, 3000) &#125; else &#123; done() &#125; &#125;, &#125;).then((action) =&gt; &#123; ElMessage(&#123; type: &#x27;info&#x27;, message: `action: $&#123;action&#125;`, &#125;) &#125;) &#125; return &#123;activeIndex, activeIndex2, handleSelect,logout&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 暂时是定死了名字，用户名字是深海火锅店，以后再更改此时我们发现文字和顶部之间有一段距离在asset下新建css文件夹，css下新建global.css文件【右键新建，stylesheet，选择add】 *&#123; margin: 0; padding: 0; box-sizing: border-box;&#125; 在main.ts中引入 // import &#x27;@/assets/css/global.css&#x27;添加这句话--------------import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;import &#x27;@/assets/css/global.css&#x27;// @ts-ignoreimport zhCn from &#x27;element-plus/dist/locale/zh-cn.mjs&#x27;const app = createApp(App)app.use(store)app.use(router)app.use(ElementPlus)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125;app.mount(&#x27;#app&#x27;)app.use(ElementPlus, &#123; locale: zhCn,&#125;) 再新建左侧导航栏Aside.vue &lt;template&gt; &lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot;&gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt; &lt;location/&gt; &lt;/el-icon&gt; &lt;span&gt;学生信息管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group title=&quot;Group One&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;item two&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;Group Two&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;item three&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-sub-menu index=&quot;1-4&quot;&gt; &lt;template #title&gt;item four&lt;/template&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;item one&lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item index=&quot;2&quot;&gt; &lt;el-icon&gt; &lt;icon-menu/&gt; &lt;/el-icon&gt; &lt;span&gt;Navigator Two&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;el-icon&gt; &lt;document/&gt; &lt;/el-icon&gt; &lt;span&gt;Navigator Three&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;el-icon&gt; &lt;setting/&gt; &lt;/el-icon&gt; &lt;span&gt;Navigator Four&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; Document, Menu as IconMenu, Location, Setting,&#125; from &#x27;@element-plus/icons-vue&#x27;export default &#123; name: &quot;Aside&quot;, setup() &#123; const handleOpen = (key: string, keyPath: string[]) =&gt; &#123; console.log(key, keyPath) &#125; const handleClose = (key: string, keyPath: string[]) =&gt; &#123; console.log(key, keyPath) &#125; return &#123;handleOpen, handleClose&#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在App.vue中引入header、aside组件 &lt;template&gt; &lt;el-config-provider :locale=&quot;locale&quot;&gt; &lt;slot name=&quot;app&quot;&gt; &lt;div class=&quot;common-layout&quot;&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;Header/&gt; &lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;250px&quot;&gt; &lt;Aside/&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view/&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/slot&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent&#125; from &#x27;vue&#x27;;import Header from &quot;@/components/Header.vue&quot;;import Aside from &quot;@/components/Aside.vue&quot;;import &#123; ElConfigProvider &#125; from &#x27;element-plus&#x27;// 国际化：设置为中文// begin----import zhCn from &#x27;element-plus/lib/locale/lang/zh-cn&#x27;export default defineComponent(&#123; name: &#x27;ZhProvider&#x27;, components: &#123; Header, Aside, [ElConfigProvider.name]: ElConfigProvider &#125;, setup() &#123; let locale = zhCn return &#123; locale &#125; &#125;&#125;);// end----&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 最后完成主页面HomeView.vue &lt;template&gt; &lt;!--功能区域--&gt; &lt;div&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Plus&quot; @click=&quot;openAdd&quot;&gt;新增&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Upload&quot;&gt;导入&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;Download&quot;&gt;导出&lt;/el-button&gt; &lt;/div&gt; &lt;!--搜索区域--&gt; &lt;div style=&quot;margin: 10px 0&quot;&gt; &lt;el-input v-model=&quot;search&quot; placeholder=&quot;请输入关键字&quot; style=&quot;width: 25%&quot; clearable/&gt; &lt;el-button type=&quot;primary&quot; style=&quot;margin-left: 5px&quot; icon=&quot;Search&quot;&gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column fixed prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;150&quot; sortable/&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;/&gt; &lt;el-table-column prop=&quot;age&quot; label=&quot;年龄&quot; width=&quot;120&quot; sortable/&gt; &lt;el-table-column prop=&quot;gender&quot; label=&quot;性别&quot; width=&quot;120&quot;/&gt; &lt;el-table-column prop=&quot;college&quot; label=&quot;学院&quot; width=&quot;120&quot;/&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; width=&quot;300&quot;/&gt; &lt;el-table-column prop=&quot;state&quot; label=&quot;状态&quot; width=&quot;120&quot;/&gt; &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;150&quot;&gt; &lt;template #default&gt; &lt;el-popconfirm type=&quot;warning&quot; title=&quot;确认删除此选项?&quot;&gt; &lt;template #reference&gt; &lt;el-button link type=&quot;warning&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-popconfirm&gt; &lt;el-button link type=&quot;primary&quot; plain size=&quot;small&quot; @click=&quot;handleClick&quot;&gt;查看&lt;/el-button&gt; &lt;el-button link type=&quot;info&quot; size=&quot;small&quot; @click=&quot;editMsg&quot;&gt;编辑&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;hr class=&quot;my-4&quot;/&gt; &lt;!--分页区域--&gt; &lt;div class=&quot;demo-pagination-block&quot; style=&quot;margin: 5px&quot;&gt; &lt;el-pagination v-model:current-page=&quot;currentPage&quot; v-model:page-size=&quot;pageSize&quot; :page-sizes=&quot;[100, 200, 300, 400]&quot; :small=&quot;small&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;400&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;defineComponent&#125; from &#x27;vue&#x27;;import &#123;h,ref&#125; from &#x27;vue&#x27;import &#123; ElMessage, ElMessageBox &#125; from &#x27;element-plus&#x27;import &#123; UploadFilled &#125; from &#x27;@element-plus/icons-vue&#x27;export default defineComponent(&#123; name: &#x27;HomeView&#x27;, components: &#123;&#125;, setup() &#123; /* 查看信息 */ const handleClick = () =&gt; &#123; console.log(&#x27;click&#x27;) ElMessageBox(&#123; title: &#x27;信息&#x27;, message: h(&#x27;p&#x27;, null, [ h(&#x27;span&#x27;, null, &#x27;Message can be &#x27;), h(&#x27;i&#x27;, &#123; style: &#x27;color: teal&#x27; &#125;, &#x27;VNode&#x27;), ]), &#125;) &#125; /* 编辑信息 */ const editMsg = () =&gt; &#123; ElMessageBox.confirm( &#x27;您正在修改他人的个人信息. 是否继续?&#x27;, &#x27;警告&#x27;, &#123; confirmButtonText: &#x27;确认&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27;, &#125; ) .then(() =&gt; &#123; ElMessage(&#123; type: &#x27;success&#x27;, message: &#x27;修改成功&#x27;, &#125;) &#125;) .catch(() =&gt; &#123; ElMessage(&#123; type: &#x27;info&#x27;, message: &#x27;取消修改&#x27;, &#125;) &#125;) &#125; const search = ref(&quot;&quot;); const tableData = [ &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;Tom&#x27;, age: &#x27;12&#x27;, gender: &#x27;女&#x27;, college: &#x27;自动化&#x27;, address: &#x27;No. 189, Grove St, Los Angeles&#x27;, state: &#x27;24小时阴性&#x27;, &#125;, &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;Tom&#x27;, age: &#x27;15&#x27;, gender: &#x27;男&#x27;, college: &#x27;经管&#x27;, address: &#x27;No. 189, Grove St, Los Angeles&#x27;, state: &#x27;24小时阴性&#x27;, &#125;, &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;Tom&#x27;, age: &#x27;12&#x27;, gender: &#x27;女&#x27;, college: &#x27;计算机&#x27;, address: &#x27;No. 189, Grove St, Los Angeles&#x27;, state: &#x27;24小时阴性&#x27;, &#125;, &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;Tom&#x27;, age: &#x27;16&#x27;, gender: &#x27;男&#x27;, college: &#x27;软件工程&#x27;, address: &#x27;No. 189, Grove St, Los Angeles&#x27;, state: &#x27;24小时阴性&#x27;, &#125;, ] const currentPage = ref(1) const pageSize = ref(100) const small = ref(false) const handleSizeChange = (val: number) =&gt; &#123; console.log(`$&#123;val&#125; items per page`) &#125; const handleCurrentChange = (val: number) =&gt; &#123; console.log(`current page: $&#123;val&#125;`) &#125; /* 消息弹出框 */ const openAdd = () =&gt; &#123; ElMessageBox.confirm( &#x27;您希望添加如下内容?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27;, draggable: true, &#125; ) .then(() =&gt; &#123; ElMessage(&#123; type: &#x27;success&#x27;, message: &#x27;Delete completed&#x27;, &#125;) &#125;) .catch(() =&gt; &#123; ElMessage(&#123; type: &#x27;info&#x27;, message: &#x27;Delete canceled&#x27;, &#125;) &#125;) &#125; return &#123; handleClick, editMsg, tableData, search, currentPage, pageSize, small, handleSizeChange, handleCurrentChange, openAdd &#125; &#125;&#125;);&lt;/script&gt; 链接：https://pan.baidu.com/s/11qXNPDQ_87TKmvF8R_RlrQ?pwd=m9fn提取码：m9fn–来自百度网盘超级会员V3的分享","categories":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://isunderachiever.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"docker配置","slug":"系统配置/编程配置/环境配置/Docker配置/docker环境配置","date":"2022-12-14T08:20:00.000Z","updated":"2024-06-01T14:32:53.521Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/docker-pei-zhi/docker-huan-jing-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/docker-pei-zhi/docker-huan-jing-pei-zhi.html","excerpt":"","text":"Docker环境配置 安装VirtualBox 安装vagrant 安装完成vagrant后重启一下系统 验证vagrant是否安装成功 cmd输入vagrant，是否有命令提示 使用vagrant创建虚拟机——官方镜像仓库 vagrant init centos/7 此时在E盘已经生成了一个名为“Vagrantfile”的文件 启动虚拟环境 vagrant up# 如果速度很慢，使用提前下载好的CentOS7镜像，速度嘎嘎快# vagrant init centos/7 # 没初始化的，要初始化vagrant box add centos/7 CentOS-7-x86_64-Vagrant-2004_01.VirtualBox.boxvagrant up ctrl+c停掉 vagrant ssh 提示[vagrant@localhost ~]$ 连接成功，此时已经可以在VirtualBox内查看到该虚拟机若提示 &#118;&#x61;&#103;&#x72;&#97;&#110;&#x74;&#x40;&#x31;&#x32;&#55;&#x2e;&#x30;&#46;&#x30;&#x2e;&#x31;: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).则输入命令set VAGRANT_PREFER_SYSTEM_BIN&#x3D;0 后再重新连接即可退出vagrant的方法：输入命令exit以文本的方式打开Vagrantfile，找到这一行配置 # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; 所以我们需要将虚拟机改为192.168.56.XX即更改为 # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; vagrant reload 重启虚拟机 vagrant sship addr # 查看虚拟机ip地址是否已经发生了改变ping 192.168.xxx # 主机与虚拟机是否互相ping通 安装docker概念：什么是docker？虚拟化容器技术。Docker基于镜像，可以秒级启动各种容器。每一种容器都是一个完整的运行环境，容器之间互相隔离。 docker的镜像市场安装docker vagrant ssh # 连接虚拟机sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine# 卸载旧版本的docker sudo yum install -y yum-utilssudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 过程需要输入y选择确认# 启动dockersudo systemctl start docker# 查看docker版本docker -v# 查看docker安装了哪些镜像sudo docker images# 设置docker开机自启动sudo systemctl enable docker 镜像加速登录阿里云后，进入 控制台，左侧菜单找到 “产品与服务”，选择“容器镜像服务”，选择“镜像工具”，点击“镜像加速器” # 执行以下四个命令sudo mkdir -p /etc/docker#----------------------------------sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://g9nk2v6o.mirror.aliyuncs.com&quot;]&#125;EOF#----------------------------------sudo systemctl daemon-reload#----------------------------------sudo systemctl restart docker 切换root用户每次sudo很麻烦？直接切换root用户 su root# 默认密码是vagrant 连接XShellvagrant ssh# 切换为root用户sudo -i# 修改root用户密码passwdsudo vi /etc/ssh/sshd_config# 找到PasswordAuthentication yes这一行，去掉前面的## # To disable tunneled clear text passwords, change to no here!# PasswordAuthentication yes# #PermitEmptyPasswords no# PasswordAuthentication no# 保存后退出# 重启sshd服务systemctl restart sshd# 使用ssh工具进行连接 详情请查看这篇博客 安装MySQL连接上虚拟机之后在docker镜像仓库搜索mysql，进入tags可查看版本信息 #------- 安装mysql5.7-----------------# docker pull mysql # 会下载最新的mysql# 下载指定版本的mysql，比如5.7# docker pull mysql:5.7sudo docker pull mysql:5.7sudo docker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7# 查看mysql是否运行docker ps# 没有查看到容器# 查看,发现容器是退出状态docker ps -a# Exited# 运行以下命令docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql# 若依然存在问题,可以停用并删除容器,重新启动mysqldocker stop $(docker ps -q)docker rm $(docker ps -aq)# 删除镜像docker rmi 镜像id# docker 删除报错:Error response from daemon: conflict: unable to delete 8e6aee9da407 (must be forced) - image is referenced in multiple repositories# 解决办法docker rmi -f 镜像id# docker 服务命令# 启动：# systemctl start docker# 守护进程重启：# systemctl daemon-reload# 重启docker服务：# systemctl restart docker / service docker restart# 关闭：# docker service docker stop / docker systemctl stop docker# 问题解决之后------# 进入配置文件挂载的目录下cd /mydata/mysql/conf# 编辑配置文件my.cnfvi my.cnf[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;init_connect=&#x27;SET NAMES utf8&#x27;character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve# 重启mysql容器docker restart mysql# 设置启动docker时，mysql自启动docker update mysql --restart=always#------- 安装mysql8.0.20-----------------#拉取镜像docker pull mysql:8.0.20#启动镜像,用于拷贝配置文件到宿主机docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.20#查看是否启动成功docker ps -a#新建挂载目录并拷贝配置文件mkdir -p /mysqldata/docker cp mysql:/etc/mysql /mysqldata/#检查是否运行成功docker ps -a# 重启mysql容器docker restart mysql# 设置启动docker时，mysql自启动docker update mysql --restart=always# 使用Navicat链接mysql# ql自启动docker update mysql --restart=always Redis配置# 下载最新redis镜像docker pull redis mkdir -p /mydata/redis/confcd /mydata/redis/conftouch redis.confdocker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf # 测试一下redisdocker exec -it redis redis-cli # redis默认配置是没有持久化的# 如果重启redis，再获取之前的数据就获取不到了# 具体命令可查看下图vi redis.conf# 【输入 i 进入插入模式】# 开启AOF持久化appendonly yes 修改redis的密码# 创建容器时设置密码# docker run -itd --name redis-6379 -p 6379:6379 redis --requirepass 123456# 为现有的redis创建密码或修改密码#1.进入redis的容器docker exec -it 容器ID bash#2.进入redis目录cd /usr/local/bin#3.运行命令：redis-cli#4.查看现有的redis密码：config get requirepass# 这一步若报错(error) NOAUTH Authentication required.# 是因为redis本身设置有密码，此时需要执行以下命令auth password; # password是之前设置的redis密码#5.设置redis密码config set requirepass 密码# 清空redis密码config set requirepass &quot;&quot; 安装redis可视化工具链接：https://pan.baidu.com/s/10z0S6b9mo76CWK9y3spPRg?pwd=51tz提取码：51tz–来自百度网盘超级会员V3的分享点击New Connection右边的按钮，可进入设置页面，设置语言 docker安装ElasticSearch1.黑马程序员视频内安装方法：链接：https://pan.baidu.com/s/1pGnbmkMjD8RXe5Y4xotfOA?pwd=ihe5提取码：ihe5将其上传到虚拟机中，然后运行命令加载即可： # 导入数据docker load -i es.tar 同理还有kibana的tar包也需要这样做。运行docker命令，部署单点es： docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置运行docker命令，部署kibanadocker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置kibana启动一般比较慢，需要多等待一会，可以通过命令：docker logs -f kibana 查看运行日志，当查看到下面的日志，说明成功： 2.网上的安装方法：# 下载镜像文件docker pull elasticsearch:7.4.2# 创建搭载目录mkdir -p /mydata/elasticsearch/configmkdir -p /mydata/elasticsearch/dataecho &quot;http.host: 0.0.0.0&quot; &gt; /mydata/elasticsearch/config/elasticsearch.ymldocker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\-e &quot;discovery.type=single-node&quot; \\-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-d elasticsearch:7.4.2docker ps# 查看容器状态 up 运行 若存在问题，查看这篇博客我这里的问题是启动的时候没问题，但是过一会有自动关闭解决问题和上方博客中写的一样 chmod -R 777 /mydata/elasticsearch/docker start elasticsearch 查看运行结果http:&#x2F;&#x2F;虚拟机ip地址:9200&#x2F; 安装Kibana# 下载镜像文件docker pull kibana:7.4.2# 安装容器docker run --name kibana -e ELASTICSEARCH_HOSTS=http://自己的IP:9200 -p 5601:5601 -d kibana:7.4.2 安装ik分词器ik分词器下载地址 3.1.在线安装ik插件（较慢）# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: docker volume inspect es-plugins 显示结果： [ &#123; &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。 2）解压缩分词器安装包下面我们需要把课前资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data ： 4）重启容器# 4、重启容器docker restart es # 查看es日志docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;&#125; 结果：&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;黑马&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;程序员&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;程序&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125;, &#123; &quot;token&quot; : &quot;员&quot;, &quot;start_offset&quot; : 4, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 3 &#125;, &#123; &quot;token&quot; : &quot;学习&quot;, &quot;start_offset&quot; : 5, &quot;end_offset&quot; : 7, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 4 &#125;, &#123; &quot;token&quot; : &quot;java&quot;, &quot;start_offset&quot; : 7, &quot;end_offset&quot; : 11, &quot;type&quot; : &quot;ENGLISH&quot;, &quot;position&quot; : 5 &#125;, &#123; &quot;token&quot; : &quot;太棒了&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 6 &#125;, &#123; &quot;token&quot; : &quot;太棒&quot;, &quot;start_offset&quot; : 11, &quot;end_offset&quot; : 13, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 7 &#125;, &#123; &quot;token&quot; : &quot;了&quot;, &quot;start_offset&quot; : 13, &quot;end_offset&quot; : 14, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 8 &#125; ]&#125; 3.3 扩展词词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。1）打开IK分词器config目录：2）在IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 传智播客奥力给 4）重启elasticsearch docker restart es# 查看 日志docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件5）测试效果： GET /_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;&#125; 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"mysql复习","slug":"数据库/MySQL/MySQL常用命令/MySQL常用命令","date":"2022-12-13T16:00:00.000Z","updated":"2024-06-01T14:32:53.519Z","comments":true,"path":"/shu-ju-ku/mysql/mysql-chang-yong-ming-ling/mysql-chang-yong-ming-ling.html","link":"","permalink":"https://isunderachiever.github.io/shu-ju-ku/mysql/mysql-chang-yong-ming-ling/mysql-chang-yong-ming-ling.html","excerpt":"","text":"mysql复习# mysql服务的启动和停止net stop mysqlnet start mysql # 新增用户# grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;grant select,insert,update,delete on . to user@localhost Identified by “password”;# 显示库中的数据表user demo; # demo数据库show tables;# 显示数据表的结构# describe 表名;describe user;# 导出数据mysqldump --opt test &gt; mysql.test# 即将数据库test数据库导出到mysql.test文本文件# 例：mysqldump -u root -p用户密码 --databases dbname &gt; mysql.dbname# 导入数据mysqlimport -u root -p用户密码 &lt; mysql.dbname。# 将文本数据导入数据库# 文本数据的字段数据之间用tab键隔开。use test;load data local infile &quot;文件名&quot; into table 表名; # 创建表# 方法1：create table user( id int auto_increment primary key comment &#x27;用户表主键&#x27; check ( id &gt; 0 ), username varchar(255) not null comment &#x27;用户账号&#x27;, password varchar(255) not null comment &#x27;用户密码&#x27;);# 方法2：create table user( id int auto_increment comment &#x27;用户表主键&#x27;, username varchar(255) not null comment &#x27;用户账号&#x27;, password varchar(255) not null comment &#x27;用户密码&#x27;, constraint primary key (id));# 删除表drop table user;# 更改表# 1.更改表名alter table user rename to u;# 2.增加列alter table u add column is_deleted tinyint not null;# 3.删除列alter table u drop column is_deleted;# 4.更改列属性alter table u modify column password int;# 5.更改列名alter table u rename column password to pwd;# 查询表select id, username, pwdfrom u;# 插入一行数据insert into u (username, pwd)values (&#x27;admin&#x27;, 123456);# 删除一行数据deletefrom uwhere id = 1;# 更改一行数据# 修改了多行数据，应该用逗号连接，而非andupdate uset username=&#x27;abc&#x27;, pwd=123where id = 2;# 约束条件# -- 1.not null# -- 2.unique# -- 3.primary key# -- 4.foreign key# -- 5.default# 添加not null约束alter table u modify pwd int not null;# 删除not null约束alter table u modify pwd int;# 添加unique约束alter table u add unique (pwd);# 删除unique约束alter table u drop index pwd;# 添加foreign key约束alter table people add constraint fk_uid foreign key (user_id) references u (id);# 删除foreign key约束alter table people drop foreign key fk_uid;# 添加default约束alter table u alter password set default 123456;# 删除default约束alter table u alter password drop default;# 索引# 在u表的username列上建立名为u_index的索引create index u_index on u (username);# 删除u_index索引alter table u drop index u_index;# 视图# 创建视图create view v_u asselect usernamefrom u;# 删除视图drop view v_u;# 更新视图create view v_u asselect username, passwordfrom u;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://isunderachiever.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://isunderachiever.github.io/tags/mysql/"}]},{"title":"人人开源配置","slug":"编程语言/Java/项目/人人开源/人人开源","date":"2022-12-13T09:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/ren-ren-kai-yuan/ren-ren-kai-yuan.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/ren-ren-kai-yuan/ren-ren-kai-yuan.html","excerpt":"","text":"进入人人开源，用git的方式下载三个项目 renren-fast renren-fast-vue renren-generator renren-fast新建renren-fast数据库，并执行mysql.sql内的sql语句 这里前端项目报错了，解决方法如下：cnpm install -g node-gypnpm install --global --production windows-build-tools 如果一直卡在Successfully installed Python 2.7不动。我电脑的解决方法是 npm install --global --production windows-build-tools@4.0.0 如果还解决不了，请看这篇博客 若后端启动报错报错信息：jar:file:&#x2F;D:&#x2F;apache-maven-3.5.3&#x2F;repository&#x2F;javax&#x2F;servlet&#x2F;servlet-api…表示jar包冲突，我的解决方法是先去repository删了这些包，然后重新在项目中下载运行renren-fast和renren-fast-vue两个项目，前者是后端项目，后者是前端项目账号和密码都是admin renren-generator先去配置数据库的信息以demo数据库为例：新建一个springboot项目，来操作demo数据库的这几个表springcloud涉及到多个数据库，则需要创建多个项目来对应每个数据库【项目与数据库一一对应】【微服务还需要导入openfeign依赖】打开generator.properties进行配置运行项目直接复制生成的main文件夹，粘贴到项目的main处有不少报错，别急，这是因为缺少了一些工具包和相应的依赖考虑到各种原因，删除刚刚生成的内容我们将工具包和其他依赖【如mybatis-plus、lombok等通用的依赖】集成成一个springboot项目将其他springboot的公共依赖、公共包进行整合复制粘贴renren-fast&#x2F;renren-generator内的类即可在renren-common中导入依赖 &lt;!--mybatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.24&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpcore&lt;/artifactId&gt; &lt;version&gt;4.4.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt; 在demo示例项目中导入renren-common的依赖 &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;renren-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在运行项目前，还需要在demo配置mysql的连接 # 应用名称spring.application.name=demo# 应用服务 WEB 访问端口server.port=8080# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址spring.datasource.url=jdbc:mysql://localhost:3306/demo?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456# 配置mybatis-plus 打印sql日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl# xml文件路径mybatis-plus.mapper-locations=classpath:/mapper/**/*.xml# 配置最新全局配置文件#mybatis-plus.config-location=classpath:mybatis-config.xml# 配置mybatis-plus 包路径mybatis-plus.type-aliases-package=com.example.demo.domain# mybatis-plus下划线转驼峰配置，默认为truemybatis-plus.configuration.map-underscore-to-camel-case=true# 配置全局默认主键类型，实体类不用加@TableId(value =&quot;id&quot;,type = IdType.AUTO)mybatis-plus.global-config.db-config.id-type=auto# 逻辑删除 （1为删除，0为未删除）mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0# 如果java实体类没加注解@TableLogic，则可以配置这个，推介这里配置mybatis-plus.global-config.db-config.logic-delete-field=isDeleted 运行demo项目链接：https://pan.baidu.com/s/1OP2oPB1onrzMMai7jOmneg?pwd=j4nw提取码：j4nw–来自百度网盘超级会员V3的分享","categories":[{"name":"人人开源","slug":"人人开源","permalink":"https://isunderachiever.github.io/categories/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"人人开源","slug":"人人开源","permalink":"https://isunderachiever.github.io/tags/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/"}]},{"title":"git配置","slug":"系统配置/编程配置/环境配置/Git配置/git配置","date":"2022-12-13T07:00:00.000Z","updated":"2024-06-01T14:32:53.520Z","comments":true,"path":"/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/git-pei-zhi/git-pei-zhi.html","link":"","permalink":"https://isunderachiever.github.io/xi-tong-pei-zhi/bian-cheng-pei-zhi/huan-jing-pei-zhi/git-pei-zhi/git-pei-zhi.html","excerpt":"","text":"git环境配置安装一路默认即可【一直next】在桌面右键，多出了Git Bash Here # 打开Git Bash Here，复制命令并粘贴，右键paste# 配置用户名【填写自己的用户名】git config --global user.name &quot;your username&quot;# 配置邮箱【填写自己的邮箱】git config --global user.email &quot;your email&quot; 同时配置gitee和github参考博客 git config --global --unset user.name &quot;你的名字&quot;git config --global --unset user.email &quot;你的邮箱&quot; 生成新的 SSH keysGithubssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;xxx@qq.com&quot; 按三次回车 Gitee邮箱换一个，不与Github邮箱相同即可 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;xxx@aliyun.com&quot; 按三次回车完成后会在~&#x2F;.ssh &#x2F; 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pubssh-agent bashssh-add ~/.ssh/id_rsa.githubssh-add ~/.ssh/id_rsa.gitee 创建一个名为config的文件，不带后缀，以文本形式打开，写入如下内容#Default gitHub user SelfHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github# giteeHost gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 添加 ssh到github和gitee中ssh -T git@gitee.comssh -T git@github.com 输入yes 补充 说一下我遇到的问题，我是全程开着加速器的，毕竟github的特殊性…但是最后这一步测试github的连接始终是连不上，Connection reset by 140.82.114.4 port 22 $ ping github.comPinging github.com [140.82.114.4] with 32 bytes of data:Reply from 140.82.114.4: bytes=32 time=270ms TTL=41Request timed out.Reply from 140.82.114.4: bytes=32 time=273ms TTL=41Reply from 140.82.114.4: bytes=32 time=273ms TTL=41Ping statistics for 140.82.114.4: Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),Approximate round trip times in milli-seconds: Minimum = 270ms, Maximum = 273ms, Average = 272ms 看来确实是有问题的 配置一下hosts文件就连上了hosts文件在C:\\Windows\\System32\\drivers\\etc点击测速，搜索github.com 如我这里是20.205.243.166则在hosts文件里添加20.205.243.166 github.com $ ssh -T git@github.comThe authenticity of host &#x27;github.com (140.82.114.4)&#x27; can&#x27;t be established.ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.This key is not known by any other names.Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.Hi IsUnderAchiever! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 但是github克隆项目还是报错，开不开‘特殊手段’都是这样 $ git clone https://github.com/nodejs/node.gitCloning into &#x27;node&#x27;...fatal: unable to access &#x27;https://github.com/nodejs/node.git/&#x27;: Failed to connect to github.com port 443 after 21049 ms: Couldn&#x27;t connect to server 只配置gitee或github 以gitee为例，github类似配置ssh免密登录 ssh-keygen -t rsa -C &quot;your email&quot;# 按三次回车后，生成密钥【在用户目录下】cat ~/.ssh/id_rsa.pub# 查看密钥# 复制以上密钥# 进入gitee，左侧找到SSH公钥，添加标题（自己随便写一个），公钥复制粘贴上一步查看的内容（注意不要携带空格）# 测试是否成功 (选择yes)ssh -T git@gitee.com","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"02.vue项目简述","slug":"编程语言/Java/项目/从零开始搭建前后端分离项目/Vue/02.Vue项目简述","date":"2022-12-11T14:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/02.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/02.html","excerpt":"","text":"编译App.vue之后，通过这个index.html来显示 access是存放静态资源的地方，比如图片、css、js component是存放组件的地方如图，HelloWorld.vue是一个组件，通过export导出后在其他vue文件中引用比如某宝等购物平台，页面的头部和底部基本不变，所以可以做成组件后在其他vue文件中直接引用 index.js【index.ts】是写路由的地方实际上是将url路径和页面进行映射，通过url路径来访问页面比如：输入localhost:8080&#x2F; 会显示HomeView.vue的内容输入localhost:8080&#x2F;about 会显示AboutView.vue的内容 store则是用来定义页面的一些变量比如，登录之后的用户信息、页面之间跳转的时候需要携带的参数等都可以放在store内 view是存放视图的地方，上图中就引入了HelloWorld组件 在components中定义HelloWorld组件 然后通过import的方式进行导入 最后可以通过&lt;HelloWorld&#x2F;&gt;这样的标签进行使用图中msg可以在HelloWorld中找到图中HomeView中将msg传入HelloWorld中，然后通过胡子语法来使用，即","categories":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://isunderachiever.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"01.新建vue项目","slug":"编程语言/Java/项目/从零开始搭建前后端分离项目/Vue/01.新建vue","date":"2022-12-11T13:00:00.000Z","updated":"2024-06-01T14:32:53.518Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/01.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/cong-ling-kai-shi-da-jian-qian-hou-duan-fen-chi-xiang-mu/vue/01.html","excerpt":"","text":"node环境配置略过，如果有安装多个版本的nodejs的需求，建议安装一个nvmnvm和nodejs的安装配置在CSDN上都可以找到我这里使用nvm安装了两个版本的nodejs，正在使用的是16.13.2版本 # node版本切换回14.17.2版本nvm user 14.17.2# 查询可以安装的所有nodejs的版本nvm list available# 安装最新稳定版nvm install stable# 安装nodejs，version是版本号 例如：nvm install 14.17.2nvm install &lt;version&gt;# 卸载nodejs，卸载指定版本的nodejs，当安装失败时卸载使用nvm uninstall &lt;version&gt; 新建vue项目 新建文件夹“springboot+vue框架” 在文件夹内cmdvue的项目名为springboot-vue-demovue create springboot-vue-demo 选择manually select features 手动创建 按空格选择以上依赖，回车下一步 选择3.X 分别按照上述图片来输入y和n，最后一个是 选择是否保存本次的配置为模板（下次创建可直接选定这些配置），可选可不选 项目创建成功，可输入这两个命令来运行vue项目cd springboot-vue-demonpm run serve 使用idea打开“springboot+vue框架”这个文件夹【根目录】 在idea中配置vue项目的运行环境 package.json和scripts需要配置 选择server后，点击“运行” 在浏览器输入http://localhost:8080/ 即可访问前端项目","categories":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://isunderachiever.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"}]},{"title":"Vue + SpringBoot + MyBatis 音乐网站","slug":"编程语言/Java/项目/基于SpringBoot的项目/音乐网站/1","date":"2022-11-28T14:00:00.000Z","updated":"2024-06-01T14:12:25.010Z","comments":true,"path":"/bian-cheng-yu-yan/java/xiang-mu/ji-yu-springboot-de-xiang-mu/yin-le-wang-zhan/1.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xiang-mu/ji-yu-springboot-de-xiang-mu/yin-le-wang-zhan/1.html","excerpt":"","text":"非常棒的一个项目！难度不高，大佬真的厉害！Yin-Hongwei &#x2F; music-websiteVue + SpringBoot + MyBatis 音乐网站大佬github的链接：https://github.com/Yin-Hongwei/music-website","categories":[{"name":"springboot项目","slug":"springboot项目","permalink":"https://isunderachiever.github.io/categories/springboot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Java Web项目","slug":"Java-Web项目","permalink":"https://isunderachiever.github.io/tags/Java-Web%E9%A1%B9%E7%9B%AE/"}]},{"title":"新建SpringBoot项目","slug":"编程语言/Java/学习/框架/SpringBoot/新建springboot项目","date":"2022-11-27T03:00:00.000Z","updated":"2024-06-01T14:32:53.424Z","comments":true,"path":"/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/xin-jian-springboot-xiang-mu.html","link":"","permalink":"https://isunderachiever.github.io/bian-cheng-yu-yan/java/xue-xi/kuang-jia/springboot/xin-jian-springboot-xiang-mu.html","excerpt":"","text":"新建SpringBoot项目下文包括使用sts、idea新建SpringBoot项目，并编写登录逻辑以及测试 新建SpringBoot项目 使用Spring Tool Suite右键新建，选择Spring Starter Project注意：其实不安装lombok插件也没什么，手动给get、set方法 和 有参、无参的构造方法即可 sts 的lombok插件需要自己安装jar包，安装过程上网查找，这里不再多说；idea的插件安装 同 使用IDEA 右键新建，选择Spring Initializr (无法访问spring官网可以选择custom，https://start.aliyun.com) 更正： 这里我有mybatis-plus，我也不知道为啥，据说正常情况是没有的，重装系统之后又没有了 如果没有mybatis-plus选择，可直接在pom.xml导入如下依赖即可 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 进入pom.xml，导入mybatis-plus自动生成的依赖 导入依赖后保存，sts保存后自动下载，idea需要点击右上角的 “M” 按钮，Load Maven Changes &lt;!--MyBatis-plus自动生成--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--velocity--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 编写自动生成类，可自动生成简易版的（domain、mapper、mapper_xml、service、serviceimpl、controller）如果想要生成比较完全的，可以去gitee上搜索“人人开源”，找到renren-generator，这个可以生成更完全，甚至可以生成前端的代码 import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;public class MyBatisPlusGenerator &#123; public static void main(String[] args) &#123; //1. 全局配置 GlobalConfig config = new GlobalConfig(); // 是否支持AR模式 config.setActiveRecord(true) // 生成路径，最好使用绝对路径，window路径是不一样的 //TODO TODO TODO TODO .setOutputDir(&quot;D:\\demo\\src\\main\\java&quot;) // 文件覆盖 .setFileOverride(true) // 主键策略 .setIdType(IdType.AUTO) .setDateType(DateType.ONLY_DATE) // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的 .setServiceName(&quot;%sService&quot;) //实体类结尾名称 .setEntityName(&quot;%s&quot;) //生成基本的resultMap .setBaseResultMap(true) //不使用AR模式 .setActiveRecord(false) //生成基本的SQL片段 .setBaseColumnList(true); //2. 数据源配置 DataSourceConfig dsConfig = new DataSourceConfig(); // 设置数据库类型 dsConfig.setDbType(DbType.MYSQL) .setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;) //TODO TODO TODO TODO .setUrl(&quot;jdbc:mysql://127.0.0.1:3306/demo?useSSL=false&quot;) .setUsername(&quot;root&quot;) .setPassword(&quot;123456&quot;); //3. 策略配置globalConfiguration中 StrategyConfig stConfig = new StrategyConfig(); //全局大写命名 stConfig.setCapitalMode(true) // 数据库表映射到实体的命名策略(驼峰命名) .setNaming(NamingStrategy.underline_to_camel) //使用lombok .setEntityLombokModel(true) //使用restcontroller注解 .setRestControllerStyle(true) // 生成的表, 支持多表一起生成，以数组形式填写 //TODO TODO TODO TODO 两个方式，直接写，或者使用命令行输入 .setInclude(&quot;u&quot;);// .setInclude(&quot;product&quot;,&quot;product_task&quot;,&quot;banner&quot;); //4. 包名策略配置 PackageConfig pkConfig = new PackageConfig(); //TODO TODO TODO TODO 包名策略配置 pkConfig.setParent(&quot;com.example.demo&quot;) .setMapper(&quot;mapper&quot;) .setService(&quot;service&quot;) .setServiceImpl(&quot;service.impl&quot;) .setController(&quot;controller&quot;) .setEntity(&quot;domain&quot;) .setXml(&quot;mapper&quot;); //5. 整合配置 AutoGenerator ag = new AutoGenerator(); ag.setGlobalConfig(config) .setDataSource(dsConfig) .setStrategy(stConfig) .setPackageInfo(pkConfig); //6. 执行操作 ag.execute(); System.out.println(&quot;======= 相关代码生成完毕 ========&quot;); &#125;&#125; 有几个地方根据自己的需求改（标有 &#x2F;&#x2F;TODO TODO 的地方） 生成文件的路径 数据库连接的配置 生成哪几个表 包名策略配置运行main方法，自动生成（需要注意，生成之后注销掉方法，不然等你编写完springboot代码点击运行的时候，可能运行的还是自动生成的代码，导致你刚写完的代码被覆盖） sts 运行完后需要右键刷新一下项目 在src&#x2F;main&#x2F;resources下新建mapper文件夹，将生成的mapper.xml移动到mapper文件夹下 如果不用lombok插件，则需要去掉实体类的注解，自己生成get、set方法 和 有参、无参的构造方法注意@Data注解，不使用lombok插件的都需要自己生成get、set方法，下面使用@Data注解的位置我不再强调了 配置application.properties # 应用名称spring.application.name=demo# 应用服务 WEB 访问端口server.port=8080# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址(demo是我们需要连接的数据库)spring.datasource.url=jdbc:mysql://localhost:3306/demo?serverTimezone=UTC# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=123456 这里我的数据库连接地址这样就可以了，如果你们有问题，需要配置mysql的时区 或者 写完整 # 完整写法(demo是我们需要连接的数据库)spring.datasource.url=jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai 在启动类上加上注解（DemoApplication.java） @MapperScan(&quot;com.example.demo.mapper&quot;) 接下来编写一个简单的登录业务 mapper继承了BaseMapper，有基本的增删改查方法，所以不用管 在service里编写// 登录public Object login(U u); serviceimpl里实现该方法 这里有个问题要说一下。// 如果你不准备改service层 以及 serviceimpl 的继承关系public interface UService extends IService&lt;U&gt;&#123;&#125;@Servicepublic class UServiceImpl extends ServiceImpl&lt;UMapper, U&gt; implements UService &#123;&#125;// extends IService&lt;U&gt; 和 extends ServiceImpl&lt;UMapper, U&gt; 这两处// 那么其实你在 UServiceImpl里不用再自动注入umapper了，如下@Autowiredprivate UMapper umapper;// 在UServiceImpl内，按住ctrl点击ServiceImpl，进入他的源码，你会发现里面有一个baseMapper// 源码内：@Autowiredprotected M baseMapper;// 仔细看看源码你就会发现baseMapper其实就是你的mapper层，所以不用再写mapper层的自动注入了，直接用baseMapper代替// ------------------// 还有一种说法，在service 和 serviceimpl里去掉他的继承关系，就是最原始的serviceimpl 实现 service即可// 使用自动注入mapper的方式在serviceimpl内编写代码public interface UService extends IService&lt;U&gt;&#123;&#125;@Servicepublic class UServiceImpl extends ServiceImpl&lt;UMapper, U&gt; implements UService &#123; @Autowired private UMapper umapper;&#125;// 因为继承IService 和 ServiceImpl实际上增加了耦合性，我们都知道，优秀的代码==高内聚、低耦合// 以上两种写法请自行斟酌 这里我就用第一种了 这里推介一个好用的工具包 hutool，导入依赖&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.10&lt;/version&gt;&lt;/dependency&gt; 新建一个com.example.demo.util文件夹，新建R类@Datapublic class R &#123; private int code; private String message; private String type; private Boolean success; private Object data; public static R success(String message) &#123; R r = new R(); r.setCode(200); r.setMessage(message); r.setSuccess(true); r.setType(&quot;success&quot;); r.setData(null); return r; &#125; public static R success(String message, Object data) &#123; R r = success(message); r.setData(data); return r; &#125; public static R warning(String message) &#123; R r = error(message); r.setType(&quot;warning&quot;); return r; &#125; public static R error(String message) &#123; R r = success(message); r.setSuccess(false); r.setType(&quot;error&quot;); return r; &#125; public static R fatal(String message) &#123; R r = error(message); r.setCode(500); return r; &#125;&#125; 编写serviceimpl@Servicepublic class UServiceImpl extends ServiceImpl&lt;UMapper, U&gt; implements UService &#123; @Override public Object login(U u) &#123; // TODO Auto-generated method stub // 登录的情况 // 1.账号密码为空 // 2.账号未注册 // 3.密码错误 // 4.登陆成功 if(StrUtil.isEmptyIfStr(u)) &#123; return R.error(&quot;账号密码为空&quot;); &#125; QueryWrapper&lt;U&gt; userQuery=new QueryWrapper&lt;&gt;(); // 查找数据库，当数据库中name的值等于u.getName()的时候 userQuery.eq(&quot;name&quot;, u.getName()); // 从数据库中查找到的user（可能为空，即未注册） U user=baseMapper.selectOne(userQuery); if(user==null) &#123; // 用户未注册 return R.error(&quot;用户未注册&quot;); &#125;else &#123; // 登录 成功 or 失败 if(user.getPassword().equals(u.getPassword())) &#123; return R.success(&quot;登陆成功&quot;); &#125;else &#123; return R.error(&quot;密码错误&quot;); &#125; &#125; &#125;&#125; 编写controller@RestController@RequestMapping(&quot;/user&quot;)public class UController &#123; @Autowired private UService uservice; @PostMapping(&quot;/login&quot;) public Object checkLogin(@RequestBody U u) &#123; return uservice.login(u); &#125;&#125; 运行启动类（DemoApplication.java） 目录结构 打开postman进行测试，没有的可以去官网下载，我这里也提供一份 链接：https://pan.baidu.com/s/1PfkZpMb_5zs9adP5TSRXRA?pwd=cc41 提取码：cc41 最后比较一下idea和sts。 sts和eclipse差不多，上手难度低，需要配置的不多。相比之下idea上手难度高一些，需要配置的地方也多一些。 但idea功能更多，比如安装一些插件，lombok、mybatis-plus的插件。建议用idea，编写代码真的比sts舒服很多。","categories":[],"tags":[]}],"categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://isunderachiever.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"开启WSL","slug":"开启WSL","permalink":"https://isunderachiever.github.io/categories/%E5%BC%80%E5%90%AFWSL/"},{"name":"编程语言","slug":"编程语言","permalink":"https://isunderachiever.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Redis","slug":"Redis","permalink":"https://isunderachiever.github.io/categories/Redis/"},{"name":"Docker","slug":"Docker","permalink":"https://isunderachiever.github.io/categories/Docker/"},{"name":"Seata","slug":"Seata","permalink":"https://isunderachiever.github.io/categories/Seata/"},{"name":"Resilience4j","slug":"Resilience4j","permalink":"https://isunderachiever.github.io/categories/Resilience4j/"},{"name":"踩坑","slug":"踩坑","permalink":"https://isunderachiever.github.io/categories/%E8%B8%A9%E5%9D%91/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://isunderachiever.github.io/categories/SpringCloud/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://isunderachiever.github.io/categories/Sentinel/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://isunderachiever.github.io/categories/RabbitMQ/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/categories/elasticsearch/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://isunderachiever.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Mockito","slug":"Mockito","permalink":"https://isunderachiever.github.io/categories/Mockito/"},{"name":"Nginx","slug":"Nginx","permalink":"https://isunderachiever.github.io/categories/Nginx/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://isunderachiever.github.io/categories/Activiti7/"},{"name":"Junit","slug":"Junit","permalink":"https://isunderachiever.github.io/categories/Junit/"},{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/categories/vue3/"},{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Linux命令","slug":"Linux命令","permalink":"https://isunderachiever.github.io/categories/Linux%E5%91%BD%E4%BB%A4/"},{"name":"Vue媒介查询","slug":"Vue媒介查询","permalink":"https://isunderachiever.github.io/categories/Vue%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/"},{"name":"Flowable","slug":"Flowable","permalink":"https://isunderachiever.github.io/categories/Flowable/"},{"name":"activiti","slug":"activiti","permalink":"https://isunderachiever.github.io/categories/activiti/"},{"name":"图床","slug":"图床","permalink":"https://isunderachiever.github.io/categories/%E5%9B%BE%E5%BA%8A/"},{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/categories/React/"},{"name":"实用小技巧 ","slug":"实用小技巧","permalink":"https://isunderachiever.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"map与实体互相转换","slug":"map与实体互相转换","permalink":"https://isunderachiever.github.io/categories/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"name":"apifox","slug":"apifox","permalink":"https://isunderachiever.github.io/categories/apifox/"},{"name":"复习","slug":"复习","permalink":"https://isunderachiever.github.io/categories/%E5%A4%8D%E4%B9%A0/"},{"name":"布局","slug":"布局","permalink":"https://isunderachiever.github.io/categories/%E5%B8%83%E5%B1%80/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://isunderachiever.github.io/categories/thymeleaf/"},{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/categories/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"name":"ORM框架","slug":"ORM框架","permalink":"https://isunderachiever.github.io/categories/ORM%E6%A1%86%E6%9E%B6/"},{"name":"Java基础","slug":"Java基础","permalink":"https://isunderachiever.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"支付宝沙箱支付","slug":"支付宝沙箱支付","permalink":"https://isunderachiever.github.io/categories/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://isunderachiever.github.io/categories/SpringSecurity/"},{"name":"vue需求","slug":"vue需求","permalink":"https://isunderachiever.github.io/categories/vue%E9%9C%80%E6%B1%82/"},{"name":"jsp","slug":"jsp","permalink":"https://isunderachiever.github.io/categories/jsp/"},{"name":"vue","slug":"vue","permalink":"https://isunderachiever.github.io/categories/vue/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://isunderachiever.github.io/categories/SpringMVC/"},{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/categories/Spring6/"},{"name":"SSM","slug":"SSM","permalink":"https://isunderachiever.github.io/categories/SSM/"},{"name":"拦截器","slug":"拦截器","permalink":"https://isunderachiever.github.io/categories/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/categories/java-oracle/"},{"name":"常用配置、工具类","slug":"常用配置、工具类","permalink":"https://isunderachiever.github.io/categories/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Optional使用","slug":"Optional使用","permalink":"https://isunderachiever.github.io/categories/Optional%E4%BD%BF%E7%94%A8/"},{"name":"elastic","slug":"elastic","permalink":"https://isunderachiever.github.io/categories/elastic/"},{"name":"表单校验+异常处理","slug":"表单校验-异常处理","permalink":"https://isunderachiever.github.io/categories/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Spring","slug":"Spring","permalink":"https://isunderachiever.github.io/categories/Spring/"},{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/categories/SpringAOP/"},{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/categories/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"},{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/categories/SpringIOC/"},{"name":"阿里云oss-403","slug":"阿里云oss-403","permalink":"https://isunderachiever.github.io/categories/%E9%98%BF%E9%87%8C%E4%BA%91oss-403/"},{"name":"vue语法检查报错","slug":"vue语法检查报错","permalink":"https://isunderachiever.github.io/categories/vue%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99/"},{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"基本配置","slug":"基本配置","permalink":"https://isunderachiever.github.io/categories/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"},{"name":"前后端分离","slug":"前后端分离","permalink":"https://isunderachiever.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/categories/springcloud/"},{"name":"ps异闻录","slug":"ps异闻录","permalink":"https://isunderachiever.github.io/categories/ps%E5%BC%82%E9%97%BB%E5%BD%95/"},{"name":"mysql","slug":"mysql","permalink":"https://isunderachiever.github.io/categories/mysql/"},{"name":"人人开源","slug":"人人开源","permalink":"https://isunderachiever.github.io/categories/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/"},{"name":"springboot项目","slug":"springboot项目","permalink":"https://isunderachiever.github.io/categories/springboot%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://isunderachiever.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"开启WSL","slug":"开启WSL","permalink":"https://isunderachiever.github.io/tags/%E5%BC%80%E5%90%AFWSL/"},{"name":"Seata","slug":"Seata","permalink":"https://isunderachiever.github.io/tags/Seata/"},{"name":"Resilience4j","slug":"Resilience4j","permalink":"https://isunderachiever.github.io/tags/Resilience4j/"},{"name":"server.port启动端口不生效","slug":"server-port启动端口不生效","permalink":"https://isunderachiever.github.io/tags/server-port%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://isunderachiever.github.io/tags/SpringCloud/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://isunderachiever.github.io/tags/Sentinel/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://isunderachiever.github.io/tags/RabbitMQ/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://isunderachiever.github.io/tags/elasticsearch/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://isunderachiever.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Mockito","slug":"Mockito","permalink":"https://isunderachiever.github.io/tags/Mockito/"},{"name":"Nginx","slug":"Nginx","permalink":"https://isunderachiever.github.io/tags/Nginx/"},{"name":"Activiti7","slug":"Activiti7","permalink":"https://isunderachiever.github.io/tags/Activiti7/"},{"name":"Junit","slug":"Junit","permalink":"https://isunderachiever.github.io/tags/Junit/"},{"name":"vue3","slug":"vue3","permalink":"https://isunderachiever.github.io/tags/vue3/"},{"name":"环境配置","slug":"环境配置","permalink":"https://isunderachiever.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Linux命令","slug":"Linux命令","permalink":"https://isunderachiever.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"Vue媒介查询","slug":"Vue媒介查询","permalink":"https://isunderachiever.github.io/tags/Vue%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2/"},{"name":"Flowable","slug":"Flowable","permalink":"https://isunderachiever.github.io/tags/Flowable/"},{"name":"activiti","slug":"activiti","permalink":"https://isunderachiever.github.io/tags/activiti/"},{"name":"图床","slug":"图床","permalink":"https://isunderachiever.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"React","slug":"React","permalink":"https://isunderachiever.github.io/tags/React/"},{"name":"PO、VO、DAO、BO、DTO、POJO ","slug":"PO、VO、DAO、BO、DTO、POJO","permalink":"https://isunderachiever.github.io/tags/PO%E3%80%81VO%E3%80%81DAO%E3%80%81BO%E3%80%81DTO%E3%80%81POJO/"},{"name":"map与实体互相转换","slug":"map与实体互相转换","permalink":"https://isunderachiever.github.io/tags/map%E4%B8%8E%E5%AE%9E%E4%BD%93%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"name":"apifox","slug":"apifox","permalink":"https://isunderachiever.github.io/tags/apifox/"},{"name":"JavaScript&JQuery复习","slug":"JavaScript-JQuery复习","permalink":"https://isunderachiever.github.io/tags/JavaScript-JQuery%E5%A4%8D%E4%B9%A0/"},{"name":"flex布局","slug":"flex布局","permalink":"https://isunderachiever.github.io/tags/flex%E5%B8%83%E5%B1%80/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://isunderachiever.github.io/tags/thymeleaf/"},{"name":"报错记录","slug":"报错记录","permalink":"https://isunderachiever.github.io/tags/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://isunderachiever.github.io/tags/Hibernate/"},{"name":"Java基础","slug":"Java基础","permalink":"https://isunderachiever.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"支付宝沙箱支付","slug":"支付宝沙箱支付","permalink":"https://isunderachiever.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/"},{"name":"添加【通过XXX打开】的右键菜单","slug":"添加【通过XXX打开】的右键菜单","permalink":"https://isunderachiever.github.io/tags/%E6%B7%BB%E5%8A%A0%E3%80%90%E9%80%9A%E8%BF%87XXX%E6%89%93%E5%BC%80%E3%80%91%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://isunderachiever.github.io/tags/SpringSecurity/"},{"name":"vue需求","slug":"vue需求","permalink":"https://isunderachiever.github.io/tags/vue%E9%9C%80%E6%B1%82/"},{"name":"jsp","slug":"jsp","permalink":"https://isunderachiever.github.io/tags/jsp/"},{"name":"vue","slug":"vue","permalink":"https://isunderachiever.github.io/tags/vue/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://isunderachiever.github.io/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://isunderachiever.github.io/tags/MyBatis/"},{"name":"Spring6","slug":"Spring6","permalink":"https://isunderachiever.github.io/tags/Spring6/"},{"name":"SSM","slug":"SSM","permalink":"https://isunderachiever.github.io/tags/SSM/"},{"name":"拦截器","slug":"拦截器","permalink":"https://isunderachiever.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"java&&oracle","slug":"java-oracle","permalink":"https://isunderachiever.github.io/tags/java-oracle/"},{"name":"常用配置、工具类","slug":"常用配置、工具类","permalink":"https://isunderachiever.github.io/tags/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Optional使用","slug":"Optional使用","permalink":"https://isunderachiever.github.io/tags/Optional%E4%BD%BF%E7%94%A8/"},{"name":" Spring Tools Suite安装及配置","slug":"Spring-Tools-Suite安装及配置","permalink":"https://isunderachiever.github.io/tags/Spring-Tools-Suite%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"name":"tomcat安装及配置","slug":"tomcat安装及配置","permalink":"https://isunderachiever.github.io/tags/tomcat%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"name":"踩坑","slug":"踩坑","permalink":"https://isunderachiever.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Spring","slug":"Spring","permalink":"https://isunderachiever.github.io/tags/Spring/"},{"name":"SpringAOP","slug":"SpringAOP","permalink":"https://isunderachiever.github.io/tags/SpringAOP/"},{"name":"Spring整合MyBatis、Junit及事务","slug":"Spring整合MyBatis、Junit及事务","permalink":"https://isunderachiever.github.io/tags/Spring%E6%95%B4%E5%90%88MyBatis%E3%80%81Junit%E5%8F%8A%E4%BA%8B%E5%8A%A1/"},{"name":"SpringIOC","slug":"SpringIOC","permalink":"https://isunderachiever.github.io/tags/SpringIOC/"},{"name":"谷粒商城","slug":"谷粒商城","permalink":"https://isunderachiever.github.io/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"},{"name":"vue语法检查报错","slug":"vue语法检查报错","permalink":"https://isunderachiever.github.io/tags/vue%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E6%8A%A5%E9%94%99/"},{"name":"java基础","slug":"java基础","permalink":"https://isunderachiever.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"大数据","slug":"大数据","permalink":"https://isunderachiever.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"基本配置","slug":"基本配置","permalink":"https://isunderachiever.github.io/tags/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"},{"name":"springcloud","slug":"springcloud","permalink":"https://isunderachiever.github.io/tags/springcloud/"},{"name":"ps学习","slug":"ps学习","permalink":"https://isunderachiever.github.io/tags/ps%E5%AD%A6%E4%B9%A0/"},{"name":"mysql","slug":"mysql","permalink":"https://isunderachiever.github.io/tags/mysql/"},{"name":"人人开源","slug":"人人开源","permalink":"https://isunderachiever.github.io/tags/%E4%BA%BA%E4%BA%BA%E5%BC%80%E6%BA%90/"},{"name":"Java Web项目","slug":"Java-Web项目","permalink":"https://isunderachiever.github.io/tags/Java-Web%E9%A1%B9%E7%9B%AE/"}]}